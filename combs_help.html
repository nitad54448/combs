<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combs Indexing - Technical Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --text-light: #f3f4f6;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --content-bg: #ffffff;
            --content-text: #1f2937;
            --content-heading: #111827;
            --code-bg: #f3f4f6;
            --code-text: #111827;
        }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--content-bg);
            color: var(--content-text); line-height: 1.7; display: flex;
            height: 100vh; overflow: hidden;
        }
        #left-panel {
            width: 280px; flex-shrink: 0; background-color: var(--dark-bg);
            color: var(--text-medium); padding: 2rem; overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        #left-panel .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--text-light);
            margin-bottom: 2rem;
        }
        #left-panel .logo span { color: var(--primary-accent); }
        #toc { list-style: none; padding: 0; margin: 0; }
        #toc li a {
            display: block; color: var(--text-dark); text-decoration: none;
            padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 500;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            border-left: 3px solid transparent;
        }
        #toc li a:hover { background-color: var(--medium-bg); color: var(--text-light); }
        #toc li a.active {
            background-color: var(--light-bg); color: var(--text-light);
            border-left-color: var(--primary-accent); font-weight: 600;
        }
        #main-content { flex-grow: 1; overflow-y: auto; padding: 3rem 4rem; }
        section {
            margin-bottom: 4rem; padding-top: 2rem; border-top: 1px solid #e5e7eb;
        }
        section:first-child { padding-top: 0; border-top: none; }
        h1, h2, h3, h4 {
            color: var(--content-heading); font-weight: 700; line-height: 1.3;
            margin-top: 1.5em; margin-bottom: 1em;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }
        p, li { margin-bottom: 1rem; }
        ul, ol { padding-left: 1.5rem; }
        a { color: var(--primary-accent); text-decoration: none; font-weight: 500; }
        a:hover { text-decoration: underline; }
        code {
            font-family: 'Source Code Pro', monospace; background-color: var(--code-bg);
            color: var(--code-text); padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg); border-radius: 0.5rem; padding: 1rem;
            overflow-x: auto; font-size: 0.85rem; line-height: 1.5;
        }
        pre code { padding: 0; background: none; }
        blockquote {
            margin-left: 0; padding: 1rem 1.5rem; border-left: 4px solid var(--primary-accent);
            background-color: #f9fafb; color: #4b5563;
        }
        blockquote strong {
            display: block; margin-bottom: 0.5rem; font-weight: 600; color: #111827;
        }
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; font-size: 0.9rem;
        }
        th, td { padding: 0.75rem 1rem; border: 1px solid #d1d5db; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .footer {
            text-align: center; margin-top: 4rem; padding-top: 2rem;
            border-top: 1px solid #e5e7eb; font-size: 0.85rem; color: #6b7280;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>
    <aside id="left-panel">
        <div class="logo">Help Guide: <span>Combs</span></div>
        <nav>
            <ul id="toc">
                <li><a href="#introduction" class="active">Technical Overview</a></li>
                <li><a href="#quick-start">Quick Start Guide</a></li>
                <li><a href="#ui">The User Interface</a></li>
                <li><a href="#peak-finding">Peak Finding</a></li>
                <li><a href="#indexing-method">Indexing Algorithm</a></li>
                <li><a href="#evaluating-solutions">Evaluating Solutions (M(20))</a></li>
                <li><a href="#space-group-analysis">Space Group Analysis</a></li>
                <li><a href="#advanced-topics">Advanced Topics</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
                <li><a href="#references">References</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <section id="introduction">
            <h1>Technical Overview & Methodology</h1>
            <p>This document provides a technical reference for the Combs Powder Indexing software. It details the program's algorithms, search parameters, and methodologies for scientists and researchers familiar with powder X-ray diffraction techniques.</p>
            
            <h3>Core Methodology</h3>
            <p>
                The goal of <em>ab initio</em> powder indexing is to determine the unit cell parameters ($a, b, c, \alpha, \beta, \gamma$) from a list of observed diffraction peak positions ($2\theta$). This program implements a system-specific, exhaustive search algorithm to solve this problem.
            </p>
            <p>
                The core principle is to assume that a small subset of the most intense, low-angle reflections must correspond to simple crystal planes with low-integer Miller indices $(hkl)$. The program solves the indexing equations by taking the exact number of unknown parameters for a given crystal system and solving a system of linear equations using that many observed peaks.
            </p>
             <p>
                To linearize the indexing equations, all peak positions are first converted from $2\theta$ to Q-space, where $Q = 1/d^2$. The relationship between $Q$, the Miller indices, and the reciprocal cell parameters ($A, B, C, D, E, F$) is given by the general quadratic form:
                $$ Q_{hkl} = Ah^2 + Bk^2 + Cl^2 + Dkl + Ehl + Fhk $$
                The software solves for these reciprocal parameters and then converts them back to the real-space cell parameters for the final solution. Each trial cell is immediately refined and scored against the full peak list.
            </p>
        </section>

        <section id="quick-start">
            <h2>Quick Start Guide</h2>
            <p>Follow these steps for a standard indexing routine on a single-phase powder pattern.</p>
            <ol>
                <li><strong>Load Data File:</strong> Use the <code>Select Data File</code> button. Supported formats include <code>.xy</code>, <code>.xrdml</code>, <code>.ras</code>, etc.</li>
                <li><strong>Find Peaks:</strong> On the <strong>Peaks</strong> tab, adjust the <code>Min peak (%)</code>, <code>Radius (pts)</code>, and <code>Points</code> sliders to accurately capture your experimental peaks.</li>
                <li><strong>Review & Refine Peaks:</strong> Critically examine the peak list. Edit 2θ positions for accuracy, delete spurious peaks (noise, Kα2), and add any missed reflections using <code>Ctrl + Click</code> on the chart. A clean list of 15-20 peaks is ideal.</li>
                <li><strong>Set Parameters:</strong> On the <strong>Parameters</strong> tab:
                    <ul>
                        <li>Verify the X-ray <code>Wavelength (Å)</code>.</li>
                        <li>Set a chemically sensible <code>Max Volume (Å³)</code> to constrain the search.</li>
                        <li>Set the <code>2θ Error (°)</code> appropriate for your instrument's resolution (e.g., 0.02° for synchrotron, 0.05° for lab data).</li>
                        <li>Select the crystal systems to search. Start with higher symmetries first.</li>
                    </ul>
                </li>
                <li><strong>Start Indexing:</strong> Click <code>Start Indexing</code>.</li>
                <li><strong>Analyze Solutions:</strong> On the <strong>Solutions</strong> tab, review the results. Sort by M(20) and click on high-scoring solutions to visually compare the calculated (blue) and observed (red) peak markers on the chart. A good solution will also have plausible space group suggestions.</li>
            </ol>
        </section>
        
        <section id="ui">
            <h2>The User Interface</h2>
            <p>The application is divided into the Controls Panel (left) and the Results Area (right).</p>

            <h3>Controls Panel</h3>
            <p>This panel contains all inputs and controls, organized into three primary tabs.</p>
            <h4>1. Peaks Tab</h4>
            <ul>
                <li><strong>Peak Finding Sliders:</strong> Control the background subtraction (<code>Radius</code>), data smoothing (<code>Points</code>), and peak detection threshold (<code>Min peak</code>, logarithmic scale).</li>
                <li><strong>2θ Range Sliders:</strong> Define the angular range for peak detection, useful for excluding noisy regions.</li>
                <li><strong>Peak Table:</strong> A list of all detected peaks. <code>2θ Obs (°)</code> values can be manually edited for precision.</li>
            </ul>

            <h4>2. Parameters Tab</h4>
            <ul>
                <li><strong>Wavelength (Å):</strong> X-ray wavelength. Critical for d-spacing calculation.</li>
                <li><strong>Max Volume (Å³):</strong> The upper limit for acceptable unit cell volume. A key parameter for constraining the search.</li>
                <li><strong>2θ Error (°):</strong> Tolerance for matching calculated to observed peaks.</li>
                <li><strong>Impurity Peaks:</strong> Number of allowed un-indexed peaks among the first 20 when calculating M(20).</li>
                <li><strong>Refine Zero-Point Error:</strong> Enables simultaneous refinement of a zero-point correction with the lattice parameters. Highly recommended.</li>
                <li><strong>Crystal Systems to Search:</strong> Checkboxes for Cubic, Tetragonal, Hexagonal, Orthorhombic, and Monoclinic systems.</li>
            </ul>
            
            <h4>3. Solutions Tab</h4>
            <ul>
                <li><strong>Solutions Table:</strong> Lists all valid solutions found, with their system, parameters, volume, and M(20) score. Click a row to select it for visual analysis on the chart.</li>
            </ul>

            <h3>Results Area</h3>
            <ul>
                <li><strong>Chart:</strong> Displays the diffraction pattern, observed peaks (red ticks), and calculated peaks for the selected solution (blue ticks). A good fit shows excellent alignment between red and blue ticks.</li>
                <li><strong>Chart Interaction:</strong> Zoom (mouse wheel), Pan (click-drag), Reset Zoom (right-click), Add Peak (<code>Ctrl + Click</code>).</li>
            </ul>
        </section>

        <section id="peak-finding">
            <h2>Peak Finding in Detail</h2>
            <p>Accurate peak positions are the most critical input for successful indexing. The program uses a multi-step process to identify peaks from raw data.</p>
            
            <h4>The Algorithm Steps</h4>
            <ol>
                <li><strong>Background Subtraction:</strong> A "rolling ball" algorithm estimates and subtracts the background signal. The <code>Radius</code> slider controls the size of the virtual ball.</li>
                <li><strong>Data Smoothing:</strong> A Savitzky-Golay filter is applied to the background-subtracted data to reduce noise while preserving peak shape. The <code>Points</code> slider controls the smoothing window size.</li>
                <li><strong>Peak Detection:</strong> The algorithm identifies local maxima in the smoothed data that are above the <code>Min peak (%)</code> threshold.</li>
                <li><strong>Position Refinement:</strong> A parabolic fit to the top three points of each detected maximum is used to calculate a sub-pixel-accuracy peak position.</li>
            </ol>
            
            <h4>Practical Advice</h4>
            <ul>
                <li>Start with default values and visually inspect the results.</li>
                <li>If weak but clear peaks are missed, lower the <code>Min peak (%)</code>. If picking up noise, increase it.</li>
                <li>For patterns with a broad amorphous background, increase the <code>Radius</code>.</li>
                <li>If data is very noisy, increase smoothing <code>Points</code>, but avoid over-smoothing, which can merge or shift peaks.</li>
                <li><strong>Always manually curate the final peak list.</strong> Remove artifacts, Kα2 shoulders, and known impurity peaks.</li>
            </ul>
        </section>

        <section id="indexing-method">
            <h2>Indexing Algorithm and Search Parameters</h2>
            <p>The program employs a dedicated search routine for each crystal system. This is an "exhaustive" or "brute-force" trial method that iterates through combinations of low-angle peaks and low-integer Miller indices. The number of peaks required to generate a trial cell depends on the number of unknown lattice parameters.</p>

            <h3>System-by-System Search Logic</h3>
            <p>The search algorithm's goal is to solve a system of linear equations of the form $Q_{obs} = \sum P_i \cdot H_i$, where $Q_{obs}$ are the $1/d^2$ values from the observed peaks, $H_i$ are terms derived from the trial Miller indices (e.g., $h^2, k^2, l^2$), and $P_i$ are the reciprocal lattice parameters (e.g., $1/a^2, 1/b^2, 1/c^2$) we want to find.</p>
            <ul>
                <li>
                    <strong>Cubic (1 parameter, $A=1/a^2$):</strong>
                    Solves a 1x1 system:
                    $$ Q_{obs, 1} = (h_1^2 + k_1^2 + l_1^2) \cdot A $$
                    The program iterates through the first 10 observed peaks, assigning each one a single trial $(hkl)$ vector (where $h,k,l$ are integers up to 8) to find a trial $a$-value.
                </li>
                <li>
                    <strong>Tetragonal & Hexagonal (2 parameters, $P_1, P_2$):</strong>
                    Solves a 2x2 system of equations using pairs of peaks from the first 10:
                    $$ Q_{obs, 1} = H_{1,a} \cdot P_1 + H_{1,c} \cdot P_2 $$
                    $$ Q_{obs, 2} = H_{2,a} \cdot P_1 + H_{2,c} \cdot P_2 $$
                    It assigns pairs of trial $(hkl)$ vectors (where $h,k,l$ are integers up to 5) to solve for $P_1$ and $P_2$, which are then converted to $a$ and $c$.
                </li>
                <li>
                    <strong>Orthorhombic (3 parameters, $A=1/a^2, B=1/b^2, C=1/c^2$):</strong>
                    Solves a 3x3 system using triplets of peaks from the first 10:
                    $$ Q_{obs, 1} = h_1^2 A + k_1^2 B + l_1^2 C $$
                    $$ Q_{obs, 2} = h_2^2 A + k_2^2 B + l_2^2 C $$
                    $$ Q_{obs, 3} = h_3^2 A + k_3^2 B + l_3^2 C $$
                    It assigns <em>triplets</em> of trial $(hkl)$ vectors from a pre-calculated basis set of 30 reflections to find $a, b, c$.
                </li>
                <li>
                    <strong>Monoclinic (4 parameters, $A, B, C, D$):</strong>
                    Solves a 4x4 system for the four reciprocal parameters ($A, B, C, D$) in the equation $Q_{hkl} = A h^2 + B k^2 + C l^2 + D hl$.
                    It iterates through <em>quadruplets</em> of observed peaks (from the first 20), assigning <em>quadruplets</em> of trial $(hkl)$ vectors from a dynamically generated, curated basis set of 50 common, low-index reflections.
                </li>
            </ul>

            <h3>Search Depth and HKL Limits</h3>
            <p>To ensure performance, the search depth and the range of Miller indices tested are internally limited. These hard-coded parameters represent a balance between exhaustive searching and computational time.</p>
             <table>
                <thead><tr><th>Crystal System</th><th>Peak Subset Used</th><th>HKL Index Limits</th></tr></thead>
                <tbody>
                    <tr><td>Cubic</td><td>First 10 peaks</td><td><code>h, k, l</code> up to 8</td></tr>
                    <tr><td>Tetragonal</td><td>First 10 peaks</td><td><code>h, k, l</code> up to 5</td></tr>
                    <tr><td>Hexagonal</td><td>First 10 peaks</td><td><code>h, k, l</code> up to 5</td></tr>
                    <tr><td>Orthorhombic</td><td>First 10 peaks</td><td>Uses a basis set of the first 30 plausible low-index reflections.</td></tr>
                    <tr><td>Monoclinic</td><td>First 20 peaks</td><td>Uses a curated basis set of 50 common, low-index reflections.</td></tr>
                </tbody>
            </table>
        </section>

        <section id="evaluating-solutions">
            <h2>Evaluating Solutions (M(20))</h2>
            <p>The indexing search often produces multiple candidate solutions. Distinguishing the correct one requires a reliable figure of merit and careful refinement.</p>
            
            <h3>The de Wolff Figure of Merit: M(20)</h3>
            <p>Solutions are ranked by the <strong>de Wolff Figure of Merit, M(20)</strong>, which assesses the fit's accuracy and completeness. It is calculated using the first 20 observed reflections. A high M(20) value is a strong indicator of a correct solution.</p>
            <table>
                <thead><tr><th>M(20) Value</th><th>Interpretation</th></tr></thead>
                <tbody>
                    <tr><td>> 20</td><td>The solution is very likely to be correct.</td></tr>
                    <tr><td>> 10</td><td>The solution is likely correct, especially if the volume is chemically sensible.</td></tr>
                    <tr><td>5 - 10</td><td>The solution is plausible and deserves further investigation.</td></tr>
                    <tr><td>&lt; 5</td><td>The solution is likely spurious and should be viewed with skepticism.</td></tr>
                </tbody>
            </table>

            <h3>Least-Squares and Zero-Point Refinement</h3>
            <p>
                Every promising trial cell is refined using linear least-squares to minimize the difference between $Q_{obs}$ and $Q_{calc}$.
            </p>
            <p>
                When the <code>Refine Zero-Point Error</code> option is enabled, the program uses a robust two-step approach:
            </p>
            <ol>
                <li><strong>Baseline Refinement:</strong> It first performs a stable refinement of <strong>only the lattice parameters</strong>. This provides a reliable fallback solution.</li>
                <li><strong>Full Refinement:</strong> It then attempts a more complex refinement solving for both the lattice parameters and the zero-point error simultaneously. This is done by adding a term to the least-squares fit that models the $2\theta$ shift.</li>
            </ol>
            <p>If the full refinement is unstable or produces an invalid cell, the program gracefully falls back to the reliable baseline solution, ensuring a valid result is never discarded due to an unstable higher-order fit.</p>
        </section>

        <section id="space-group-analysis">
            <h2>Space Group Analysis</h2>
            <p>
                After a high-scoring unit cell is found, the program provides an automated analysis to suggest the most probable space groups. This feature serves as a powerful guide for subsequent structure solution or Rietveld refinement.
            </p>
            <p>
                The analysis relies on a comprehensive internal database of reflection conditions (<code>space_groups_complete.json</code>) derived from crystallographic libraries like <strong>Pymatgen</strong>.
            </p>
            
            <h3>Methodology</h3>
            <p>The analysis is a systematic process of elimination based on observed systematic absences:</p>
            <ol>
                <li>
                    <strong>Index Observed Peaks:</strong> The program takes the refined unit cell and generates a complete theoretical reflection list. It then indexes <em>all</em> high-quality observed peaks from the user's peak list, not just the first 20.
                </li>
                <li>
                    <strong>Build High-Confidence Set:</strong> To avoid errors from peak overlap, the algorithm filters this list to find <strong>unambiguous</strong> reflections—observed peaks that correspond to a single, non-overlapping theoretical $(hkl)$ line.
                </li>
                <li>
                    <strong>Determine Centering:</strong> This high-confidence set of <em>observed</em> $(hkl)$s is tested against the rules for all lattice centerings (P, I, F, A, B, C, R). The program determines the most likely centering by finding the one with the <strong>minimum number of violations</strong>. A violation is defined as an <em>observed reflection</em> that <em>should be absent</em> (e.g., observing a (100) reflection for an I-centered lattice).
                </li>
                <li>
                    <strong>Rank Space Groups:</strong> The program filters its database for <em>all</em> space groups matching the solution's crystal system (e.g., 'monoclinic') and the most plausible centering(s).
                </li>
                <li>
                    <strong>Count Extinction Violations:</strong> For each candidate space group, it checks the high-confidence observed reflections against that group's specific extinction rules for glide planes and screw axes (e.g., $0k0: k=2n$). Again, it only counts violations where an <em>observed peak</em> breaks a rule.
                </li>
            </ol>

            <h3>How to Interpret the Results</h3>
            <p>
                The program ranks space groups by their number of violations. This ranking is displayed in the PDF report.
            </p>
            <ul>
                <li><strong>0 Violations:</strong> This is the ideal result. It means that <em>no observed reflection</em> in the high-confidence set violated any of the space group's extinction rules. These are the strongest candidates.</li>
                <li><strong>1-2 Violations:</strong> These are still plausible. A single violation could be caused by an experimental artifact, a mis-indexed ambiguous peak, or a weak, theoretically-forbidden reflection appearing due to experimental factors.</li>
                <li><strong>Many Violations:</strong> These space groups are highly unlikely to be correct.</li>
            </ul>
            <blockquote>
                <strong>Important:</strong> This analysis is a suggestion, not a definitive assignment. It is based <em>only</em> on the observed extinctions in a powder pattern, which can be incomplete. The final determination must be made with chemical knowledge and confirmed via structure refinement.
            </blockquote>
        </section>
        
        <section id="advanced-topics">
            <h2>Advanced Topics: Enhanced Search and Sieving</h2>
            <p>
                To improve the success rate, the program integrates several advanced search strategies after the initial indexing routine.
            </p>
            
            <h3>1. Matrix-based Cell Transformations</h3>
            <p>Promising solutions are transformed using crystallographic matrices to test for related primitive or higher-symmetry cells. For example, a body-centered cell ($I$) is tested for a valid primitive ($P$) equivalent.</p>
            
            <h3>2. HKL Divisor Analysis</h3>
            <p>The program examines the list of indexed Miller indices. If all indices in one direction (e.g., all $h$ values) share a common divisor, it tests a new cell with the corresponding axis halved.</p>
            
            <h3>3. Orthorhombic to Hexagonal Check</h3>
            <p>A hexagonal lattice can be indexed as a C-centered orthorhombic cell where $b/a \approx \sqrt{3}$. The program specifically checks all orthorhombic solutions for this condition and generates the equivalent hexagonal cell for evaluation.</p>
            
            <h3>4. Final Sieving</h3>
            <p>After all searches, a final sieving process is applied. If two solutions have very similar volumes, the one with higher symmetry and a better M(20) score is preferred, and the redundant solution is discarded.</p>
        </section>
        
        <section id="troubleshooting">
            <h2>Troubleshooting & FAQ</h2>
            
            <h4>Why were no solutions found?</h4>
            <ul>
                <li><strong>Poor Peak List:</strong> The most common cause. Ensure the peak list is accurate, with impurity peaks removed and positions refined. A minimum of 15-20 clean peaks is recommended.</li>
                <li><strong>Incorrect Parameters:</strong> Verify the <code>Wavelength</code> and ensure the <code>Max Volume</code> is chemically reasonable and sufficiently large.</li>
                <li><strong>High Zero-Point Error:</strong> A significant instrument misalignment may require enabling the <code>Refine Zero-Point Error</code> option.</li>
                <li><strong>Sample is a Mixture:</strong> Indexing requires a peak list from a single crystalline phase.</li>
            </ul>

            <h4>Why is M(20) low for a visually good fit?</h4>
            <ul>
                <li><strong>Incorrect Cell (Sub-multiple/Super-multiple):</strong> The found cell may be a multiple or sub-multiple of the true cell. It indexes some lines but is penalized by M(20) for being too "empty" or "dense" with calculated reflections.</li>
                <li><strong>High Error / Low Resolution:</strong> The <code>2θ Error</code> might be set too tight for broad peaks. Try slightly increasing this value.</li>
                <li><strong>Spurious Solution:</strong> A random solution can sometimes fit a few lines by chance. Visual inspection is key; if major observed peaks are missed by the calculated pattern, the solution is incorrect regardless of the M(20) value.</li>
            </ul>
        </section>


            <section id="references">
            <h2>References</h2>
            <p>This program was developed by Nita Dragoe at Université Paris-Saclay (2024-2025) as a successor to a prior software, Powder 4, originally created by the same author in 1999-2000. For a deeper understanding of the methodology, consulting the original scientific papers is highly recommended.</p>
            <ol>
                <li>
                    <strong>The M(20) Figure of Merit:</strong><br>
                    de Wolff, P. M. (1968). "A Simplified Criterion for the Reliability of a Powder Pattern Indexing." <em>Journal of Applied Crystallography</em>, <strong>1</strong>, 108-113.
                </li>
                <li>
                    <strong>General Powder Diffraction Text:</strong><br>
                    Klug, H. P. & Alexander, L. E. (1974). <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em>, 2nd ed. New York: Wiley-Interscience.
                </li>
                <li>
                    <strong>Alternative Indexing Methods:</strong><br>
                    Ito, T. (1949). "A General Powder X-ray Photography."<em>Nature</em>, 164, 755-756.<br> 
                    Werner, P.-E., Eriksson, L., & Westdahl, M. (1985). "TREOR, a semi-exhaustive trial-and-error powder indexing program for all symmetries." <em>Journal of Applied Crystallography</em>, <strong>18</strong>, 367-370.<br>
                     Visser, J. W. (1969). "A fully automatic program for finding the unit cell from powder data." <em>Journal of Applied Crystallography</em>, <strong>2</strong>, 89-95.<br>
                     Le Bail, A. (2004). "Monte Carlo Indexing with McMaille". <em>Powder Diffraction</em>, <strong>19(3)</strong>, 249-254.<br>
                     Boultif, A. & Louër, D. (2004). "Powder pattern indexing with the dichotomy method." <em>Journal of Applied Crystallography</em>, <strong>37</strong>, 724-731.
                   
                    </li>
            </ol>
            <div class="footer">
                <p>Help Guide updated on 19 Oct 2025 by an AI assistant.</p>
            </div>
        </section>

    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('#toc a');
        const mainContent = document.getElementById('main-content');
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => link.classList.remove('active'));
                    const activeLink = document.querySelector(`#toc a[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { root: mainContent, rootMargin: "0px 0px -80% 0px" });
        
        sections.forEach(section => observer.observe(section));
        
        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                navLinks.forEach(l => l.classList.remove('active'));
                this.classList.add('active');
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                // Manually scroll the main-content panel
                if (targetElement) {
                    mainContent.scrollTo({
                        top: targetElement.offsetTop - 32, // 32px padding-top
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Set the active link on load
        const updateActiveLink = () => {
            let currentActive = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                // Check if the top of the section is within the top 20% of the viewport
                if (rect.top >= 0 && rect.top <= mainContent.clientHeight * 0.2) {
                    currentActive = section.getAttribute('id');
                }
            });

            if (currentActive) {
                navLinks.forEach(link => link.classList.remove('active'));
                const activeLink = document.querySelector(`#toc a[href="#${currentActive}"]`);
                if (activeLink) activeLink.classList.add('active');
            } else {
                // If no section is at the top, activate the first one
                navLinks.forEach(link => link.classList.remove('active'));
                if (navLinks.length > 0) navLinks[0].classList.add('active');
            }
        };
        
        // Use timeout to ensure content is rendered before first check
        setTimeout(updateActiveLink, 100);
    });
</script>

</body>
</html>
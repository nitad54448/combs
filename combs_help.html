<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combs Indexing - Technical Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --text-light: #f3f4f6;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --content-bg: #ffffff;
            --content-text: #1f2937;
            --content-heading: #111827;
            --code-bg: #f3f4f6;
            --code-text: #111827;
        }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--content-bg);
            color: var(--content-text); line-height: 1.7; display: flex;
            height: 100vh; overflow: hidden;
        }
        #left-panel {
            width: 280px; flex-shrink: 0; background-color: var(--dark-bg);
            color: var(--text-medium); padding: 2rem; overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        #left-panel .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--text-light);
            margin-bottom: 2rem;
        }
        #left-panel .logo span { color: var(--primary-accent); }
        #toc { list-style: none; padding: 0; margin: 0; }
        #toc li a {
            display: block; color: var(--text-dark); text-decoration: none;
            padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 500;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            border-left: 3px solid transparent;
        }
        #toc li a:hover { background-color: var(--medium-bg); color: var(--text-light); }
        #toc li a.active {
            background-color: var(--light-bg); color: var(--text-light);
            border-left-color: var(--primary-accent); font-weight: 600;
        }
        #main-content { flex-grow: 1; overflow-y: auto; padding: 3rem 4rem; }
        section {
            margin-bottom: 4rem; padding-top: 2rem; border-top: 1px solid #e5e7eb;
        }
        section:first-child { padding-top: 0; border-top: none; }
        h1, h2, h3, h4 {
            color: var(--content-heading); font-weight: 700; line-height: 1.3;
            margin-top: 1.5em; margin-bottom: 1em;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }
        p, li { margin-bottom: 1rem; }
        ul, ol { padding-left: 1.5rem; }
        a { color: var(--primary-accent); text-decoration: none; font-weight: 500; }
        a:hover { text-decoration: underline; }
        code {
            font-family: 'Source Code Pro', monospace; background-color: var(--code-bg);
            color: var(--code-text); padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg); border-radius: 0.5rem; padding: 1rem;
            overflow-x: auto; font-size: 0.85rem; line-height: 1.5;
        }
        pre code { padding: 0; background: none; }
        blockquote {
            margin-left: 0; padding: 1rem 1.5rem; border-left: 4px solid var(--primary-accent);
            background-color: #f9fafb; color: #4b5563;
        }
        blockquote strong {
            display: block; margin-bottom: 0.5rem; font-weight: 600; color: #111827;
        }
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; font-size: 0.9rem;
        }
        th, td { padding: 0.75rem 1rem; border: 1px solid #d1d5db; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .footer {
            text-align: center; margin-top: 4rem; padding-top: 2rem;
            border-top: 1px solid #e5e7eb; font-size: 0.85rem; color: #6b7280;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>
    <aside id="left-panel">
        <div class="logo">Help Guide: <span>Combs</span></div>
        <nav>
            <ul id="toc">
                <li><a href="#introduction" class="active">Technical Overview</a></li>
                <li><a href="#quick-start">Quick Start Guide</a></li>
                <li><a href="#ui">The User Interface</a></li>
                <li><a href="#peak-finding">Peak Finding</a></li>
                <li><a href="#indexing-method">Indexing Algorithm</a></li>
                <li><a href="#evaluating-solutions">Evaluating Solutions</a></li>
                <li><a href="#space-group-analysis">Space Group Analysis</a></li>
                <li><a href="#advanced-topics">Advanced Topics</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
                <li><a href="#references">References</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <section id="introduction">
            <h1>Technical Overview & Methodology</h1>
            <p>This document provides a technical reference for the Combs Powder Indexing software. It details the program's algorithms, search parameters, and methodologies for scientists and researchers familiar with powder X-ray diffraction techniques.</p>

            <h3>Core Methodology</h3>
            <p>
                The goal of <em>ab initio</em> powder indexing is to determine the unit cell parameters ($a, b, c, \alpha, \beta, \gamma$) from a list of observed diffraction peak positions ($2\theta$). This program implements a system-specific, exhaustive search algorithm to solve this problem.
            </p>
            <p>
                The core principle is to assume that a small subset of the most intense, low-angle reflections must correspond to simple crystal planes with low-integer Miller indices $(hkl)$. The program solves the indexing equations by taking the exact number of unknown parameters for a given crystal system and solving a system of linear equations using that many observed peaks.
            </p>
             <p>
                To linearize the indexing equations, all peak positions are first converted from $2\theta$ to Q-space, where $Q = 1/d^2$. The relationship between $Q$, the Miller indices, and the reciprocal cell parameters ($A, B, C, D, E, F$) is given by the general quadratic form:
                $$ Q_{hkl} = Ah^2 + Bk^2 + Cl^2 + Dkl + Ehl + Fhk $$
                The software solves for these reciprocal parameters and then converts them back to the real-space cell parameters for the final solution. Each trial cell is immediately refined and scored against the full peak list.
            </p>
        </section>

        <section id="quick-start">
            <h2>Quick Start Guide</h2>
            <p>Follow these steps for a standard indexing routine on a single-phase powder pattern.</p>
            <ol>
                <li><strong>Load Data File:</strong> Use the <code>Select Data File</code> button. Supported formats include <code>.xy</code>, <code>.xrdml</code>, <code>.ras</code>, etc.</li>
                <li><strong>Find Peaks:</strong> On the <strong>Peaks</strong> tab, adjust the <code>Min peak (%)</code>, <code>Radius (pts)</code>, and <code>Points</code> sliders to accurately capture your experimental peaks.</li>
                <li><strong>Review & Refine Peaks:</strong> Critically examine the peak list. Edit 2θ positions for accuracy, delete spurious peaks (noise, Kα2 shoulders if *not* stripping), and add any missed reflections using <code>Ctrl + Click</code> on the chart. A clean list of 15-20 peaks is ideal.</li>
                <li><strong>Set Parameters:</strong> On the <strong>Parameters</strong> tab:
                    <ul>
                        <li>Select the appropriate X-ray <code>Radiation Preset</code> (e.g., Cu Ka).</li>
                        <li>Decide whether to enable <code>Strip K-alpha2</code>. This choice updates the <code>Ka1 Wavelength</code> field automatically. The default is OFF, using the average Ka wavelength.</li>
                        <li>Set a chemically sensible <code>Max Volume (Å³)</code> to constrain the search.</li>
                        <li>Set the <code>2θ Error (°)</code> appropriate for your instrument's resolution (e.g., 0.02° for synchrotron, 0.05° for lab data).</li>
                        <li>The <strong>Refine Zero-Point Error</strong> checkbox is enabled by default and is highly recommended.</li>
                        <li>Select the crystal systems to search. Start with higher symmetries first.</li>
                    </ul>
                </li>
                <li><strong>Start Indexing:</strong> Click <code>Start Indexing</code>.</li>
                <li><strong>Analyze Solutions:</strong> On the <strong>Solutions</strong> tab, review the results. Sort by M(20) and click on high-scoring solutions to visually compare the calculated (blue) and observed (red) peak markers on the chart. A good solution will also have plausible space group suggestions.</li>
            </ol>
        </section>

        <section id="ui">
            <h2>The User Interface</h2>
            <p>The application is divided into the Controls Panel (left) and the Results Area (right).</p>

            <h3>Controls Panel</h3>
            <p>This panel contains all inputs and controls, organized into three primary tabs.</p>
            <h4>1. Peaks Tab</h4>
            <ul>
                <li><strong>Peak Finding Sliders:</strong> Control the background subtraction (<code>Radius</code>), data smoothing (<code>Points</code>), and peak detection threshold (<code>Min peak</code>, logarithmic scale).</li>
                <li><strong>2θ Range Sliders:</strong> Define the angular range for peak detection, useful for excluding noisy regions.</li>
                <li><strong>Peak Table:</strong> A list of all detected peaks. <code>2θ Obs (°)</code> values can be manually edited for precision.</li>
            </ul>

            <h4>2. Parameters Tab</h4>
            <ul>
                <li><strong>Radiation Preset:</strong> Select the X-ray source used (e.g., Cu Ka, Co Ka). This sets the appropriate wavelengths.</li>
                <li><strong>Ka1 Wavelength (Å):</strong> Displays the wavelength being used for calculations. If a preset is selected, this value automatically updates based on the <code>Strip K-alpha2</code> setting (shows Ka1 if ON, average Ka if OFF). It is editable only when <code>Custom</code> preset is chosen.</li>
                <li><strong>Strip K-alpha2:</strong> If checked, applies a Rachinger algorithm to numerically remove the Kα2 component from the data before peak finding and analysis. This also sets the <code>Ka1 Wavelength</code> field to the pure Kα1 value. Default is OFF.</li>
                <li><strong>Max Volume (Å³):</strong> The upper limit for acceptable unit cell volume. A key parameter for constraining the search.</li>
                <li><strong>Impurity Peaks:</strong> Number of allowed un-indexed peaks among the first 20 when calculating M(20).</li>
                <li><strong>2θ Error (°):</strong> Tolerance for matching calculated to observed peaks.</li>
                <li><strong>Refine Zero-Point Error:</strong> Controls whether a full, unconstrained zero-point refinement is applied to the final reported solution.</li>
                <li><strong>Crystal Systems to Search:</strong> Checkboxes for Cubic, Tetragonal, Hexagonal, Orthorhombic, and Monoclinic systems.</li>
            </ul>

            <h4>3. Solutions Tab</h4>
            <ul>
                <li><strong>Solutions Table:</strong> Lists all valid solutions found, with their system, parameters, volume, and M(20) score. Click a row to select it for visual analysis on the chart.</li>
            </ul>

            <h3>Results Area</h3>
            <ul>
                <li><strong>Chart:</strong> Displays the diffraction pattern, observed peaks (red ticks), and calculated peaks for the selected solution (blue ticks). A good fit shows excellent alignment between red and blue ticks.</li>
                <li><strong>Chart Interaction:</strong> Zoom (mouse wheel), Pan (click-drag), Reset Zoom (right-click), Add Peak (<code>Ctrl + Click</code>).</li>
            </ul>
        </section>

        <section id="peak-finding">
            <h2>Peak Finding in Detail</h2>
            <p>Accurate peak positions are the most critical input for successful indexing. The program uses a multi-step process to identify peaks from raw data.</p>

            <h4>The Algorithm Steps</h4>
            <ol>
                <li><strong>Kα2 Stripping (Optional):</strong> If <code>Strip K-alpha2</code> is checked, the Rachinger algorithm is applied to the raw intensity data first.</li>
                <li><strong>Background Subtraction:</strong> A "rolling ball" algorithm estimates and subtracts the background signal from the (potentially stripped) data. The <code>Radius</code> slider controls the size of the virtual ball.</li>
                <li><strong>Data Smoothing:</strong> A Savitzky-Golay filter is applied to the background-subtracted data to reduce noise while preserving peak shape. The <code>Points</code> slider controls the smoothing window size.</li>
                <li><strong>Peak Detection:</strong> The algorithm identifies local maxima in the smoothed data that are above the <code>Min peak (%)</code> threshold.</li>
                <li>
                    <strong>Position Refinement:</strong> To find a precise, sub-pixel peak position, the algorithm performs a 5-point least-squares quadratic fit (based on Savitzky-Golay coefficients) on the data points surrounding the detected maximum. This is more accurate than a simple 3-point parabola and robust against noise. If a peak is too close to the data's edge, it falls back to a 3-point fit.
                </li>
            </ol>

            <h4>Practical Advice</h4>
            <ul>
                <li>Start with default values and visually inspect the results.</li>
                <li>If weak but clear peaks are missed, lower the <code>Min peak (%)</code>. If picking up noise, increase it.</li>
                <li>For patterns with a broad amorphous background, increase the <code>Radius</code>.</li>
                <li>If data is very noisy, increase smoothing <code>Points</code>, but avoid over-smoothing, which can merge or shift peaks.</li>
                <li><strong>Always manually curate the final peak list.</strong> Remove artifacts and known impurity peaks. If <strong>not</strong> stripping Kα2, be sure to delete the Kα2 shoulders manually.</li>
                <li>Kα2 stripping can simplify patterns but may introduce small artifacts. If indexing fails with stripping ON, try turning it OFF and manually removing the α2 peaks.</li>
            </ul>
        </section>

        <section id="indexing-method">
            <h2>Indexing Algorithm and Search Parameters</h2>
            <p>The program employs a dedicated search routine for each crystal system. This is an "exhaustive" or "brute-force" trial method that iterates through combinations of low-angle peaks and low-integer Miller indices. The number of peaks required to generate a trial cell depends on the number of unknown lattice parameters.</p>

            <h3>System-by-System Search Logic</h3>
            <p>The search algorithm's goal is to solve a system of linear equations of the form $Q_{obs} = \sum P_i \cdot H_i$, where $Q_{obs}$ are the $1/d^2$ values from the observed peaks, $H_i$ are terms derived from the trial Miller indices (e.g., $h^2, k^2, l^2$), and $P_i$ are the reciprocal lattice parameters (e.g., $1/a^2, 1/b^2, 1/c^2$) we want to find.</p>
            <ul>
                <li>
                    <strong>Cubic (1 parameter, $A=1/a^2$):</strong>
                    Solves a 1x1 system:
                    $$ Q_{obs, 1} = (h_1^2 + k_1^2 + l_1^2) \cdot A $$
                    The program iterates through the first 10 observed peaks, assigning each one a single trial $(hkl)$ vector (where $h,k,l$ are integers up to 8) to find a trial $a$-value.
                </li>
                <li>
                    <strong>Tetragonal & Hexagonal (2 parameters, $P_1, P_2$):</strong>
                    Solves a 2x2 system of equations using pairs of peaks from the first 10:
                    $$ Q_{obs, 1} = H_{1,a} \cdot P_1 + H_{1,c} \cdot P_2 $$
                    $$ Q_{obs, 2} = H_{2,a} \cdot P_1 + H_{2,c} \cdot P_2 $$
                    It assigns pairs of trial $(hkl)$ vectors (where $h,k,l$ are integers up to 5) to solve for $P_1$ and $P_2$, which are then converted to $a$ and $c$.
                </li>
                <li>
                    <strong>Orthorhombic (3 parameters, $A=1/a^2, B=1/b^2, C=1/c^2$):</strong>
                    Solves a 3x3 system using triplets of peaks from the first 10:
                    $$ Q_{obs, 1} = h_1^2 A + k_1^2 B + l_1^2 C $$
                    $$ Q_{obs, 2} = h_2^2 A + k_2^2 B + l_2^2 C $$
                    $$ Q_{obs, 3} = h_3^2 A + k_3^2 B + l_3^2 C $$
                    It assigns <em>triplets</em> of trial $(hkl)$ vectors from a pre-calculated basis set of 30 reflections to find $a, b, c$.
                </li>
                <li>
                    <strong>Monoclinic (4 parameters, $A, B, C, D$):</strong>
                    Solves a 4x4 system for the four reciprocal parameters ($A, B, C, D$) in the equation $Q_{hkl} = A h^2 + B k^2 + C l^2 + D hl$.
                    A full exhaustive search is computationally infeasible (over 1.1 trillion combinations). Instead, the program uses a deep <strong>random sampling strategy</strong>.
                    <br><br>
                    It iterates through all combinations of 4 peaks from the first 20 (approx. 4,845 combos). For <em>each</em> peak quadruplet, it tests <strong>10000</strong> randomly sampled HKL-quadruplets. These HKLs are drawn from a curated basis set of 50 common, low-index reflections. Finally, it tests all 24 permutations of assigning the peaks to the HKLs.
                    <br><br>
                    This results in a total search space of approximately $\binom{20}{4} \times 10,000 \times 24 \approx \textbf{1.16 billion trials}$, providing a deep and thorough search in a manageable time.
                </li>
            </ul>
        </section>

        <section id="evaluating-solutions">
            <h2>Evaluating Solutions</h2>
            <p>The indexing search often produces multiple candidate solutions. Distinguishing the correct one requires a reliable figure of merit and careful refinement.</p>

            <h3>The de Wolff Figure of Merit: M(20)</h3>
            <p>Solutions are ranked by the <strong>de Wolff Figure of Merit, M(20)</strong>, which assesses the fit's accuracy and completeness. It is calculated using the first 20 observed reflections. A high M(20) value is a strong indicator of a correct solution.</p>
            <table>
                <thead><tr><th>M(20) Value</th><th>Interpretation</th></tr></thead>
                <tbody>
                    <tr><td>> 20</td><td>The solution is very likely to be correct.</td></tr>
                    <tr><td>> 10</td><td>The solution is likely correct, especially if the volume is chemically sensible.</td></tr>
                    <tr><td>5 - 10</td><td>The solution is plausible and deserves further investigation.</td></tr>
                    <tr><td>&lt; 5</td><td>The solution is likely spurious and should be viewed with skepticism.</td></tr>
                </tbody>
            </table>

            <h3>Least-Squares and Zero-Point Refinement</h3>
            <p>
                Every promising trial cell is refined using a robust, two-stage process to find the best possible parameters and M(20) score.
            </p>
            <h4>Stage 1: Internal Zero-Point Correction</h4>
            <p>
                To generate the most accurate cell proposal, the program <strong>always</strong> performs an initial refinement that includes a zero-point error term. This internal correction is strictly limited (constrained to be no larger than the user-defined `2θ Error`) to account for minor instrument misalignments without overfitting. The resulting corrected peak positions are then used to refine a baseline set of lattice parameters. This makes the initial cell proposal much more robust against small experimental shifts.
            </p>
            <h4>Stage 2: Final (Optional) Zero-Point Refinement</h4>
            <p>
                If the cell from Stage 1 achieves a high M(20) score, and the user has the <code>Refine Zero-Point Error</code> checkbox enabled, a second, <strong>full and unconstrained</strong> refinement is performed. This final step solves for all parameters simultaneously to produce the final reported values and their estimated standard deviations. If this option is disabled, only the lattice parameters from Stage 1 are reported.
            </p>
        </section>

        <section id="space-group-analysis">
            <h2>Space Group Analysis</h2>
            <p>
                After a high-scoring unit cell is found, the program provides an automated analysis to suggest the most probable space groups. This feature serves as a powerful guide for subsequent structure solution or Rietveld refinement.
            </p>

            <h3>Methodology</h3>
            <p>The analysis is a systematic process of elimination based on observed systematic absences:</p>
            <ol>
                <li>
                    <strong>Generate Unique Reflections:</strong> The program takes the refined unit cell and generates a complete theoretical reflection list, ensuring only crystallographically unique reflections (e.g., `(100)`, but not `(-100)`) are included to prevent self-ambiguity.
                </li>
                <li>
                    <strong>Index Observed Peaks:</strong> It then indexes <em>all</em> observed peaks from the user's list against this theoretical pattern.
                </li>
                <li>
                    <strong>Build High-Confidence Set:</strong> To avoid errors from accidental peak overlap (e.g., `(100)` and `(011)` having very similar $2\theta$ values), the algorithm filters the indexed list to find <strong>unambiguous</strong> reflections. A reflection is considered unambiguous only if no other theoretical $(hkl)$ line is calculated to be within the `2θ Error` tolerance of its position.
                </li>
                <li>
                    <strong>Determine Centering & Extinctions:</strong> This high-confidence set of <em>observed</em> $(hkl)$s is used for all further analysis. It is tested against the rules for lattice centerings and glide/screw axes. A violation is only counted if an <em>observed unambiguous peak</em> breaks a rule.
                </li>
                <li>
                    <strong>Rank Space Groups:</strong> The program filters its internal database for all space groups matching the solution's crystal system and plausible centering(s). Each candidate group is ranked by its number of violations.
                </li>
            </ol>

            <h3>How to Interpret the Results</h3>
            <ul>
                <li><strong>0 Violations:</strong> This is the ideal result. It means that <em>no observed unambiguous reflection</em> violated any of the space group's extinction rules. These are the strongest candidates.</li>
                <li><strong>1-2 Violations:</strong> These are still plausible. A single violation could be caused by an experimental artifact or a weak, theoretically-forbidden reflection.</li>
                <li><strong>Ambiguous Peaks (in italics):</strong> In the PDF report's reflection table, any peak that was identified as ambiguous (and therefore excluded from the analysis) is printed in an <em>italic</em> font for easy identification.</li>
            </ul>
        </section>

        <section id="advanced-topics">
            <h2>Advanced Topics: Enhanced Search and Sieving</h2>
            <p>
                To improve the success rate, the program integrates several advanced search strategies after the initial indexing routine is complete. These "fishing" strategies test for non-obvious but crystallographically common relationships.
            </p>

            <h3>1. "Swap Fishing" for Ambiguity</h3>
            <p>
                For each promising solution, the program re-examines the indexing of the <strong>first four low-angle peaks</strong>. It identifies the two peaks that are closest to each other, as this is a likely point of mis-indexing due to ambiguity. It then creates a new hypothesis by <strong>swapping their HKL assignments</strong> and attempts to solve for a new trial cell. This new cell is then sent back through the full refinement and scoring process. If this "swapped" hypothesis is correct, it will often lead to a solution with a significantly higher M(20) score.
            </p>

            <h3>2. Matrix-based Cell Transformations</h3>
            <p>Solutions are transformed using crystallographic matrices to test for related primitive or higher-symmetry cells. For example, a body-centered cell ($I$) is tested for a valid primitive ($P$) equivalent.</p>

            <h3>3. HKL Divisor Analysis</h3>
            <p>The program examines the list of indexed Miller indices. If all indices in one direction (e.g., all $h$ values) share a common divisor, it tests a new cell with the corresponding axis halved (a sub-cell).</p>

            <h3>4. Orthorhombic to Hexagonal Check</h3>
            <p>A hexagonal lattice can sometimes be indexed as a C-centered orthorhombic cell where $b/a \approx \sqrt{3}$. The program specifically checks all orthorhombic solutions for this condition and generates the equivalent hexagonal cell for evaluation.</p>

            <h3>5. Final Sieving</h3>
            <p>
                After all searches, a final sieving process is applied to remove redundant solutions. If two solutions have very similar volumes (within 1%), the one with higher symmetry is preferred.
            </p>
            <p>
                If the symmetries are also equal (e.g., two different monoclinic cells), the program compares their M(20) scores. Crucially, it treats M(20) scores as "effectively equal" if they are within a small tolerance (e.g., $\Delta M(20) < 0.05$). In this tie-breaker scenario, it invokes crystallographic conventions:
            </p>
            <ul>
                <li><strong>For Monoclinic Cells:</strong> If two solutions have effectively equal M(20) scores, the program will prefer the solution whose $\beta$ angle is <strong>closer to 90°</strong> (e.g., 106° will be preferred over 147°).</li>
                <li><strong>For Other Systems:</strong> If M(20) scores are tied, the first solution found is retained.</li>
            </ul>
        </section>

        <section id="troubleshooting">
            <h2>Troubleshooting & FAQ</h2>

            <h4>Why were no solutions found?</h4>
            <ul>
                <li><strong>Poor Peak List:</strong> The most common cause. Ensure the peak list is accurate, with impurity peaks removed and positions refined. A minimum of 15-20 clean peaks is recommended.</li>
                <li><strong>Incorrect Parameters:</strong> Verify the <code>Wavelength</code> and ensure the <code>Max Volume</code> is chemically reasonable and sufficiently large.</li>
                <li><strong>High Zero-Point Error:</strong> While the program corrects for small zero errors internally, a very large instrument misalignment may still cause failure.</li>
                <li><strong>Sample is a Mixture:</strong> Indexing requires a peak list from a single crystalline phase.</li>
            </ul>

            <h4>Why is M(20) low for a visually good fit?</h4>
            <ul>
                <li><strong>Incorrect Cell (Sub-multiple/Super-multiple):</strong> The found cell may be a multiple or sub-multiple of the true cell. It indexes some lines but is penalized by M(20) for being too "empty" or "dense" with calculated reflections.</li>
                <li><strong>High Error / Low Resolution:</strong> The <code>2θ Error</code> might be set too tight for broad peaks. Try slightly increasing this value.</li>
                <li><strong>Spurious Solution:</strong> A random solution can sometimes fit a few lines by chance. Visual inspection is key; if major observed peaks are missed by the calculated pattern, the solution is incorrect regardless of the M(20) value.</li>
            </ul>
        </section>


                    <section id="references">
            <h2>References</h2>
            <p>This program was developed by Nita Dragoe at Université Paris-Saclay (2024-2025) as a successor to a prior software, Powder 4, originally created by the same author in 1999-2000. For a deeper understanding of the methodology, consulting the original scientific papers is highly recommended.</p>
            <ol>
                <li>
                    <strong>The M(20) Figure of Merit:</strong><br>
                    de Wolff, P. M. (1968). "A Simplified Criterion for the Reliability of a Powder Pattern Indexing." <em>Journal of Applied Crystallography</em>, <strong>1</strong>, 108-113.
                </li>
                <li>
                    <strong>General Powder Diffraction Text:</strong><br>
                    Klug, H. P. & Alexander, L. E. (1974). <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em>, 2nd ed. New York: Wiley-Interscience.
                </li>
                <li>
                    <strong>Kα2 Stripping Algorithm:</strong><br>
                    Rachinger, W. A. (1948). "A Correction for the α1α2 Doublet in the Measurement of Widths of X-Ray Diffraction Lines." <em>Journal of Scientific Instruments</em>, <strong>25</strong>, 254-255.
                </li>
                <li>
                    <strong>Alternative Indexing Methods:</strong><br>
                    Ito, T. (1949). "A General Powder X-ray Photography."<em>Nature</em>, 164, 755-756.<br>
                    Werner, P.-E., Eriksson, L., & Westdahl, M. (1985). "TREOR, a semi-exhaustive trial-and-error powder indexing program for all symmetries." <em>Journal of Applied Crystallography</em>, <strong>18</strong>, 367-370.<br>
                     Visser, J. W. (1969). "A fully automatic program for finding the unit cell from powder data." <em>Journal of Applied Crystallography</em>, <strong>2</strong>, 89-95.<br>
                     Le Bail, A. (2004). "Monte Carlo Indexing with McMaille". <em>Powder Diffraction</em>, <strong>19(3)</strong>, 249-254.<br>
                     Boultif, A. & Louër, D. (2004). "Powder pattern indexing with the dichotomy method." <em>Journal of Applied Crystallography</em>, <strong>37</strong>, 724-731.

                    </li>
            </ol>
            <div class="footer">
                <p>Help Guide updated on 23 Oct 2025 by an AI assistant.</p>
            </div>
        </section>

    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('#toc a');
        const mainContent = document.getElementById('main-content');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => link.classList.remove('active'));
                    const activeLink = document.querySelector(`#toc a[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { root: mainContent, rootMargin: "0px 0px -80% 0px" });

        sections.forEach(section => observer.observe(section));

        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                navLinks.forEach(l => l.classList.remove('active'));
                this.classList.add('active');
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);

                if (targetElement) {
                    mainContent.scrollTo({
                        top: targetElement.offsetTop - 32,
                        behavior: 'smooth'
                    });
                }
            });
        });

        const updateActiveLink = () => {
            let currentActive = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top >= 0 && rect.top <= mainContent.clientHeight * 0.2) {
                    currentActive = section.getAttribute('id');
                }
            });

            if (currentActive) {
                navLinks.forEach(link => link.classList.remove('active'));
                const activeLink = document.querySelector(`#toc a[href="#${currentActive}"]`);
                if (activeLink) activeLink.classList.add('active');
            } else {
                // If no section is clearly active at the top, default to the first one
                 if (mainContent.scrollTop < sections[0].offsetTop + sections[0].offsetHeight) {
                     navLinks.forEach(link => link.classList.remove('active'));
                     if (navLinks.length > 0) navLinks[0].classList.add('active');
                 }
            }
        };

        // Update active link on scroll
        mainContent.addEventListener('scroll', updateActiveLink);

        // Initial update after load
        setTimeout(updateActiveLink, 150);
    });
</script>

</body>
</html>
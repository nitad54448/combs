<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKL Pattern Simulator</title>
   
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
   
   
   <style>
         :root {
            --dark-bg: #111827; --medium-bg: #1f2937; --light-bg: #374151;
            --border-color: #4b5563; --primary-accent: #1a73e8; --text-light: #e5e7eb;
            --text-medium: #d1d5db; --text-dark: #9ca3af; --error-red: #dc2626;
        }
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 350px; min-width: 300px; max-width: 600px; flex-shrink: 0; padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); overflow-y: auto; color: var(--text-medium); display: flex; flex-direction: column; z-index: 20;}
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: #ffffff; 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
           
            padding: 1.5rem 1.5rem 0.5rem 1.5rem; 
            color: var(--medium-bg); 
            z-index: 10;
        }
        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.35rem; padding: 0.5rem 0.75rem; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .control-input:disabled { background-color: var(--medium-bg); opacity: 0.6; cursor: not-allowed; }
        .control-input.error { border-color: var(--error-red); }
        .btn-like { display: flex; align-items: center; justify-content: center; padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; font-size: 1rem; text-align: center; cursor: pointer; border: none; transition: background-color: 0.2s; }
        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #1765cc; }
        .btn-secondary { background-color: var(--light-bg); color: var(--text-light); border: 1px solid var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: #4a5568; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        .hidden { display: none !important; }
        .parameter-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 0.75rem; }
        .parameter-grid .control-input { width: 100%; }
        
      
        #hkl-chart-container { 
            width: 100%; 
            flex-grow: 1; 
            position: relative; 
            min-height: 0; 
        }
        #placeholder { 
            width: 100%; 
            flex-grow: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            text-align: center; 
            color: #6b7280;
        }
        #placeholder svg { width: 4rem; height: 4rem; margin-bottom: 1rem; }
        
       
        #app-footer {
            padding: 8px 0;
            text-align: right;
            font-size: 0.65rem;
            color: var(--text-dark);
            border-top: 1px solid #e5e7eb; /* Light border inside results panel */
            margin-top: auto; 
            flex-shrink: 0;
        }
        
       
        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Gap between label and box */
            margin-bottom: 0.75rem;
            
        }
        .slider-group .control-label {
            margin-bottom: 0;
            font-size: 0.875rem;
            color: var(--text-dark); 
            flex-shrink: 0;
            min-width: 50px;
            text-align: left;
        }
        
    
        .slider-box {
            background-color: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.35rem;
            padding: 0.5rem 0.75rem;
            height: 32px;
            box-sizing: border-box;
            
            flex-grow: 1; /* Box fills remaining space */
            display: flex;
            align-items: center;
        }
        
        
        .slider-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex; 
            align-items: center;
            height: 100%; 
        }

        input[type="range"].custom-slider {
            flex-grow: 1; 
            
            height: 4px; 
            background: transparent; 
            border-radius: 2px;
            appearance: none; -webkit-appearance: none; outline: none;
            margin: 0;
            width: 100%; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; 
            background: #ffffff80; /* blanc; le 80 indique la transparence */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--primary-accent); 
            /* Add z-index to ensure thumb is on top of value */
            position: relative;
            z-index: 10;
        }
        input[type="range"].custom-slider::-moz-range-thumb {
            width: 16px; height: 16px;
            
            background: #ffffff80; /* Pure white fill; 50% tranparence */
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid var(--primary-accent); 
            position: relative;
            z-index: 10;
        }
        
        .slider-value-display {
            /* Position in middle of wrapper */
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            
            font-size: 0.9rem;
            color: var(--text-light);
            text-align: center; /* Center text */
            min-width: 45px; /* Keep min-width */
            
            /* Make it unclickable so slider works */
            pointer-events: none;
            z-index: 5; /* Behind thumb, above track */
        }
        
        
        /* Checkbox style */
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer; margin-top: 0.75rem;}
        .checkbox-label input:disabled + span { opacity: 0.5; cursor: not-allowed; }
        .checkbox-label input:disabled { cursor: not-allowed; }
        input[type="checkbox"] { accent-color: var(--primary-accent); transform: scale(1.1); }

        .btn-like.file-label {
            display: block; 
            width: 100%; /* Explicitly set to 100% of parent */
            max-width: 100%; 
            text-align: left; 
            box-sizing: border-box; 
        }
        
        #space-group-fields {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem; /* Space between input/select and system display */
        }

        #space-group-input,
		#space-group-setting {
		    flex: 1 1 0;
		    width: 100%;
		}

		#wavelength-inputs-container {
		    display: flex;
		    gap: 0.5rem;
		}

		#wavelength-preset,
		#wavelength {
		    flex: 1 1 0;       /* each takes half */
		    min-width: 0;      /* prevent select from expanding */
		    box-sizing: border-box;
		}
		
        
        .tooltip {
            position: relative;
            display: inline-block;
            z-index: 100; /* Ensure tooltip is on top */
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px; /* Set width */
            background-color: var(--light-bg); /* Use theme color */
            color: var(--text-light); /* Use theme color */
            text-align: left;
            border-radius: 6px;
            padding: 12px 16px;
            position: absolute;
            z-index: 101;
            top: 150%; /* Position below the icon */
            left: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.5;
            border: 1px solid var(--border-color); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .tooltip .tooltiptext ul {
            list-style-position: inside;
            padding-left: 0.5rem;
            margin-top: 0.25rem;
        }
        .tooltip .tooltiptext li {
            margin-bottom: 0.25rem;
        }

        .tooltip .tooltiptext::after { /* Arrow */
            content: "";
            position: absolute;
            bottom: 100%; /* At the top of the tooltip */
            left: 10px; /* Near the left edge */
            margin-left: 0;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent var(--light-bg) transparent; /* Match bg */
        }

        .tooltip .tooltiptext.visible {
            visibility: visible;
            opacity: 1;
        }
        
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">

            <div class="control-group">
                
                 <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 8px;">
                    
                     <div class="tooltip">
                         <span id="tooltip-icon" style="display: flex; align-items: center; justify-content: center; width: 22px; height: 22px; font-weight: 700; color: var(--dark-bg); background-color: var(--text-dark); border-radius: 50%; cursor: pointer; user-select: none; font-size: 0.875rem;">?</span>
                         <span id="tooltip-text" class="tooltiptext">
                             <b>HKL Pattern Simulator</b><br>
                             Calculates theoretical HKL reflection positions from space group and unit cell parameters.
                             <br><br>
                             <b>Chart Interactions:</b>
                             <ul>
                                 <li><b>Zoom:</b> Use the mouse wheel.</li>
                                 <li><b>Pan:</b> Click and drag.</li>
                                 <li><b>Reset:</b> Right-click on the chart.</li>
                             </ul>
                         </span>
                     </div>
                   
                     <label for="exp-file-input" class="control-label" style="margin-bottom: 0;">Experimental Data (Optional)</label>
                 </div>
                 
                
                 <label for="exp-file-input" class="btn-like btn-secondary file-label">
                     <span id="exp-file-name">Select Data File...</span>
                 </label>
                 <input type="file" id="exp-file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf,.xra,.gsa,.dat,.asc">
            </div>

             <div class="control-group">
                <label class="control-label">Space Group</label> <div id="space-group-fields">
                    <input type="text" id="space-group-input" class="control-input" placeholder="e.g., 3 or P 1 2 1">
                    <select id="space-group-setting" class="control-select" disabled>
                         <option value="-1">Default</option>
                    </select>
                </div>
                <div style="margin-top: 8px; font-size: 0.8rem;">
                    <span class="control-label" style="display: inline;">Crystal System:</span>
                    <span id="crystal-system-display" style="color: var(--text-light); font-weight: 500;">-</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="wavelength-preset" class="control-label">Wavelength (Å)</label>
                 <div id="wavelength-inputs-container">
                    <select id="wavelength-preset" class="control-select">
                        <option value="Cu">Cu Kα (avg)</option>
                        <option value="Mo">Mo Kα (avg)</option>
                        <option value="Co">Co Kα (avg)</option>
                        <option value="Fe">Fe Kα (avg)</option>
                        <option value="Cr">Cr Kα (avg)</option>
                        <option value="custom">Custom</option>
                    </select>
                    <input type="number" id="wavelength" value="1.54184" step="0.00001" min="0.1" class="control-input">
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="plot-ka2-checkbox">
                    <span>Plot Kα1 and Kα2 separately</span>
                </label>
            </div>

            <div class="control-group">
                <label class="control-label">Unit Cell Parameters</label>
                <div class="parameter-grid">
                    <div><label for="cell-a" class="control-label" style="font-size: 0.75rem;">a (Å)</label><input type="number" id="cell-a" value="5.0" step="0.01" min="1" class="control-input" disabled></div>
                    <div><label for="cell-b" class="control-label" style="font-size: 0.75rem;">b (Å)</label><input type="number" id="cell-b" value="5.0" step="0.01" min="1" class="control-input" disabled></div>
                    <div><label for="cell-c" class="control-label" style="font-size: 0.75rem;">c (Å)</label><input type="number" id="cell-c" value="5.0" step="0.01" min="1" class="control-input" disabled></div>
                    <div><label for="cell-alpha" class="control-label" style="font-size: 0.75rem;">α (°)</label><input type="number" id="cell-alpha" value="90.0" step="0.1" min="30" max="150" class="control-input" disabled></div>
                    <div><label for="cell-beta" class="control-label" style="font-size: 0.75rem;">β (°)</label><input type="number" id="cell-beta" value="90.0" step="0.1" min="30" max="150" class="control-input" disabled></div>
                    <div><label for="cell-gamma" class="control-label" style="font-size: 0.75rem;">γ (°)</label><input type="number" id="cell-gamma" value="90.0" step="0.1" min="30" max="150" class="control-input" disabled></div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" style="margin-bottom: 0.75rem;">2θ Range</label> 
                
                <div class="slider-group">
                    <label for="min-2theta-slider" class="control-label">2θ Min</label>
                    <div class="slider-box">
                        <div class="slider-wrapper">
                            <input type="range" id="min-2theta-slider" class="custom-slider" min="0" max="170" value="5" step="0.1">
                            <span id="min-2theta-value" class="slider-value-display">5.00</span>
                        </div>
                    </div>
                </div>
                <div class="slider-group">
                    <label for="max-2theta-slider" class="control-label">2θ Max</label>
                   
                    <div class="slider-box">
                        <div class="slider-wrapper">
                            <input type="range" id="max-2theta-slider" class="custom-slider" min="5" max="180" value="90" step="0.1">
                            <span id="max-2theta-value" class="slider-value-display">90.00</span>
                        </div>
                    </div>
                </div>
                 <input type="number" id="min-2theta" class="hidden" value="5">
                 <input type="number" id="max-2theta" class="hidden" value="90">
            </div>
            
            <div class="control-group" style="margin-top: auto;">
                <button id="save-hkl-button" class="btn btn-primary btn-like" style="width: 100%;" disabled>Enter Valid Space Group</button>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Setup Simulation</h2>
                <p>Select a Space Group and enter parameters to start.</p>
            </div>
            <div id="hkl-chart-container" class="hidden">
                <canvas id="hkl-chart"></canvas>
            </div>
            
            
            <footer id="app-footer">
                IndexMan, version 15 nov 2025. NitaD, Univ Paris-Saclay
            </footer>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let spaceGroupData = null;
            let currentSpaceGroup = null;
            let currentHKLList_ka1 = []; // Store calculated Ka1 reflections
            let currentHKLList_ka2 = []; // Store calculated Ka2 reflections
            let hklChart = null;
            let experimentalData = { tth: [], intensity: [] };

            const uiElements = {
                sgInput: document.getElementById('space-group-input'), systemDisplay: document.getElementById('crystal-system-display'), settingSelect: document.getElementById('space-group-setting'),
                cellA: document.getElementById('cell-a'), cellB: document.getElementById('cell-b'), cellC: document.getElementById('cell-c'),
                cellAlpha: document.getElementById('cell-alpha'), cellBeta: document.getElementById('cell-beta'), cellGamma: document.getElementById('cell-gamma'),
                wavelengthPreset: document.getElementById('wavelength-preset'), wavelength: document.getElementById('wavelength'),
                plotKa2Checkbox: document.getElementById('plot-ka2-checkbox'),
                min2ThetaSlider: document.getElementById('min-2theta-slider'), max2ThetaSlider: document.getElementById('max-2theta-slider'),
                min2ThetaValue: document.getElementById('min-2theta-value'), max2ThetaValue: document.getElementById('max-2theta-value'),
                min2ThetaNum: document.getElementById('min-2theta'), max2ThetaNum: document.getElementById('max-2theta'),
                saveButton: document.getElementById('save-hkl-button'),
                expFileInput: document.getElementById('exp-file-input'), expFileName: document.getElementById('exp-file-name'),
                chartCanvas: document.getElementById('hkl-chart'), chartContainer: document.getElementById('hkl-chart-container'),
                placeholder: document.getElementById('placeholder')
            };
            
            const WAVELENGTH_PRESETS = {
                'Cu': { ka1: 1.54056, ka2: 1.54439, ka_avg: 1.54184 },
                'Mo': { ka1: 0.70930, ka2: 0.71359, ka_avg: 0.71073 },
                'Co': { ka1: 1.78897, ka2: 1.79285, ka_avg: 1.79026 },
                'Fe': { ka1: 1.93604, ka2: 1.93998, ka_avg: 1.93735 },
                'Cr': { ka1: 2.28970, ka2: 2.29361, ka_avg: 2.29092 },
                'custom': { ka1: null, ka2: null, ka_avg: null } // User defined, monochromatic
            };

            const debounce = (func, delay) => { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; };

            async function loadSpaceGroupData() { try { const response = await fetch('space_groups_all_settings.json'); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); spaceGroupData = await response.json(); console.log("Space group data loaded."); } catch (error) { console.error("Could not load space group data:", error); alert("Error: Could not load space group definitions."); uiElements.sgInput.disabled = true; uiElements.sgInput.placeholder = "Error loading definitions"; } }

            function findSpaceGroup(input) { if (!spaceGroupData || !input) return null; const searchTerm = input.trim().toLowerCase().replace(/\s+/g, '').replace('-', ''); if (/^\d+$/.test(searchTerm)) { const sgObject = spaceGroupData.space_groups[searchTerm]; if (sgObject) return sgObject; } for (const sgKey in spaceGroupData.space_groups) { const sg = spaceGroupData.space_groups[sgKey]; const stdSymbolNorm = sg.standard_symbol.toLowerCase().replace(/\s+/g, '').replace('-', ''); if (stdSymbolNorm === searchTerm) return sg; if (sg.settings) { for (const setting of sg.settings) { const settingSymbolNorm = setting.symbol.toLowerCase().replace(/\s+/g, '').replace('-', ''); if (settingSymbolNorm === searchTerm) return sg; } } } return null; }


      
const validateInputStyle = (input, min, max) => {
    const valueStr = input.value.trim();
    // Don't show error for empty or incomplete numbers
    if (valueStr === '' || valueStr === '-' || valueStr === '.') {
        input.classList.remove('error');
        return;
    }
    try {
        const value = parseFloat(valueStr);
        if (isNaN(value) || value < min || value > max) {
            input.classList.add('error'); // Show error
        } else {
            input.classList.remove('error'); // Valid
        }
    } catch (e) {
        input.classList.add('error');
    }
};


const validateAndRevert = (input, min, max, defaultValue) => {
    const valueStr = input.value.trim();
    try {
        let value = parseFloat(valueStr);
        // Check if invalid (NaN or out of bounds)
        if (isNaN(value) || value < min || value > max) {
            value = defaultValue; // Get default
            input.value = defaultValue; // Set input field to default
        }
        input.classList.remove('error'); // Clear error style
        return value; // Return the valid number
    } catch (e) {
        input.value = defaultValue; // Revert on any parse error
        input.classList.remove('error');
        return defaultValue;
    }
};


function updateParameterInputs(system, settingDesc = null) {
    const inputs = { a: uiElements.cellA, b: uiElements.cellB, c: uiElements.cellC, alpha: uiElements.cellAlpha, beta: uiElements.cellBeta, gamma: uiElements.cellGamma };
    
    // bounds, 100 ? c'est débile mais bon
    const bounds = {
        a: { min: 1, max: 100, default: 5.0 },
        b: { min: 1, max: 100, default: 5.0 },
        c: { min: 1, max: 100, default: 5.0 },
        alpha: { min: 20, max: 165, default: 90.0 },
        beta: { min: 20, max: 165, default: 90.0 },
        gamma: { min: 20, max: 165, default: 90.0 }
    };

    // Disable and clear all listeners first
    Object.values(inputs).forEach(input => {
        
        input.removeEventListener('input', debouncedCalculate);
        if (input._styleListener) {
            input.removeEventListener('input', input._styleListener);
            input._styleListener = null;
        }
        if (input._revertListener) {
            input.removeEventListener('change', input._revertListener);
            input._revertListener = null;
        }
        // Reset state
        input.disabled = true; input.readOnly = true; input.style.opacity = 0.6;
        input.removeAttribute('listener-added');
        input.classList.remove('error'); 
    });
    
    
    inputs.alpha.value = 90.0; inputs.beta.value = 90.0; inputs.gamma.value = 90.0;

    // Helper function to add listeners
    const setupListener = (inputElement) => {
        if (!inputElement.getAttribute('listener-added')) {
    
            const inputId = inputElement.id.replace('cell-', ''); // 'a', 'b', 'alpha', etc.
            const b = bounds[inputId];
            
            if (b) {
                // 1. Add live styling listener on 'input'
                inputElement._styleListener = () => validateInputStyle(inputElement, b.min, b.max);
                inputElement.addEventListener('input', inputElement._styleListener);
                
                // 2. Add revert listener on 'change' (loss of focus)
                inputElement._revertListener = () => {
                    validateAndRevert(inputElement, b.min, b.max, b.default);
                    // Also trigger calculation update 
                    debouncedCalculate(); 
                };
                inputElement.addEventListener('change', inputElement._revertListener);
            }
            
            // 3. Add calculation listener on 'input'
            inputElement.addEventListener('input', debouncedCalculate);
            
            inputElement.setAttribute('listener-added', 'true');
        }
    };
    
    // Helper function to enable input
    const enable = (id, readOnly = false) => {
        inputs[id].disabled = false; inputs[id].readOnly = readOnly; inputs[id].style.opacity = 1;
        if (!readOnly) {
            setupListener(inputs[id]);
            // Run initial validation style check
            const b = bounds[id];
            if (b) {
                validateInputStyle(inputs[id], b.min, b.max);
            }
        }
    };

    // à vérifier le switch, avant c'était if/else, illisible
    switch (system) {
        case 'cubic':
            enable('a');
            // Link b and c to a
            inputs.a.addEventListener('input', () => {
                inputs.b.value = inputs.a.value; inputs.c.value = inputs.a.value;
                // Validate linked inputs visually
                validateInputStyle(inputs.b, bounds.b.min, bounds.b.max);
                validateInputStyle(inputs.c, bounds.c.min, bounds.c.max);
               
            });
            inputs.b.value = inputs.a.value; inputs.c.value = inputs.a.value;
            inputs.a.addEventListener('change', () => {
                // When 'a' reverts, revert 'b' and 'c' too
                inputs.b.value = inputs.a.value;
                inputs.c.value = inputs.a.value;
            });
            inputs.a.setAttribute('listener-added', 'true'); // a listener setup in enable()
            break;
        case 'hexagonal': case 'trigonal':
            enable('a'); enable('c');
            inputs.gamma.value = 120.0; // Fixed gamma
            // Link b to a
            inputs.a.addEventListener('input', () => {
                inputs.b.value = inputs.a.value;
                // Validate linked input visually
                validateInputStyle(inputs.b, bounds.b.min, bounds.b.max);
            });
            inputs.b.value = inputs.a.value;
            // Add 'change' listener for linked inputs
            inputs.a.addEventListener('change', () => {
                inputs.b.value = inputs.a.value;
            });
            inputs.a.setAttribute('listener-added', 'true');
            setupListener(inputs.c);
            break;
         case 'tetragonal':
            enable('a'); enable('c');
            // Link b to a
            inputs.a.addEventListener('input', () => {
                inputs.b.value = inputs.a.value;
                // Validate linked input visually
                validateInputStyle(inputs.b, bounds.b.min, bounds.b.max);
            });
            inputs.b.value = inputs.a.value;
            // Add 'change' listener for linked inputs
            inputs.a.addEventListener('change', () => {
                inputs.b.value = inputs.a.value;
            });
            inputs.a.setAttribute('listener-added', 'true');
             setupListener(inputs.c);
            break;
        case 'orthorhombic':
            enable('a'); enable('b'); enable('c');
            break;
        case 'monoclinic':
            const uniqueAxis = settingDesc || 'b'; 
            enable('a'); enable('b'); enable('c');
            if (uniqueAxis === 'a') {
                enable('alpha'); 
                inputs.beta.value = 90.0; 
                inputs.gamma.value = 90.0; 
            } else if (uniqueAxis === 'c') {
                enable('gamma'); 
                inputs.alpha.value = 90.0; 
                inputs.beta.value = 90.0; 
            } else { // 'b'
                enable('beta'); 
                inputs.alpha.value = 90.0; 
                inputs.gamma.value = 90.0; 
            }
            break;
        case 'triclinic':
            enable('a'); enable('b'); enable('c'); enable('alpha'); enable('beta'); enable('gamma');
            break;
    }
    
     // Ensure all enabled, non-readonly inputs have a listener
     ['a', 'b', 'c', 'alpha', 'beta', 'gamma'].forEach(id => {
         if (!inputs[id].disabled && !inputs[id].readOnly && !inputs[id].getAttribute('listener-added')) {
             setupListener(inputs[id]);
         }
     });
     // Style disabled/readonly inputs
     Object.values(inputs).forEach(input => { if (input.disabled || input.readOnly) { input.style.opacity = 0.6; }});
}



            function updateSettingsDropdown(sg) {
                uiElements.settingSelect.innerHTML = '';
                if (sg && sg.settings && sg.settings.length > 0) {
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "0";
                    defaultOption.textContent = `Standard: ${sg.settings[0].symbol}` + (sg.settings[0].description ? ` (${sg.settings[0].description})` : '');
                    uiElements.settingSelect.appendChild(defaultOption);
                    if (sg.settings.length > 1) {
                        sg.settings.slice(1).forEach((setting, index) => {
                            const option = document.createElement('option');
                            option.value = index + 1;
                            option.textContent = `${setting.symbol}` + (setting.description ? ` (${setting.description})` : '');
                            uiElements.settingSelect.appendChild(option);
                        });
                        uiElements.settingSelect.disabled = false;
                    } else {
                        uiElements.settingSelect.disabled = true;
                    }
                } else {
                    const option = document.createElement('option');
                    option.value = "-1";
                    option.textContent = "N/A";
                    uiElements.settingSelect.appendChild(option);
                    uiElements.settingSelect.disabled = true;
                }
            }


            function getCurrentParameters() {
    const system = currentSpaceGroup?.crystal_system;
    const preset = uiElements.wavelengthPreset.value;
    const plotKa2 = uiElements.plotKa2Checkbox.checked && preset !== 'custom';

    // erreurs ? 
    let hasError = false;
    let hasEmpty = false;
    
    const inputsToValidate = [
        uiElements.cellA, uiElements.cellB, uiElements.cellC,
        uiElements.cellAlpha, uiElements.cellBeta, uiElements.cellGamma,
        uiElements.wavelength
    ];
    
    for (const input of inputsToValidate) {
        
        if (!input.disabled) {
            if (input.classList.contains('error')) {
                hasError = true;
                break; // Found an error, no need to check others
            }
            if (input.value.trim() === '') {
                hasEmpty = true;
                break; // Found an empty field, no need to check others
            }
        }
    }
    
    if (hasError) {
        console.warn("Calculation paused, invalid input detected.");
        return null; // Stop calculation
    }
    if (hasEmpty) {
        console.warn("Calculation paused, empty field detected.");
        return null; // Stop calculation
    }
    
    // All inputs are now considered valid and non-empty
    
    let lambda_val = parseFloat(uiElements.wavelength.value);
    let a_val = parseFloat(uiElements.cellA.value);
    let b_val, c_val, alpha_val, beta_val, gamma_val;

    // Start with default values
    b_val = parseFloat(uiElements.cellB.value); 
    c_val = parseFloat(uiElements.cellC.value); 
    alpha_val = 90.0;
    beta_val = 90.0;
    gamma_val = 90.0;

    // Adjust based on system
    if (system === 'cubic') {
        b_val = a_val; 
        c_val = a_val; 
    } else if (system === 'hexagonal' || system === 'trigonal') {
        b_val = a_val; 
        c_val = parseFloat(uiElements.cellC.value);
        gamma_val = 120.0;
    } else if (system === 'tetragonal') {
        b_val = a_val; 
        c_val = parseFloat(uiElements.cellC.value);
    } else if (system === 'orthorhombic') {
        b_val = parseFloat(uiElements.cellB.value);
        c_val = parseFloat(uiElements.cellC.value);
    } else if (system === 'monoclinic') {
        b_val = parseFloat(uiElements.cellB.value);
        c_val = parseFloat(uiElements.cellC.value);

        const settingIndex = parseInt(uiElements.settingSelect.value) >= 0 ? parseInt(uiElements.settingSelect.value) : 0;
        const settingDesc = currentSpaceGroup.settings?.[settingIndex]?.description || 'b';
        if (settingDesc === 'a') {
            alpha_val = parseFloat(uiElements.cellAlpha.value);
        } else if (settingDesc === 'c') {
            gamma_val = parseFloat(uiElements.cellGamma.value);
        } else { // 'b'
            beta_val = parseFloat(uiElements.cellBeta.value);
        }
    } else if (system === 'triclinic') {
        b_val = parseFloat(uiElements.cellB.value);
        c_val = parseFloat(uiElements.cellC.value);
        alpha_val = parseFloat(uiElements.cellAlpha.value);
        beta_val = parseFloat(uiElements.cellBeta.value);
        gamma_val = parseFloat(uiElements.cellGamma.value);
    } else {
        // No valid system
        b_val = parseFloat(uiElements.cellB.value);
        c_val = parseFloat(uiElements.cellC.value);
    }
    
    const params = {
        a: a_val, b: b_val, c: c_val,
        alpha: alpha_val, beta: beta_val, gamma: gamma_val,
        lambda: plotKa2 && preset !== 'custom' ? WAVELENGTH_PRESETS[preset].ka1 : lambda_val,
        lambda_ka2: plotKa2 && preset !== 'custom' ? WAVELENGTH_PRESETS[preset].ka2 : null,
        system: system
    };
    
    // Final check for NaN , useless, I think
    if (isNaN(params.lambda) || isNaN(params.a) || isNaN(params.b) || isNaN(params.c) || isNaN(params.alpha) || isNaN(params.beta) || isNaN(params.gamma)) {
         console.error("NaN value detected after parsing."); 
         return null; 
    }
     
    return params;
}


//
// la partie critique, erreur ici avant le 15 nov 2025
//
function generateHKL_for_indexing(maxTth, params, laueClass, lambda, setting = null) {
    const { a, b, c, alpha, beta, gamma } = params;
    if (!a || !lambda) return [];

    const reflections = [];
    const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
    const q_max_limit = (1 / (d_min * d_min)) * 1.05;

    const h_max = Math.ceil(a / d_min) + 1;
    const k_max = b ? Math.ceil(b / d_min) + 1 : h_max;
    const l_max = c ? Math.ceil(c / d_min) + 1 : h_max;

    // ---- Centering rules ----
    function passesCentering(h, k, l) {
        const sym = (setting?.symbol || "").toUpperCase();
        if (sym.startsWith("I")) {
            return (h + k + l) % 2 === 0;
        }
        if (sym.startsWith("F")) {
            const ph = ((h % 2) + 2) % 2;
            const pk = ((k % 2) + 2) % 2;
            const pl = ((l % 2) + 2) % 2;
            return (ph === pk && pk === pl);
        }
        if (sym.startsWith("C")) {
            return (h + k) % 2 === 0;
        }
        if (sym.startsWith("A")) {
            return (k + l) % 2 === 0;
        }
        if (sym.startsWith("B")) {
            return (h + l) % 2 === 0;
        }
        return true; // P, R, etc.
    }


    // ---- Laue class canonicalization ----
    function isCanonical(h, k, l) {
        // This function combines Friedel's Law (hkl vs -h-k-l)
        // and Laue class symmetry (e.g., hkl vs h-kl)
        // It now maps all 32 point groups (from laueClass) to the 11 Laue classes.
        
        const laue = (laueClass || "").toLowerCase().replace(/\s+/g, '');

        switch (laue) {
            // Triclinic (Laue Class -1)
            case "1":
            case "-1": // triclinic
                // Friedel reduction only: l>0 or (l=0, k>0) or (l=0, k=0, h>=0)
                if (l < 0) return false;
                if (l === 0 && k < 0) return false;
                if (l === 0 && k === 0 && h < 0) return false;
                return true;

            // Monoclinic (Laue Class 2/m)
            case "2":
            case "m":
            case "2/m": {
                const ua = (setting?.description || 'b').toLowerCase(); // Use description
                if (ua === 'b') { // Unique axis b. Equivalents: (h,k,l), (h,-k,l), (-h,k,-l), (-h,-k,-l)
                    // Standard reduction: k >= 0, l >= 0. If l=0, h >= 0.
                    if (k < 0) return false;
                    if (l < 0) return false;
                    if (l === 0 && h < 0) return false;
                    return true;
                } else if (ua === 'c') { // Unique axis c. Equivalents: (h,k,l), (h,k,-l), (-h,-k,l), (-h,-k,-l)
                    // Standard reduction: l >= 0, k >= 0. If k=0, h >= 0.
                    if (l < 0) return false;
                    if (k < 0) return false;
                    if (k === 0 && h < 0) return false;
                    return true;
                } else if (ua === 'a') { // Unique axis a. Equivalents: (h,k,l), (-h,k,l), (h,-k,-l), (-h,-k,-l)
                    // Standard reduction: h >= 0, l >= 0. If l=0, k >= 0.
                    if (h < 0) return false;
                    if (l < 0) return false;
                    if (l === 0 && k < 0) return false;
                    return true;
                }
                return true; // Should not be reached
            }

            // Orthorhombic (Laue Class mmm)
            case "222":
            case "mm2":
            case "mmm":
                // h>=0, k>=0, l>=0
                if (h < 0 || k < 0 || l < 0) return false;
                return true;

            // Tetragonal (Laue Class 4/m)
            case "4":
            case "-4":
            case "4/m":
            // Tetragonal (Laue Class 4/mmm)
            case "422":
            case "4mm":
            case "-42m":
            case "-4m2":
            case "4/mmm":
                // l>=0, h>=k, k>=0
                if (l < 0) return false;
                if (k < 0) return false;
                if (h < k) return false;
                return true;

            // Trigonal (Laue Class -3)
            case "3":
            case "-3":
            // Trigonal (Laue Class -3m)
            case "32":
            case "3m":
            case "-3m":
            case "312": // Specific cases
            case "321":
            case "3m1":
            case "31m":
            case "-3m1":
            case "-31m":
            // Hexagonal (Laue Class 6/m)
            case "6":
            case "-6":
            case "6/m":
            // Hexagonal (Laue Class 6/mmm)
            case "622":
            case "6mm":
            case "-6m2":
            case "-62m":
            case "6/mmm":
                 // l>=0 and (h>=k>=0)
                if (l < 0) return false;
                if (k < 0) return false;
                // For hex, h>=k>=0 is a common reduction
                if (h < k) return false; 
                return true;

            // Cubic (Laue Class m-3)
            case "23":
            case "m-3":
            // Cubic (Laue Class m-3m)
            case "432":
            case "-43m":
            case "m-3m":
                // h>=k>=l>=0
                if (l < 0) return false;
                if (k < l) return false;
                if (h < k) return false;
                return true;

            default: // Failsafe, same as triclinic
                if (l < 0) return false;
                if (l === 0 && k < 0) return false;
                if (l === 0 && k === 0 && h < 0) return false;
                return true;
        }
    }


    // ---- d*2 formulas ----
    function inv_d_sq_for(h, k, l) {
        // This switch now maps all 32 point groups to the 11 Laue class formulas
        const laue = (laueClass || "").toLowerCase().replace(/\s+/g, '');
        
        switch (laue) {
            // Cubic (Laue Classes m-3, m-3m)
            case "23":
            case "m-3":
            case "432":
            case "-43m":
            case "m-3m":
                return (h*h + k*k + l*l) / (a*a);
            
            // Tetragonal (Laue Classes 4/m, 4/mmm)
            case "4":
            case "-4":
            case "4/m":
            case "422":
            case "4mm":
            case "-42m":
            case "-4m2":
            case "4/mmm":
                return (h*h + k*k) / (a*a) + (l*l) / (c*c);
            
            // Orthorhombic (Laue Class mmm)
            case "222":
            case "mm2":
            case "mmm":
                return (h*h) / (a*a) + (k*k) / (b*b) + (l*l) / (c*c);
            
            // Trigonal/Hexagonal (Laue Classes -3, -3m, 6/m, 6/mmm)
            case "3":
            case "-3":
            case "32":
            case "3m":
            case "-3m":
            case "312": // Specific cases
            case "321":
            case "3m1":
            case "31m":
            case "-3m1":
            case "-31m":
            case "6":
            case "-6":
            case "6/m":
            case "622":
            case "6mm":
            case "-6m2":
            case "-62m":
            case "6/mmm":
                return (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c);
            
            // Monoclinic (Laue Class 2/m)
            case "2":
            case "m":
            case "2/m": {
                const uniqueAxis = setting?.description || 'b';

                if (uniqueAxis === 'b') {
                    const sb = Math.sin(beta * Math.PI / 180), cb = Math.cos(beta * Math.PI / 180);
                    const sb2 = sb*sb;
                    if (sb2 < 1e-12) return 0;
                    // Standard formula for unique axis 'b'
                    return (1/sb2) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cb/(a*c)) + (k*k)/(b*b);
                } else {
                     // Use the general triclinic formula for unique axis 'a' or 'c'.
                     // This is always correct, even if alpha/beta/gamma are 90.
                    const ca = Math.cos(alpha * Math.PI / 180), cb = Math.cos(beta * Math.PI / 180), cg = Math.cos(gamma * Math.PI / 180);
                    const sa = Math.sin(alpha * Math.PI / 180), sb = Math.sin(beta * Math.PI / 180), sg = Math.sin(gamma * Math.PI / 180);
                    const V2 = (a*b*c)**2 * (1 - ca*ca - cb*cb - cg*cg + 2*ca*cb*cg);
                    if (V2 < 1e-12) return 0;
                    const A = (b*c*sa)**2 / V2;
                    const B = (a*c*sb)**2 / V2;
                    const C = (a*b*sg)**2 / V2;
                    const D = 2 * a*b*c*c * (ca*cb - cg) / V2;
                    const E = 2 * a*b*b*c * (cg*ca - cb) / V2; 
                    const F = 2 * a*a*b*c * (cb*cg - ca) / V2; 
                    
                    // 1/d^2 = h^2(A) + k^2(B) + l^2(C) + hk(D) + hl(E) + kl(F)
                    return A*h*h + B*k*k + C*l*l + D*h*k + E*h*l + F*k*l; 
                }
            }
            
            // Triclinic (Laue Class -1)
            case "1":
            case "-1": {
                const ca = Math.cos(alpha * Math.PI / 180), cb = Math.cos(beta * Math.PI / 180), cg = Math.cos(gamma * Math.PI / 180);
                const sa = Math.sin(alpha * Math.PI / 180), sb = Math.sin(beta * Math.PI / 180), sg = Math.sin(gamma * Math.PI / 180);
                
                // Volume squared
                const V2 = (a*b*c)**2 * (1 - ca*ca - cb*cb - cg*cg + 2*ca*cb*cg);
                if (V2 < 1e-12) return 0;

                // a*^2, b*^2, c*^2
                const A = (b*c*sa)**2 / V2;
                const B = (a*c*sb)**2 / V2;
                const C = (a*b*sg)**2 / V2;
                
                // D = 2 * a* * b* * cos(gamma*)
                const D = 2 * a*b*c*c * (ca*cb - cg) / V2;
                
                // E = 2 * a* * c* * cos(beta*)
                const E = 2 * a*b*b*c * (cg*ca - cb) / V2; 
                
                // F = 2 * b* * c* * cos(alpha*)
                const F = 2 * a*a*b*c * (cb*cg - ca) / V2; 
                
                return A*h*h + B*k*k + C*l*l + D*h*k + E*h*l + F*k*l; 
            }
            default:
                console.warn(`[inv_d_sq_for] Unknown point group, returning 0: ${laueClass}`);
                return 0;
        }
    }

    // ---- enumeration ----
    for (let h = -h_max; h <= h_max; h++) {
        for (let k = -k_max; k <= k_max; k++) {
            for (let l = -l_max; l <= l_max; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                if (!isCanonical(h, k, l)) continue;
                if (!passesCentering(h, k, l)) continue;

                const inv_d_sq = inv_d_sq_for(h, k, l);
                if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue;

                const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                if (sinThetaSq <= 0 || sinThetaSq > 1) continue;

                const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                reflections.push({ tth, h, k, l, d: 1 / Math.sqrt(inv_d_sq), lambda_source: lambda });
            }
        }
    }

    return reflections.sort((a, b) => a.tth - b.tth);
}





            const satisfiesCondition = (h_in, k_in, l_in, condStr) => {
                const h = Math.round(h_in); const k = Math.round(k_in); const l = Math.round(l_in);
                if (condStr === "h+k, k+l, h+l=2n") { return ((h + k) % 2 === 0 && (k + l) % 2 === 0 && (h + l) % 2 === 0); }
                const conditions = condStr.split(',').map(s => s.trim());
                for (const condition of conditions) {
                    const match = condition.match(/([0-9]*[hkl\+\-]+)\s*=\s*(\d+)n/);
                    if (!match) { console.warn(`[satisfiesCondition] Could not parse rule part: "${condition}" in rule string "${condStr}"`); continue; }
                    const [, expr, modStr] = match; const mod = parseInt(modStr);
                    if (isNaN(mod) || mod <= 0) { console.warn(`[satisfiesCondition] Invalid modulus in rule part: "${condition}"`); continue; }
                    let value = 0;
                    const terms = expr.match(/[+-]?[0-9]*[hkl]/g) || [];
                    for (const term of terms) {
                        let sign = 1; let coeff = 1; let variable = '';
                        const coeffMatch = term.match(/^([+-]?)(\d*)([hkl])$/);
                        if (coeffMatch) {
                            sign = (coeffMatch[1] === '-') ? -1 : 1;
                            coeff = coeffMatch[2] ? parseInt(coeffMatch[2]) : 1;
                            variable = coeffMatch[3];
                            if (variable === 'h') value += sign * coeff * h;
                            else if (variable === 'k') value += sign * coeff * k;
                            else if (variable === 'l') value += sign * coeff * l;
                        } else { console.warn(`[satisfiesCondition] Could not parse term "${term}" in expression "${expr}"`); }
                    }
                    if (value % mod !== 0) { return false; }
                }
                return true;
            };

            function getReflectionZone(h_in, k_in, l_in) {
                const h = Math.round(h_in); const k = Math.round(k_in); const l = Math.round(l_in);
                // General rules for common zones, order matters for specific cases
                if (h === 0 && k === 0 && l !== 0) return '00l';
                if (h === 0 && l === 0 && k !== 0) return '0k0';
                if (k === 0 && l === 0 && h !== 0) return 'h00';
                if (h === 0 && k !== 0 && l !== 0) return '0kl';
                if (k === 0 && h !== 0 && l !== 0) return 'h0l';
                if (l === 0 && h !== 0 && k !== 0) return 'hk0';
                if (h === k && l === 0 && h !== 0) return 'hh0'; // Specific for hexagonal
                if (h === l && k === 0 && h !== 0) return 'h0h'; // Specific for tetragonal/cubic
                if (k === l && h === 0 && k !== 0) return '0kk'; // Specific for tetragonal/cubic
                if (h === k && h === l && h !== 0) return 'hhh'; // Specific for cubic
                if (h === k && l !== 0 && h !== 0) return 'hhl';
                if (h === l && k !== 0 && h !== 0) return 'hkh';
                if (k === l && h !== 0 && k !== 0) return 'hkk';
                return 'hkl'; // Most general case
            }

            function initializeChart() {
                if (hklChart) { hklChart.destroy(); hklChart = null; }
                uiElements.placeholder.classList.add('hidden');
                uiElements.chartContainer.classList.remove('hidden');
                const ctx = uiElements.chartCanvas.getContext('2d');
                hklChart = new Chart(ctx, { type: 'bar', data: { datasets: [
                    { type: 'bar', label: 'Calculated Kα1', data: [], backgroundColor: 'rgba(59, 130, 246, 0.9)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 1 },
                    { type: 'line', label: 'Experimental Data', data: [], borderColor: 'rgba(107, 114, 128, 0.7)', showLine: true, pointRadius: 0, borderWidth: 0.75, tension: 0.1, order: 3 },
                    { type: 'bar', label: 'Calculated Kα2', data: [], backgroundColor: 'rgba(96, 165, 250, 0.7)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 2 }
                    ] },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        scales: { x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' }, min: 0, max: 90 }, y: { title: { display: false }, min: 0, max: 1.1, ticks: { display: false } } },
                       
                       
						plugins: {
						    zoom: {
						        pan: {
						            enabled: true,
						            mode: 'xy'
						        },
						        zoom: {
						            wheel: {
						                enabled: true,
						                speed: 0.1,
						                modifierKey: null  // Remove ctrl requirement
						            },
						            pinch: {
						                enabled: true
						            },
						            mode: 'xy',
						            
						            onZoomComplete: function({chart}) {
						                // Re-calculate marker heights based on new scale
						                updateChartMarkers(currentHKLList_ka1, currentHKLList_ka2);
						                chart.update('none'); // Redraw with new marker heights
						            }
						        },
						        
						        pan: {
						            enabled: true,
						            mode: 'xy',
						            onPanComplete: function({chart}) {
						                // Re-calculate marker heights based on new scale
						                updateChartMarkers(currentHKLList_ka1, currentHKLList_ka2);
						                chart.update('none'); // Redraw with new marker heights
						            }
						        }
						    },


                            legend: { display: true, position: 'top' },


                            tooltip: { enabled: true, mode: 'nearest', intersect: false, callbacks: {
                                title: function(tooltipItems) { if (!tooltipItems.length) return ''; const item = tooltipItems[0]; return `2θ: ${item.parsed.x.toFixed(3)}°`; },
                                label: function(context) {
                                    const hklData = context.raw?.hkl;
                                    const source = context.datasetIndex === 0 ? "Kα1" : (context.datasetIndex === 2 ? "Kα2" : "");
                                    if (hklData) { 
                                    	// --- Show canonical HKL in tooltip
                                    	// (The generator now only passes canonical HKLs, so no change needed here)
                                    	return `(hkl): (${hklData.h}, ${hklData.k}, ${hklData.l}) ${source} d: ${hklData.d.toFixed(4)} Å`; 
                                    }
                                    if (context.datasetIndex === 1) { return `Intensity: ${context.parsed.y.toFixed(0)}`; } return null;
                                }
                            } }
                        }
                    }
                });
                console.log("Chart initialized.");

                uiElements.chartCanvas.addEventListener('contextmenu', e => {
					e.preventDefault();
					if (hklChart) {
					    hklChart.resetZoom();
					}
				});
            }

            function rescaleChartAxes() {
                if (!hklChart) return;
                const min2T = parseFloat(uiElements.min2ThetaNum.value) || 0;
                const max2T = parseFloat(uiElements.max2ThetaNum.value) || 90;
                hklChart.options.scales.x.min = min2T; hklChart.options.scales.x.max = max2T;
                const expData = hklChart.data.datasets[1].data; let finalYMax = 1.1; let finalYMin = 0; let showYTicks = false;
                if (expData && expData.length > 0) { const visibleExpData = expData.filter(pt => pt.x >= min2T && pt.x <= max2T); const intensities = visibleExpData.map(pt => pt.y); const maxY = intensities.length > 0 ? Math.max(...intensities) : 0; const minY = intensities.length > 0 ? Math.min(...intensities.filter(y => y > -Infinity)) : 0; finalYMax = Math.max(0.1, maxY) * 1.1; finalYMin = Math.min(0, minY) - finalYMax * 0.05; if (minY >= 0) { finalYMin = -finalYMax * 0.05; } showYTicks = true; } else { finalYMax = 1.1; finalYMin = 0; showYTicks = false; }
                 hklChart.options.scales.y.min = finalYMin; hklChart.options.scales.y.max = finalYMax; hklChart.options.scales.y.ticks.display = showYTicks;
                 
                 return { finalYMin, finalYMax };
            }

            function updateChartMarkers(reflections_ka1, reflections_ka2 = [], newYScale = null) {
                 if (!hklChart) { console.log("Chart not init, skip update."); return; }
                 
                 let yMin, yMax;
                 if (newYScale) {
                     // Use pending values if provided (for file load/recalculate)
                     yMin = newYScale.finalYMin;
                     yMax = newYScale.finalYMax;
                 } else {
                     // Use live scale values (for zoom/pan callbacks)
                     const yAxis = hklChart.scales.y;
                     yMin = yAxis.min;
                     yMax = yAxis.max;
                 }
                 
                 const yRange = (yMax > yMin) ? yMax - yMin : 1;
                 /*  Set marker height to 3% of Y-axis range, à voir */
                 const markerHeight = yRange * 0.03;
                 const markerTop = yMin + markerHeight;

                const markerData_ka1 = reflections_ka1.map(r => ({ x: r.tth, y: [yMin, markerTop], hkl: { h: r.h, k: r.k, l: r.l, d: r.d } }));
                const markerData_ka2 = reflections_ka2.map(r => ({ x: r.tth, y: [yMin, markerTop], hkl: { h: r.h, k: r.k, l: r.l, d: r.d } }));
                
                hklChart.data.datasets[0].data = markerData_ka1;
                hklChart.data.datasets[2].data = markerData_ka2;
            }

const calculateAndDrawHKLs = () => {
    if (!hklChart && (currentSpaceGroup || experimentalData.tth.length > 0)) {
        initializeChart();
    }

    if (!currentSpaceGroup) {
        currentHKLList_ka1 = [];
        currentHKLList_ka2 = [];
        if (hklChart) {
            updateChartMarkers([], []);
            rescaleChartAxes();
            hklChart.update('none');
        }
        uiElements.saveButton.disabled = true;
        uiElements.saveButton.textContent = "Enter Valid Space Group";
        return;
    }

    const params = getCurrentParameters();
    const min2T = parseFloat(uiElements.min2ThetaNum.value);
    const max2T = parseFloat(uiElements.max2ThetaNum.value);
    if (!params || isNaN(min2T) || isNaN(max2T)) {
        currentHKLList_ka1 = [];
        currentHKLList_ka2 = [];
        if (hklChart) {
            updateChartMarkers([], []);
            rescaleChartAxes();
            hklChart.update('none');
        }
        uiElements.saveButton.disabled = true;
        uiElements.saveButton.textContent = "Invalid Parameters";
        return;
    }

    console.log("Calculating HKLs with params:", params, "Range:", min2T, "-", max2T);

    const settingIndex = parseInt(uiElements.settingSelect.value) >= 0 ? parseInt(uiElements.settingSelect.value) : 0;
    const setting = currentSpaceGroup.settings?.[settingIndex] || currentSpaceGroup.settings?.[0] || null;
    const conditions = setting?.reflection_conditions || {};

    const laueClass = currentSpaceGroup.point_group; // e.g. "2", "m", "222", "4", "23"

    const filterHKLs = (hkl_list) => {
        return hkl_list.filter(refl => {
            if (refl.tth < min2T || refl.tth > max2T) return false;
            let isAllowed = true;
            const zone = getReflectionZone(refl.h, refl.k, refl.l);
            const zoneConditions = conditions[zone] || [];
            const generalConditions = conditions['hkl'] || [];
            const allApplicableConditions = [...zoneConditions, ...generalConditions];

            const uniqueConditions = new Set(allApplicableConditions);
            for (const condStr of uniqueConditions) {
                if (!satisfiesCondition(refl.h, refl.k, refl.l, condStr)) {
                    isAllowed = false;
                    break;
                }
            }
            return isAllowed;
        });
    };

    const allHKLs_ka1 = generateHKL_for_indexing(max2T, params, laueClass, params.lambda, setting);
    currentHKLList_ka1 = filterHKLs(allHKLs_ka1);

    currentHKLList_ka2 = [];
    if (params.lambda_ka2) {
        const allHKLs_ka2 = generateHKL_for_indexing(max2T, params, laueClass, params.lambda_ka2, setting);
        currentHKLList_ka2 = filterHKLs(allHKLs_ka2);
    }

    if (hklChart) {
        const newYScale = rescaleChartAxes();
        updateChartMarkers(currentHKLList_ka1, currentHKLList_ka2, newYScale);
        hklChart.update('none');
    }

    uiElements.saveButton.disabled = false;
    uiElements.saveButton.textContent = "Save HKL List";
};



            const debouncedCalculate = debounce(calculateAndDrawHKLs, 300);


// This version is modified to pass the *default* setting description
// to 'updateParameterInputs' when a new space group is entered.
uiElements.sgInput.addEventListener('input', () => {
    const inputText = uiElements.sgInput.value; currentSpaceGroup = findSpaceGroup(inputText); uiElements.sgInput.classList.remove('error');
    if (currentSpaceGroup) {
        if (!hklChart && experimentalData.tth.length == 0) { initializeChart(); }
        else if (!hklChart && experimentalData.tth.length > 0){ initializeChart(); const expPoints = experimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, experimentalData.intensity[i]) })); hklChart.data.datasets[1].data = expPoints; }
        
        uiElements.systemDisplay.textContent = currentSpaceGroup.crystal_system.charAt(0).toUpperCase() + currentSpaceGroup.crystal_system.slice(1);
        
        // Update dropdown FIRST, so we can read the default setting
        updateSettingsDropdown(currentSpaceGroup); 
        
        // Get default setting description (from setting 0)
        const defaultSettingDesc = currentSpaceGroup.settings?.[0]?.description || (currentSpaceGroup.crystal_system === 'monoclinic' ? 'b' : null);
        
        // Call updateParameterInputs with the default setting description
        updateParameterInputs(currentSpaceGroup.crystal_system, defaultSettingDesc); 
        
        debouncedCalculate();
    } else {
         uiElements.systemDisplay.textContent = "-"; updateParameterInputs(null); updateSettingsDropdown(null); currentHKLList_ka1 = []; currentHKLList_ka2 = [];
        if(hklChart) {
            updateChartMarkers([], []);
            rescaleChartAxes();
            if (experimentalData.tth.length === 0) { uiElements.placeholder.classList.remove('hidden'); uiElements.chartContainer.classList.add('hidden'); hklChart.destroy(); hklChart = null; }
            else { hklChart.update('none'); }
        }
        uiElements.saveButton.disabled = true; uiElements.saveButton.textContent = "Enter Valid Space Group"; if (inputText.trim() !== "") uiElements.sgInput.classList.add('error');
     }
});

uiElements.settingSelect.addEventListener('change', () => {
    if (!currentSpaceGroup) return;

    uiElements.cellA.value = "5.0";
    uiElements.cellB.value = "5.0";
    uiElements.cellC.value = "5.0";
    uiElements.cellAlpha.value = "90.0";
    uiElements.cellBeta.value = "90.0";
    uiElements.cellGamma.value = "90.0";

    // Point 1: Get new setting and update parameter constraints
    const settingIndex = parseInt(uiElements.settingSelect.value);
    if (settingIndex < 0) {
        // This case might happen if the dropdown is reset
        updateParameterInputs(currentSpaceGroup.crystal_system, null);
        debouncedCalculate();
        return;
    }
    
    // Get the description ("a", "b", "c") for the selected setting
    const setting = currentSpaceGroup.settings?.[settingIndex];
    const settingDesc = setting?.description || (currentSpaceGroup.crystal_system === 'monoclinic' ? 'b' : null);

    // Re-run updateParameterInputs with the NEW setting description
    updateParameterInputs(currentSpaceGroup.crystal_system, settingDesc);
    
    // Recalculate HKLs with new setting
    debouncedCalculate();
});

        function handleWavelengthChange() {
    const preset = uiElements.wavelengthPreset.value;
    const plotKa2 = uiElements.plotKa2Checkbox.checked;

    const bounds = { min: 0.1, max: 5.0, default: 1.54184 };

    // Remove old listeners if they exist
    if (uiElements.wavelength._styleListener) {
        uiElements.wavelength.removeEventListener('input', uiElements.wavelength._styleListener);
        uiElements.wavelength._styleListener = null;
    }
    if (uiElements.wavelength._revertListener) {
        uiElements.wavelength.removeEventListener('change', uiElements.wavelength._revertListener);
        uiElements.wavelength._revertListener = null;
    }

    if (preset === 'custom') {
        uiElements.wavelength.readOnly = false;
        uiElements.plotKa2Checkbox.checked = false;
        uiElements.plotKa2Checkbox.disabled = true;

        // 1. Add live styling listener on 'input'
        uiElements.wavelength._styleListener = () => validateInputStyle(uiElements.wavelength, bounds.min, bounds.max);
        uiElements.wavelength.addEventListener('input', uiElements.wavelength._styleListener);
        
        // 2. Add revert listener on 'change'
        uiElements.wavelength._revertListener = () => {
            validateAndRevert(uiElements.wavelength, bounds.min, bounds.max, bounds.default);
            debouncedCalculate(); // Recalculate after revert
        };
        uiElements.wavelength.addEventListener('change', uiElements.wavelength._revertListener);

        // Run initial style check
        validateInputStyle(uiElements.wavelength, bounds.min, bounds.max);

    } else {
        const presetData = WAVELENGTH_PRESETS[preset];
        uiElements.wavelength.readOnly = true;
        uiElements.plotKa2Checkbox.disabled = false;
        if (plotKa2) {
            uiElements.wavelength.value = presetData.ka1.toFixed(5);
        } else {
            uiElements.wavelength.value = presetData.ka_avg.toFixed(5);
        }
        uiElements.wavelength.classList.remove('error');
    }
    
    // We *always* call debouncedCalculate to update,
    // which will be stopped by getCurrentParameters if custom is invalid.
    debouncedCalculate();
}


             uiElements.wavelengthPreset.addEventListener('change', handleWavelengthChange);
             uiElements.plotKa2Checkbox.addEventListener('change', handleWavelengthChange);
             uiElements.wavelength.addEventListener('input', debouncedCalculate);

             uiElements.min2ThetaSlider.addEventListener('input', () => {
                let minVal = parseFloat(uiElements.min2ThetaSlider.value);
                let maxVal = parseFloat(uiElements.max2ThetaSlider.value);
                if (minVal >= maxVal) { minVal = maxVal - parseFloat(uiElements.min2ThetaSlider.step); uiElements.min2ThetaSlider.value = minVal; }
                 uiElements.min2ThetaValue.textContent = minVal.toFixed(2); // 
                 uiElements.min2ThetaNum.value = minVal;
                 debouncedCalculate();
             });
             uiElements.max2ThetaSlider.addEventListener('input', () => {
                 let minVal = parseFloat(uiElements.min2ThetaSlider.value);
                 let maxVal = parseFloat(uiElements.max2ThetaSlider.value);
                 if (maxVal <= minVal) { maxVal = minVal + parseFloat(uiElements.max2ThetaSlider.step); uiElements.max2ThetaSlider.value = maxVal; }
                 uiElements.max2ThetaValue.textContent = maxVal.toFixed(2); // toFixed(2), le 29 oct
                 uiElements.max2ThetaNum.value = maxVal;
                 debouncedCalculate();
             });

            const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel'); resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize'; const moveHandler = (moveEvent) => { if (moveEvent.clientX > 300 && moveEvent.clientX < window.innerWidth - 300) leftPanel.style.width = `${moveEvent.clientX}px`; }; const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); }; window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler); });

            const parseDataFile = (text, fileName = "") => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let last_x = -Infinity; let suspicious_steps = 0; let positive_x_values = 0; let negative_steps = 0; let headerLines = 0; let dataStarted = false; lines.forEach(line => { if (line.startsWith('#') || line.startsWith('//') || line.startsWith('!') || line.startsWith(';') || line.trim() === '') { if (!dataStarted) headerLines++; return; } if (!dataStarted) { if (/[a-zA-Z]/.test(line)) { headerLines++; return; } } const parts = line.trim().split(/[\s,;]+/); if (parts.length < 2) return; const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (isNaN(x) || isNaN(y)) { if (!dataStarted) headerLines++; return; } dataStarted = true; if (x > 0) positive_x_values++; if (last_x !== -Infinity) { const dX = x - last_x; if (dX < 0) { negative_steps++; } else if (dX > 0 && (dX < 0.0001 || dX > 0.2)) { suspicious_steps++; } } last_x = x; tth.push(x); intensity.push(y); }); if (tth.length > 10) { if (positive_x_values / tth.length < 0.5) { console.warn(`Data File (${fileName}) Warning: Most 2-theta (X) values are zero or negative.`); } if (negative_steps / tth.length > 0.8) { console.warn(`Data File (${fileName}) Warning: Data appears to be sorted in descending 2-theta order.`); } if (suspicious_steps / tth.length > 0.2) { console.warn(`Data File (${fileName}) Warning: Many data points have a step size outside the typical range (0.0001° - 0.2°).`); } } else if (tth.length === 0) { throw new Error(`Could not parse any 2-column data from ${fileName}.`); } return { tth, intensity }; };
            const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
            const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
            const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
            const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
            const parseGsasXraFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { if (lines[i].trim() === '') continue; const parts = lines[i].trim().split(/\s+/); for (let j = 0; j < parts.length; j++) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
            const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
            const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };
            const detectAndParseFile = (fileName, fileContent) => { const name = fileName.toLowerCase(); const lines = fileContent.trim().split(/\r?\n/); const firstLine = lines.length > 0 ? lines[0].trim() : ''; const upperContent = fileContent.substring(0, 500).toUpperCase(); const PARSER_REGISTRY = [ { test: (name, content) => name.endsWith('.xrdml') || (content.includes('<?xml') && content.includes('<xrdMeasurement')), parser: parseXrdmlFile }, { test: (name, content) => name.endsWith('.brml') || (content.includes('<?xml') && content.includes('<RawDataFile')), parser: parseBrukerBrmlFile }, { test: (name, content) => name.endsWith('.rasx') && content.includes('<?xml'), parser: parseBrukerBrmlFile }, { test: (name, content, firstLine) => name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION'), parser: parseUxdFile }, { test: (name, content, firstLine, upper) => name.endsWith('.ras') || upper.includes('*RAS_HEADER_START'), parser: parseRigakuRasFile }, { test: (name) => name.endsWith('.udf') || name.endsWith('.rd') || name.endsWith('.sd'), parser: parsePhilipsUdfFile }, { test: (name, content, firstLine, upper, allLines) => allLines.some(line => line.trim().toUpperCase().startsWith('BANK')), parser: (content, allLines) => { const bankLine = allLines.find(line => line.trim().toUpperCase().startsWith('BANK')); if (bankLine && bankLine.toUpperCase().includes('STD')) { return parseGsasXraFile(content); } return parseGsasEsdFile(content); } }, { test: (name, content, firstLine, upper) => name.endsWith('.mdi') && (upper.includes('2-THETA, INTENSITY') || upper.startsWith('(SAMPLE')), parser: parseDataFile } ]; for (const rule of PARSER_REGISTRY) { try { if (rule.test(name, fileContent, firstLine, upperContent, lines)) { if (rule.parser.length > 1) { return rule.parser(fileContent, lines); } return rule.parser(fileContent); } } catch (e) { console.warn(`Parser ${rule.parser.name} failed, trying next...`, e.message); } } return parseDataFile(fileContent, fileName); };

            uiElements.expFileInput.addEventListener('change', async (e) => {
                 const file = e.target.files[0];
                 if (!file) { experimentalData = { tth: [], intensity: [] }; uiElements.expFileName.textContent = "Select Data File..."; if (hklChart) { hklChart.data.datasets[1].data = []; if (currentHKLList_ka1.length === 0 && !currentSpaceGroup) { uiElements.placeholder.classList.remove('hidden'); uiElements.chartContainer.classList.add('hidden'); hklChart.destroy(); hklChart = null; } else { rescaleChartAxes(); hklChart.update('none'); } } return; }
                 uiElements.expFileName.textContent = file.name;
                 try {
                     const text = await file.text(); const parsed = detectAndParseFile(file.name, text);
                     if (!parsed || !parsed.tth || parsed.tth.length === 0) throw new Error("Could not parse data from file.");
                     
                     experimentalData = { tth: parsed.tth, intensity: parsed.intensity };
                     
                     // --- update sliders and inputs based on file range
                     if (experimentalData.tth.length > 0) {
                        let fileMin2T = Math.min(...experimentalData.tth);
                        let fileMax2T = Math.max(...experimentalData.tth);

                        // Get slider constraints
                        const minSliderMin = parseFloat(uiElements.min2ThetaSlider.min);
                        const minSliderMax = parseFloat(uiElements.min2ThetaSlider.max);
                        const maxSliderMin = parseFloat(uiElements.max2ThetaSlider.min);
                        const maxSliderMax = parseFloat(uiElements.max2ThetaSlider.max);

                        // Clamp values to be within slider limits
                        let finalMin2T = Math.max(minSliderMin, Math.min(minSliderMax, fileMin2T));
                        let finalMax2T = Math.min(maxSliderMax, Math.max(maxSliderMin, fileMax2T));

                        // Ensure min is not >= max (with a small step)
                        if (finalMin2T >= finalMax2T) {
                             // Reset min and max based on file data, clamped
                             finalMin2T = Math.max(minSliderMin, Math.min(minSliderMax, fileMin2T));
                             finalMax2T = Math.min(maxSliderMax, Math.max(maxSliderMin, fileMax2T));
                             // If still overlapping, just force a small range
                             if (finalMin2T >= finalMax2T) {
                                 finalMax2T = finalMin2T + 0.1;
                                 if(finalMax2T > maxSliderMax) {
                                     finalMin2T = maxSliderMax - 0.1;
                                     finalMax2T = maxSliderMax;
                                 }
                             }
                        }

                        // Update all min controls
                        uiElements.min2ThetaSlider.value = finalMin2T;
                        uiElements.min2ThetaValue.textContent = finalMin2T.toFixed(2);
                        uiElements.min2ThetaNum.value = finalMin2T;

                        // Update all max controls
                        uiElements.max2ThetaSlider.value = finalMax2T;
                        uiElements.max2ThetaValue.textContent = finalMax2T.toFixed(2);
                        uiElements.max2ThetaNum.value = finalMax2T;
                    }
                    

                     if (!hklChart) { initializeChart(); }
                     const expPoints = experimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, experimentalData.intensity[i]) }));
                     hklChart.data.datasets[1].data = expPoints;
                     
                     const newYScale = rescaleChartAxes(); // Get new scale
                     updateChartMarkers(currentHKLList_ka1, currentHKLList_ka2, newYScale); // Pass new scale
                     
                     hklChart.update('none');
                 } catch (error) { console.error("Error loading experimental data:", error); alert(`Error loading file: ${error.message}`); experimentalData = { tth: [], intensity: [] }; uiElements.expFileName.textContent = "Error loading file!"; if (hklChart) { hklChart.data.datasets[1].data = []; if (currentHKLList_ka1.length === 0 && !currentSpaceGroup) { uiElements.placeholder.classList.remove('hidden'); uiElements.chartContainer.classList.add('hidden'); hklChart.destroy(); hklChart = null; } else { rescaleChartAxes(); hklChart.update('none'); } }
                 } finally { e.target.value = null; }
             });

             function saveHKLFile() {
                 const hklLists = [
                     { list: currentHKLList_ka1, source: uiElements.plotKa2Checkbox.checked && uiElements.wavelengthPreset.value !== 'custom' ? "K-alpha1" : "Avg/Custom" },
                     { list: currentHKLList_ka2, source: "K-alpha2" }
                 ];
                 if (hklLists[0].list.length === 0 && hklLists[1].list.length === 0) {
                     alert("No calculated HKLs to save.");
                     return;
                 }

                //  Add URL and Footer to saved file ---
                const footerText = "IndexMan, version 29 oct 2025";
                let fileContent = `# URL: ${window.location.href}\n`;
                fileContent += `# ${footerText}\n`;
                fileContent += `# =============================================\n`;
                fileContent += `# HKL Simulation Results\n`;

                const settingIndex = parseInt(uiElements.settingSelect.value) >= 0 ? parseInt(uiElements.settingSelect.value) : 0;
                const setting = currentSpaceGroup?.settings[settingIndex] || currentSpaceGroup?.settings[0];
                const sgSymbol = setting?.symbol || currentSpaceGroup?.standard_symbol || 'N/A';
                const settingDesc = setting?.description ? ` (${setting.description})` : '';

                fileContent += `# Space Group: ${sgSymbol}${settingDesc}\n`;

                 let conditionsString = "# Reflection Conditions: ";
                 const conditions = setting?.reflection_conditions;
                 if (conditions && Object.keys(conditions).length > 0) {
                     const parts = [];
                     for (const zone in conditions) {
                         if (conditions[zone] && conditions[zone].length > 0) {
                             parts.push(`${zone}: ${conditions[zone].join(', ')}`);
                         }
                     }
                     conditionsString += parts.join('; ') || "None for this setting";
                 } else {
                     conditionsString += "None (P1 or check setting)";
                 }
                 fileContent += conditionsString + "\n";

                const params = getCurrentParameters();
                if(params) {
                    fileContent += `# Parameters: a=${params.a.toFixed(5)} b=${params.b.toFixed(5)} c=${params.c.toFixed(5)} alpha=${params.alpha.toFixed(3)} beta=${params.beta.toFixed(3)} gamma=${params.gamma.toFixed(3)}\n`;
                    if(params.lambda_ka2) {
                        fileContent += `# Wavelength K-alpha1 (A): ${params.lambda.toFixed(5)}\n`;
                        fileContent += `# Wavelength K-alpha2 (A): ${params.lambda_ka2.toFixed(5)}\n`;
                    } else {
                        fileContent += `# Wavelength (A): ${params.lambda.toFixed(5)}\n`;
                    }
                }
                fileContent += `# Range (2theta): ${uiElements.min2ThetaNum.value} - ${uiElements.max2ThetaNum.value}\n`;
                fileContent += `# Columns: h k l d_spacing(A) 2theta(deg) Source\n`;

                
                const combinedList = [];
                
                // 1. Add source property to each reflection and create a combined list
                const ka1_source = uiElements.plotKa2Checkbox.checked && uiElements.wavelengthPreset.value !== 'custom' ? "K-alpha1" : "Avg/Custom";
                currentHKLList_ka1.forEach(hkl => {
                    combinedList.push({ ...hkl, source: ka1_source });
                });
                
                if (currentHKLList_ka2.length > 0) {
                    const ka2_source = "K-alpha2";
                    currentHKLList_ka2.forEach(hkl => {
                        combinedList.push({ ...hkl, source: ka2_source });
                    });
                }

                // 2. Sort the combined list by 2-theta (tth)
                combinedList.sort((a, b) => a.tth - b.tth);

                // 3. Iterate through the sorted list and build the file content
                combinedList.forEach(hkl => {
                    const hStr = String(hkl.h).padStart(4);
                    const kStr = String(hkl.k).padStart(4);
                    const lStr = String(hkl.l).padStart(4);
                    fileContent += `${hStr} ${kStr} ${lStr} ${hkl.d.toFixed(5).padStart(12)} ${hkl.tth.toFixed(4).padStart(12)} ${hkl.source}\n`;
                });
                
    

                /* // OLD CODE , replaced on 29 oct
                hklLists.forEach(({ list, source }) => {
                    if (list.length > 0) {
                        list.forEach(hkl => {
                            const hStr = String(hkl.h).padStart(4);
                            const kStr = String(hkl.k).padStart(4);
                            const lStr = String(hkl.l).padStart(4);
                            fileContent += `${hStr} ${kStr} ${lStr} ${hkl.d.toFixed(5).padStart(12)} ${hkl.tth.toFixed(4).padStart(12)} ${source}\n`;
                        });
                    }
                });
                */

                const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                const sgName = sgSymbol.replace(/[^a-zA-Z0-9]/g, '') || 'hkl'; // Use actual setting symbol
                link.setAttribute("download", `${sgName}_simulation.txt`);
                link.style.visibility = 'hidden'; document.body.appendChild(link);
                link.click();
                document.body.removeChild(link); URL.revokeObjectURL(url);
            }
            // Ensure the listener is still attached
            uiElements.saveButton.addEventListener('click', saveHKLFile);
            

            // --- Initialize ---
           
			Chart.register(window.ChartZoom || window['chartjs-plugin-zoom']);


            loadSpaceGroupData();
             // Set initial slider text and hidden input values
             uiElements.min2ThetaNum.value = uiElements.min2ThetaSlider.value;
             uiElements.max2ThetaNum.value = uiElements.max2ThetaSlider.value;
          
             uiElements.min2ThetaValue.textContent = parseFloat(uiElements.min2ThetaSlider.value).toFixed(2);
             uiElements.max2ThetaValue.textContent = parseFloat(uiElements.max2ThetaSlider.value).toFixed(2);
             // Trigger initial wavelength setup
             handleWavelengthChange();
             
           
             const tooltipIcon = document.getElementById('tooltip-icon');
             const tooltipText = document.getElementById('tooltip-text');
             
             if (tooltipIcon && tooltipText) {
                tooltipIcon.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevents the document click from firing
                    tooltipText.classList.toggle('visible');
                });

                document.addEventListener('click', (e) => {
                    if (tooltipText.classList.contains('visible') && 
                        !tooltipIcon.contains(e.target) && 
                        !tooltipText.contains(e.target)) 
                    {
                        tooltipText.classList.remove('visible');
                    }
                });
             }
             
        });
    </script>

</body>
</html>


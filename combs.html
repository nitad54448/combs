<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combs-Powder Indexing</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #1a73e8;
            --primary-accent-hover: #1765cc;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
            --led-gray: #6b7280;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        
        #controls-panel { 
            width: 400px; min-width: 300px; max-width: 700px; flex-shrink: 0; 
            padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); 
            overflow-y: visible; color: var(--text-medium); display: flex; flex-direction: column;
            position: relative;
            z-index: 20;
        }
        
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        
        #results-area { 
            flex-grow: 1; position: relative; background-color: #ffffff; 
            min-width: 0; display: flex; flex-direction: column; 
            padding: 1.5rem; color: var(--medium-bg);
            z-index: 10;
        }

        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.35rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
 
        .btn-like {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }

        .btn {
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }

        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--light-bg); color: var(--text-light); border-color: var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: #4a5568; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }

        .file-input-label {
            background-color: var(--border-color);
            color: var(--text-medium);
        }
        .file-input-label:hover { background-color: #6b7280; }
        .file-input-label.error { border: 1px solid var(--error-red); color: var(--error-red); }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}

        input[type="checkbox"] {
            accent-color: var(--primary-accent);
            transform: scale(1.1);
            vertical-align: middle; 
        }
        .hidden { display: none !important; }

        /* Tab Styles */
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
        .tab-btn { flex: 1; padding: 0.75rem 0.5rem; background: none; border: none; color: var(--text-dark); font-weight: 600; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .tab-btn:hover { color: var(--text-light); }
        .tab-btn.active { color: var(--primary-accent); border-bottom-color: var(--primary-accent); }
        .tab-content-panels { flex-grow: 1; min-height: 0; position: relative; }
        .tab-content-panel { display: none; flex-direction: column; height: 100%; overflow-y: auto; padding-right: 8px; margin-right: -8px;}
        .tab-content-panel.active { display: flex; }
        .tab-content-panel::-webkit-scrollbar { width: 6px; }
        .tab-content-panel::-webkit-scrollbar-track { background: var(--dark-bg); }
        .tab-content-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        .tab-content-panel::-webkit-scrollbar-thumb:hover { background: var(--light-bg); }
        #solutions-tab-content .control-group { flex-grow: 1; display: flex; flex-direction: column; margin-bottom: 0;}
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); }

        /* --- LED Indicator Styles --- */
        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        .led-indicator.gray { background-color: var(--led-gray); }
        .led-indicator.green { background-color: var(--success-green); box-shadow: 0 0 5px var(--success-green);}
        .led-indicator.red { background-color: var(--error-red); box-shadow: 0 0 5px var(--error-red); }

        #peak-table-container {
            overflow-y: auto;
            background-color: var(--medium-bg);
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            margin-top: 1rem;
        }
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; position: sticky; top: 0; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .peak-table th, .peak-table td, .peak-table input { text-align: center; }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }

        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle;}
        .solutions-table th { background-color: #2a3547; font-weight: 600; position: sticky; top: 0;}
        .solutions-table th[data-sort] { cursor: pointer; } 
        .solutions-table th[data-sort]:hover { background-color: var(--light-bg); }
        .solutions-table th.sort-asc::after,
        .solutions-table th.sort-desc::after {
            content: ''; display: inline-block; margin-left: 5px; width: 0; height: 0;
            border-left: 4px solid transparent; border-right: 4px solid transparent;
        }
        .solutions-table th.sort-asc::after { border-bottom: 4px solid var(--text-light); }
        .solutions-table th.sort-desc::after { border-top: 4px solid var(--text-light); }
        .solutions-table td:nth-child(4), .solutions-table td:nth-child(5) { text-align: right; } /* Align Vol and M20 right */

        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        .bottom-actions { margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--light-bg); }

        #status-box {
            position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; border-radius: 6px;
            color: white; font-size: 0.8rem; font-weight: 500; z-index: 1000;
            opacity: 0; visibility: hidden; transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show { opacity: 1; visibility: visible; transform: translateY(0); }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

        /* --- Help Tooltip Styles --- */
        .help-tooltip-container { position: relative; display: inline-block; }
        .help-icon {
            display: flex; align-items: center; justify-content: center; width: 28px; height: 28px;
            background-color: var(--border-color); color: var(--text-light); border-radius: 50%;
            font-weight: bold; font-size: 1rem; cursor: help; transition: background-color: 0.2s;
        }
        .help-icon:hover { background-color: #6b7280; }


        .tooltip-content {
    visibility: hidden;
    opacity: 0;
    width: 400px;
    background-color: var(--light-bg);
    color: var(--text-medium);
    text-align: left;
    border-radius: 0.375rem;
    padding: 1rem;
    position: absolute;
    z-index: 1001;
    top: -15px;
    left: 115%;
    margin-left: 10px;
    /* This transition applies when hiding the tooltip */
    transition: opacity 0.3s;
    /* Wait 1 second after the mouse leaves before starting to hide */
    transition-delay: 2s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.help-tooltip-container:hover .tooltip-content {
     visibility: visible;
     opacity: 1;
     transition-delay: 0s;
}

.help-tooltip-container::after {
    content: '';
    position: absolute;
    /* This creates a transparent element over the gap */
    left: 100%;
    width: 10px; 
    /* This makes it cover the full height of the icon */
    top: 0;
    bottom: 0;
}


        .tooltip-content::after {
            content: ""; position: absolute;
            top: 20px; 
            right: 100%;
            margin-top: -5px; 
            border-width: 5px; border-style: solid;
            border-color: transparent var(--light-bg) transparent transparent;
        }
        
        .tooltip-content h4 { color: var(--text-light); font-size: 0.9rem; margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; }
        .tooltip-content p { margin-top: 0; margin-bottom: 0.75rem; line-height: 1.4; }
        .tooltip-content p:last-child { margin-bottom: 0; }
        .tooltip-content hr { border: none; border-top: 1px solid var(--border-color); margin: 0.75rem 0; }

        #app-footer {
    position: fixed;   /* Keeps it on the screen even if you scroll */
    bottom: 8px;      
    right: 15px;      
    font-size: 0.75rem; 
    color: var(--text-dark); 
    z-index: 1001;     
}

        /* --- Compact Slider Styles --- */
        .slider-group {
            display: grid;
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 12px;
            align-items: center;
            margin-bottom: 1rem;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-group > .control-label {
            margin-bottom: 0;
            font-size: 0.875rem;
            white-space: nowrap;
        }
        .slider-value-track {
            grid-column: 2;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
        }
        .slider-value-track > * {
            grid-column: 1;
            grid-row: 1;
        }
        .slider-value-display {
            text-align: center;
            color: var(--text-dark);
            font-weight: 500;
            font-size: 0.8rem;
            pointer-events: none;
        }
        input[type="range"].custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px;
            background: var(--medium-bg);
            border-radius: 6px;
            outline: none;
            padding: 0;
            margin: 0;
        }
        input[type="range"].custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider:disabled {
            background: var(--light-bg);
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb {
            background: var(--border-color);
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb {
            background: var(--border-color);
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">

            <div class="control-group">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <label for="file-input" class="file-input-label btn-like" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon" aria-label="Help and usage information">?</span>


 


                        <div class="tooltip-content">
    <h4>Combs - Powder XRD Indexing</h4>
    <p>This program uses a system-specific, exhaustive search to find potential unit cells based on the first 20 peaks.</p>
    <ul>
        <li style="margin-bottom: 5px;"><b>Cubic:</b> Tests single peaks.</li>
        <li style="margin-bottom: 5px;"><b>Tetra/Hexa:</b> Solves using peak pairs.</li>
        <li style="margin-bottom: 5px;"><b>Ortho:</b> Solves using peak triplets.</li>
        <li style="margin-bottom: 5px;"><b>Monoclinic:</b> Solves using peak quadruplets.</li>
    </ul>
    <p>All trial cells are refined, scored (M(20)), and analyzed for space groups. For a full breakdown, <a href="combs_help.html" target="_blank" style="color: #6495ED;">read the technical guide.</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2&theta; intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the plot, X-axis, or Y-axis. Right-click to reset zoom.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Add Peak:</b> Hold <b>Ctrl</b> and click on the chart to manually add a peak at that position.</p>
</div>

                    </div>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf,.xra,.gsa">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="peaks">Peaks</button>
                <button class="tab-btn" data-tab="parameters">Parameters</button>
                <button class="tab-btn" data-tab="solutions">
                    Solutions
                    <span id="solutions-led" class="led-indicator gray" aria-label="Solutions status indicator"></span>
                </button>
            </div>

            <div class="tab-content-panels">
                <div id="peaks-tab-content" class="tab-content-panel active">
                     <div class="control-group" style="width: 100%; flex-grow: 1; display: flex; flex-direction: column;">
                        <div id="peak-controls" class="hidden" style="display: flex; flex-direction: column; flex-grow: 1;">
                            
                            <div class="slider-group">
                                <label class="control-label">Min peak (%)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="peak-threshold-slider" class="custom-slider" min="0" max="100" value="56">
                                    <span id="peak-threshold-value" class="slider-value-display">2.0</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Radius (pts)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="200" value="40" step="1">
                                    <span id="ball-radius-value" class="slider-value-display">40</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Points</label>
                                <div class="slider-value-track">
                                    <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="100" value="10" step="1">
                                    <span id="smoothing-width-value" class="slider-value-display">10</span>
                                </div>
                            </div>

                            <div style="border-top: 1px solid var(--border-color); margin: 1.5rem 0;"></div>

                            <div class="slider-group">
                                <label class="control-label">2θ Min</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                                    <span id="tth-min-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            <div class="slider-group">
                                <label class="control-label">2θ Max</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                                    <span id="tth-max-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            
                            <div id="peak-table-container" class="hidden" style="flex-grow: 1; min-height: 0;">
                                <table class="peak-table">
                                    <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                                    <tbody id="peak-list-body"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="parameters-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                        <div id="indexing-controls" class="hidden">
                            <div class="parameter-grid">
                                <div>
                                    <label for="wavelength" class="control-label">Wavelength (Å)</label>
                                    <input type="number" id="wavelength" value="1.54178" step="0.00001" min="0.1" class="control-input">
                                </div>
                                <div>
                                    <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                                    <input type="number" id="max-volume" value="1000" step="100" min="60" max="12000" class="control-input">
                                </div>
                            </div>
                            <div class="parameter-grid" style="margin-top: 1rem;">
                                <div>
                                    <label for="tth-error" class="control-label">2θ Error (°)</label>
                                    <input type="number" id="tth-error" value="0.05" step="0.005" min="0.001" class="control-input">
                                </div>
                                <div>
                                    <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                                    <input type="number" id="impurity-peaks" value="0" min="0" max="5" step="1" class="control-input">
                                </div>
                            </div>
                            
                            <div style="margin-top: 1.5rem;">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="refine-zero-checkbox"checked> Refine Zero-Point Error
                                </label>
                            </div>

                            <label class="control-label" style="margin-top: 1.5rem; margin-bottom: 1rem;">Crystal Systems to Search:</label>
                            <div class="parameter-grid">
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > Orthorhombic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > Monoclinic</label>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="solutions-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                         <div id="solutions-table-container">
                            <table class="solutions-table">
                                <thead><tr>
                                    <th data-sort="system">Sys.</th>
                                    <th>Parameters (Å)</th>
                                    <th>Angles (°)</th>
                                    <th data-sort="volume">Vol</th>
                                    <th data-sort="m20">M(20)</th>
                                </tr></thead>
                                <tbody id="solutions-table-body"></tbody>
                            </table>
                         </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <p id="status-text" style="text-align: center; font-size: 0.8rem; color: var(--text-dark); margin: 0 0 0.5rem 0; height: 1.2em;"></p>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary btn-like" style="flex: 1;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary btn-like" style="flex: 1;" disabled>Generate PDF Report</button>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>

        </div>
    </div>

    <div id="status-box"></div>

    <script>

document.addEventListener('DOMContentLoaded', () => {

    const ui = {
        fileInput: document.getElementById('file-input'),
        fileInputLabel: document.querySelector('.file-input-label'),
        fileName: document.getElementById('file-name'),
        peakControls: document.getElementById('peak-controls'),
        peakThresholdSlider: document.getElementById('peak-threshold-slider'),
        peakThresholdValue: document.getElementById('peak-threshold-value'),
        peakTableContainer: document.getElementById('peak-table-container'),
        peakListBody: document.getElementById('peak-list-body'),
        indexingControls: document.getElementById('indexing-controls'),
        wavelength: document.getElementById('wavelength'),
        tthError: document.getElementById('tth-error'),
        maxVolume: document.getElementById('max-volume'),
        impurityPeaksInput: document.getElementById('impurity-peaks'),
        refineZeroCheckbox: document.getElementById('refine-zero-checkbox'),
        systemCheckboxes: document.querySelectorAll('.system-checkbox'),
        startIndexingButton: document.getElementById('start-indexing-button'),
        reportButton: document.getElementById('report-button'),
        progressBar: document.getElementById('progress-bar'),
        progressBarContainer: document.getElementById('progress-bar-container'),
        solutionsTableBody: document.getElementById('solutions-table-body'),
        solutionsTableHeaders: document.querySelectorAll('#solutions-table-container th'),
        solutionsLed: document.getElementById('solutions-led'),
        chartCanvas: document.getElementById('xrd-chart'),
        placeholder: document.getElementById('placeholder'),
        resultsContainer: document.getElementById('results-container'),
        tthMinSlider: document.getElementById('tth-min-slider'),
        tthMaxSlider: document.getElementById('tth-max-slider'),
        tthMinValue: document.getElementById('tth-min-value'),
        tthMaxValue: document.getElementById('tth-max-value'),
        ballRadiusSlider: document.getElementById('ball-radius-slider'),
        ballRadiusValue: document.getElementById('ball-radius-value'),
        smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
        smoothingWidthValue: document.getElementById('smoothing-width-value'),
        statusBar: document.getElementById('status-box'),
        tabButtonsContainer: document.querySelector('.tab-buttons'),
        tabButtons: document.querySelectorAll('.tab-btn'),
        tabPanels: document.querySelectorAll('.tab-content-panel')
    };
    
    // Global variable for space group data ---
    let spaceGroupData = null;

    // Function to load space group JSON data ---
   // Function to load space group JSON data ---
    async function loadSpaceGroupData() {
        try {
            const response = await fetch('space_groups_all_settings.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            spaceGroupData = await response.json();
            console.log("Space group data (all settings) loaded successfully.");
        } catch (error) {
            console.error("Could not load space group data:", error);
            showStatus("Warning: Could not load space_groups_all_settings.json. Space group analysis will be disabled.", "error", 8000);
        }
    }
    
    // --Load data on startup, add message to console, see file event 
    loadSpaceGroupData();

    
    ui.solutionsTableHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const column = header.dataset.sort;
            if (!column) return;

            if (sortState.column === column) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.column = column;
                sortState.direction = (column === 'm20' || column === 'volume') ? 'desc' : 'asc';
            }

            sortSolutions();
            const selectedSystems = Array.from(ui.systemCheckboxes)
                                         .filter(cb => cb.checked)
                                         .map(cb => cb.value);
            displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
            updateSolutionsTable();
        });
    });

    ui.systemCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            const selectedSystems = Array.from(ui.systemCheckboxes)
                                         .filter(cb => cb.checked)
                                         .map(cb => cb.value);
            displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
            updateSolutionsTable();
        });
    });

    // --- LOGARITHMIC SLIDER CONFIGURATION ---
    const minPeak = 0.1;
    const maxPeak = 20;
    const minLog = Math.log(minPeak);
    const maxLog = Math.log(maxPeak);
    const scale = (maxLog - minLog) / 100;

    function valueToLogSlider(value) {
        if (value <= 0) return 0;
        return (Math.log(value) - minLog) / scale;
    }

    function logSliderToValue(position) {
        return Math.exp(minLog + scale * position);
    }

    // --- DEBOUNCE 
    const debounce = (func, delay) => {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    };
    const debouncedFindPeaks = debounce(findPeaks, 250);

    // --- INITIALIZE LOG SLIDER ---
    const initialPeakThreshold = 2.0;
    ui.peakThresholdSlider.value = valueToLogSlider(initialPeakThreshold);
    ui.peakThresholdValue.textContent = initialPeakThreshold.toFixed(1);

    // --- TAB SWITCHING --
    ui.tabButtonsContainer.addEventListener('click', (e) => {
        const clickedTab = e.target.closest('.tab-btn');
        if (!clickedTab || clickedTab.disabled) return;
        const tabTarget = clickedTab.dataset.tab;
        ui.tabButtons.forEach(btn => btn.classList.remove('active'));
        ui.tabPanels.forEach(panel => panel.classList.remove('active'));
        clickedTab.classList.add('active');
        document.getElementById(`${tabTarget}-tab-content`).classList.add('active');
    });

    let statusTimeout;
    const showStatus = (message, type = 'info', duration = 4000) => {
        if (!ui.statusBar) {
            console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
            return;
        }
        if (statusTimeout) clearTimeout(statusTimeout);
        ui.statusBar.textContent = message;
        ui.statusBar.className = `show ${type}`;
        statusTimeout = setTimeout(() => {
            if (ui.statusBar) {
                ui.statusBar.classList.remove('show');
            }
        }, duration);
    };

    let fullExperimentalData = { tth: [], intensity: [] };
    let pickedPeaks = [];
    let solutions = [];
    let displayedSolutions = [];
    let selectedSolution = null;
    let currentHklList = [];
    let xrdChart;
    let isIndexing = false;
    let activeWorkers = [];
    let sortState = { column: 'm20', direction: 'desc' };
    let workerURL = null;

    const setupWorker = () => {
        try {
            const workerScript = document.getElementById('indexing-worker').textContent;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            workerURL = URL.createObjectURL(blob);
        } catch (error) {
            console.error("Failed to create worker blob URL:", error);
            showStatus("Critical error: Could not initialize indexing engine.", "error", 10000);
        }
    };
    setupWorker();

    // --- SYSTEMATIC ABSENCE ANALYSIS HELPERS -
    const max_hkl_analysis = 10;


    function generateHKL_for_analysis(params, lambda, maxTth) {
    const { a, b: b_in, c: c_in, beta: beta_in, system } = params;
    const b = b_in ?? a;
    const c = c_in ?? a;
    const beta = beta_in ?? 90;
    const reflections = [];

    const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
    const q_max_limit = (1 / (d_min * d_min)) * 1.05;
    const h_max = Math.ceil(a / d_min) + 1;
    const k_max = Math.ceil(b / d_min) + 1;
    const l_max = Math.ceil(c / d_min) + 1;

    const processReflection = (h, k, l, inv_d_sq) => {
        if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) return;
        const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
        if (sinThetaSq <= 1) {
            const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
            reflections.push({ tth, h, k, l, d: 1 / Math.sqrt(inv_d_sq) });
        }
    };

    switch (system) {
        case 'cubic':
            for (let h = 0; h <= h_max; h++) {
                for (let k = 0; k <= h; k++) {
                    for (let l = 0; l <= k; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        const inv_d_sq = (h * h + k * k + l * l) / (a * a);
                        processReflection(h, k, l, inv_d_sq);
                    }
                }
            }
            break;

        case 'tetragonal':
        case 'hexagonal':
            for (let h = 0; h <= h_max; h++) {
                for (let k = 0; k <= h; k++) {
                    for (let l = 0; l <= l_max; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        let inv_d_sq = 0;
                        if (system === 'tetragonal') {
                            inv_d_sq = (h * h + k * k) / (a * a) + (l * l) / (c * c);
                        } else { // hexagonal
                            inv_d_sq = (4 / 3) * (h * h + h * k + k * k) / (a * a) + (l * l) / (c * c);
                        }
                        processReflection(h, k, l, inv_d_sq);
                    }
                }
            }
            break;

        case 'orthorhombic':
            for (let h = 0; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) {
                    for (let l = 0; l <= l_max; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        const inv_d_sq = (h * h) / (a * a) + (k * k) / (b * b) + (l * l) / (c * c);
                        processReflection(h, k, l, inv_d_sq);
                    }
                }
            }
            break;

        case 'monoclinic':
            const sinBeta = Math.sin(beta * Math.PI / 180);
            const cosBeta = Math.cos(beta * Math.PI / 180);
            const sinBetaSq = sinBeta * sinBeta;
            if (sinBetaSq < 1e-6) return []; // Invalid cell

            for (let h = -h_max; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) { // k >= 0 is sufficient
                    for (let l = -l_max; l <= l_max; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        // Enforce uniqueness convention for monoclinic
                        if (k === 0) {
                            if (h < 0) continue;
                            if (h === 0 && l <= 0) continue;
                        }
                        const inv_d_sq = (1 / sinBetaSq) * (h * h / (a * a) + l * l / (c * c) - 2 * h * l * cosBeta / (a * c)) + k * k / (b * b);
                        processReflection(h, k, l, inv_d_sq);
                    }
                }
            }
            break;
    }

    // Sort and remove duplicates as a final safety measure
    const uniqueReflections = [];
    const tolerance = 1e-4; // 2-theta tolerance for uniqueness
    if (reflections.length > 0) {
        reflections.sort((a, b) => a.tth - b.tth);
        uniqueReflections.push(reflections[0]);
        for (let i = 1; i < reflections.length; i++) {
            if (Math.abs(reflections[i].tth - uniqueReflections[uniqueReflections.length - 1].tth) > tolerance) {
                uniqueReflections.push(reflections[i]);
            }
        }
    }
    return uniqueReflections;
}



/**
 * Analyzes observed diffraction peaks to determine compatible space groups.
 * Uses an INCLUSIVE approach: only flags violations when forbidden reflections are OBSERVED.
 * * @param {object} solution - Crystal solution with unit cell parameters and system
 * @param {Array<object>} obs_peaks - **Already-filtered** observed peaks
 * @param {object} spaceGroupData - Parsed reflection_conditions.json
 * @param {string} wavelength - Radiation wavelength (e.g., 'CuKa')
 * @param {number} tthError - Tolerance for matching 2-theta values
 * @param {number} tthMax - The max 2-theta value from the UI slider
 * @returns {object} {centering, rankedSpaceGroups, detectedExtinctions}
 */
function analyzeSystematicAbsences(solution, obs_peaks, spaceGroupData, wavelength, tthError, tthMax) {
    const MAX_VIOLATIONS = 2; // Allow a few violations for experimental error
    
    const fallbackResult = {
        centering: 'Unknown',
        rankedSpaceGroups: [],
        detectedExtinctions: [],
        ambiguousHkls: new Set() // Add default empty set
    };

    if (!spaceGroupData?.space_groups) {
        console.warn("Space group data not loaded");
        return fallbackResult;
    }

    // This now calls the CORRECTED hkl generation function
    const all_calc_hkls = generateHKL_for_analysis(
        solution, 
        wavelength, 
        tthMax
    );
    
    if (all_calc_hkls.length === 0) return fallbackResult;

    const indexed_hkls = [];
    const zero_correction = solution.zero_correction || 0;

    obs_peaks.forEach(peak => {
        const corrected_tth = peak.tth - zero_correction;
        const bestMatch = all_calc_hkls.reduce((best, hkl) => {
            const diff = Math.abs(hkl.tth - corrected_tth);
            return diff < best.minDiff ? { hkl, minDiff: diff } : best;
        }, { hkl: null, minDiff: Infinity });

        if (bestMatch.hkl && bestMatch.minDiff < (tthError * 1.5)) {
            indexed_hkls.push({ 
                h: bestMatch.hkl.h, 
                k: bestMatch.hkl.k, 
                l: bestMatch.hkl.l,
                tth: peak.tth,
                calc_tth: bestMatch.hkl.tth 
            });
        }
    });

    const unique_indexed_hkls = Array.from(
        new Map(indexed_hkls.map(r => [`${r.h},${r.k},${r.l}`, r])).values()
    );

    // This filter will now work correctly because all_calc_hkls is a unique list
    const unambiguous_hkls = unique_indexed_hkls.filter(refl => {
        const nearbyCount = all_calc_hkls.filter(calc => {
            if (calc.h === refl.h && calc.k === refl.k && calc.l === refl.l) return false;
            return Math.abs(calc.tth - refl.calc_tth) < tthError;
        }).length;
        return nearbyCount === 0; 
    });

    const hkls_for_analysis = unambiguous_hkls.length > 0 ? unambiguous_hkls : unique_indexed_hkls;
    
    if (hkls_for_analysis.length < 5) {
        fallbackResult.centering = 'Unknown (too few unambiguous peaks in range)';
        return fallbackResult;
    }

    const unambiguousSet = new Set(unambiguous_hkls.map(r => `${r.h},${r.k},${r.l}`));
    const ambiguousHkls = new Set(
        unique_indexed_hkls
            .filter(r => !unambiguousSet.has(`${r.h},${r.k},${r.l}`))
            .map(r => `${r.h},${r.k},${r.l}`)
    );

    const centeringResult = determineCentering(hkls_for_analysis, solution.system);
    const detectedExtinctions = detectExtinctions(hkls_for_analysis);
    const rankedSpaceGroups = rankSpaceGroups(
        hkls_for_analysis,
        solution.system,
        centeringResult.plausibleCenterings,
        spaceGroupData,
        MAX_VIOLATIONS
    );

    return {
        centering: centeringResult.description,
        rankedSpaceGroups: rankedSpaceGroups.slice(0, 20),
        detectedExtinctions: detectedExtinctions,
        centeringViolations: centeringResult.violations,
        ambiguousHkls: ambiguousHkls
    };
}






/**
 * Determines the most likely lattice centering based on observed reflections.
 * (This function is a helper for analyzeSystematicAbsences)
 */
function determineCentering(indexed_hkls, system) {
    const centeringTests = {
        'P': { 
            name: 'Primitive (P)', 
            forbidden: (h, k, l) => false // No restrictions
        },
        'I': { 
            name: 'Body-centered (I)', 
            forbidden: (h, k, l) => (h + k + l) % 2 !== 0 
        },
        'F': { 
            name: 'Face-centered (F)', 
            forbidden: (h, k, l) => {
                // All must be even or all must be odd
                const allEven = h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
                const allOdd = h % 2 !== 0 && k % 2 !== 0 && l % 2 !== 0;
                return !(allEven || allOdd);
            }
        },
        'A': { 
            name: 'A-centered (A)', 
            forbidden: (h, k, l) => (k + l) % 2 !== 0 
        },
        'B': { 
            name: 'B-centered (B)', 
            forbidden: (h, k, l) => (h + l) % 2 !== 0 
        },
        'C': { 
            name: 'C-centered (C)', 
            forbidden: (h, k, l) => (h + k) % 2 !== 0 
        }
    };

    // Add rhombohedral for hexagonal/trigonal systems
    if (system === 'hexagonal' || system === 'trigonal') {
        centeringTests['R'] = {
            name: 'Rhombohedral (R, obverse)',
            forbidden: (h, k, l) => (-h + k + l) % 3 !== 0
        };
    }

    // Count violations: observed reflections that should be absent
    const violations = {};
    for (const [key, test] of Object.entries(centeringTests)) {
        // This is the logic that was failing (because indexed_hkls was bad)
        // It will now work correctly.
        violations[key] = indexed_hkls.filter(({h, k, l}) => 
            test.forbidden(h, k, l)
        ).length;
    }

    // Find centering(s) with minimum violations
    const minViolations = Math.min(...Object.values(violations));
    const plausible = Object.keys(violations).filter(key => 
        violations[key] === minViolations
    );

    // Prioritize special centerings over primitive
    let finalCenterings;
    if (plausible.includes('F')) {
        finalCenterings = ['F'];
    } else if (plausible.includes('I')) {
        finalCenterings = ['I'];
    } else if (plausible.includes('R')) {
        finalCenterings = ['R'];
    } else {
        const specialCenterings = plausible.filter(c => 
            ['A', 'B', 'C'].includes(c)
        );
        // This is the logic that handles your P/C case:
        // If 'plausible' is ['P', 'C'], specialCenterings will be ['C'],
        // and finalCenterings will be ['C'].
        // *** EDIT ***: This should be finalCenterings = specialCenterings.length > 0 ? [...specialCenterings, 'P'] : ['P'];
        // No, the original logic is: if C is plausible, C is preferred.
        // Let's modify this to include P if it's also plausible.
        
        // --- *** FIX *** ---
        // If special centerings are found, add 'P' to the list
        // if it also had zero violations.
        finalCenterings = specialCenterings.length > 0 ? specialCenterings : ['P'];
        if (plausible.includes('P') && !finalCenterings.includes('P')) {
             finalCenterings.push('P');
        }
        // This now means finalCenterings can be, e.g., ['C', 'P']
        // --- *** END FIX *** ---
    }

    return {
        plausibleCenterings: finalCenterings, // This is now a list, e.g., ['P'] or ['C', 'P']
        description: finalCenterings.map(c => centeringTests[c].name).join(' or '),
        violations: violations,
        minViolations: minViolations
    };
}


/**
 * --- *** FEATURE UPDATE *** ---
 * Detects possible systematic extinctions from observed reflections.
 * This version will list a rule as "possible" even if only one peak
 * is observed in that zone, as long as it satisfies the rule.
 * (This function is called by analyzeSystematicAbsences)
 */
function detectExtinctions(indexed_hkls) {
    const confirmed = [];
    
    // Only test the most common/clear extinctions
    const tests = [
        // Axial extinctions
        { name: '00l: l=2n', zone: r => r.h === 0 && r.k === 0 && r.l !== 0, 
          test: r => r.l % 2 === 0 },
        { name: 'h00: h=2n', zone: r => r.k === 0 && r.l === 0 && r.h !== 0, 
          test: r => r.h % 2 === 0 },
        { name: '0k0: k=2n', zone: r => r.h === 0 && r.l === 0 && r.k !== 0, 
          test: r => r.k % 2 === 0 },
        
        // Common planar extinctions
        { name: 'hk0: h+k=2n', zone: r => r.l === 0 && r.h !== 0 && r.k !== 0,
          test: r => (r.h + r.k) % 2 === 0 },
        { name: 'h0l: h+l=2n', zone: r => r.k === 0 && r.h !== 0 && r.l !== 0,
          test: r => (r.h + r.l) % 2 === 0 },
        { name: '0kl: k+l=2n', zone: r => r.h === 0 && r.k !== 0 && r.l !== 0,
          test: r => (r.k + r.l) % 2 === 0 }
    ];
    
    for (const {name, zone, test} of tests) {
        const zoneReflections = indexed_hkls.filter(zone);
        
        // --- *** MODIFICATION *** ---
        // Removed the 'minCount' check.
        if (zoneReflections.length === 0) {
            continue;
        }
        // --- *** END MODIFICATION *** ---
        
        // All observed reflections in zone must satisfy condition
        if (zoneReflections.every(test)) {
            confirmed.push(name);
        }
    }
    
    return confirmed.length > 0 ? confirmed : ["None detected"];
}

/**
 * Ranks space groups AND THEIR SETTINGS by compatibility with observed reflections.
 * (This function is a helper for analyzeSystematicAbsences)
 */
function rankSpaceGroups(indexed_hkls, system, allowedCenterings, spaceGroupData, maxViolations) {
    const candidateGroups = Object.values(spaceGroupData.space_groups)
        .filter(sg => sg.crystal_system === system);
    
    const validSettings = [];
    
    for (const sg of candidateGroups) {
        const sgNumber = sg.number;
        
        // Iterate through every setting for this space group
        for (const setting of sg.settings) {
            const centering = setting.symbol.charAt(0);
            
            // --- *** FIX *** ---
            // This now correctly checks if the setting's centering
            // is in the list of allowed centerings (e.g., ['P', 'C'])
            if (!allowedCenterings.includes(centering) && 
                !(allowedCenterings.includes('P') && !['I','F','A','B','C','R'].includes(centering))) {
                continue;
            }
            // --- *** END FIX *** ---
            
            const rules = setting.reflection_conditions || {};
            const violations = countViolations(indexed_hkls, rules);
            
            if (violations.count <= maxViolations) {
                validSettings.push({
                    number: sgNumber,
                    symbol: setting.symbol, 
                    standardSymbol: sg.standard_symbol, 
                    pointGroup: sg.point_group,
                    centrosymmetric: sg.centrosymmetric,
                    violations: violations.count,
                    violatedReflections: violations.details
                });
            }
        }
    }
    
    // Sort the final flat list by violations, then by space group number
    validSettings.sort((a, b) => {
        if (a.violations !== b.violations) return a.violations - b.violations;
        return a.number - b.number;
    });
    
    return validSettings;
}

/**
 * Counts how many observed reflections violate a space group's conditions.
 * (This function is a helper for analyzeSystematicAbsences)
 */
function countViolations(indexed_hkls, rules) {
    let count = 0;
    const details = [];
    
    // Helper to check if a condition string is satisfied
    const satisfiesCondition = (h, k, l, condStr) => {
        // Parse conditions like "h+k=2n", "l=4n", etc.
        const match = condStr.match(/([hkl\+\-]+)=(\d+)n/);
        if (!match) return true; // Can't parse, assume satisfied
        
        const [, expr, modStr] = match;
        const mod = parseInt(modStr);
        
        // Evaluate the expression
        let value = 0;
        const terms = expr.match(/[+-]?[hkl]/g) || [];
        for (const term of terms) {
            const sign = term[0] === '-' ? -1 : 1;
            const variable = term.replace(/[+-]/g, '');
            if (variable === 'h') value += sign * h;
            else if (variable === 'k') value += sign * k;
            else if (variable === 'l') value += sign * l;
        }
        
        return Math.round(value) % mod === 0;
    };
    
    // --- *** MODIFICATION *** ---
    // Loop through the full reflection object to access all its properties
    for (const reflection of indexed_hkls) {
        const {h, k, l, calc_tth} = reflection; // Destructure h, k, l, and calc_tth
        // --- *** END MODIFICATION *** ---
        
        let isViolation = false;
        
        // Determine which rule applies to this reflection
        const zone = getReflectionZone(h, k, l);
        const applicableRules = rules[zone] || [];
        
        // Also check general hkl rules
        const generalRules = rules.hkl || [];
        
        // Check if reflection satisfies all applicable conditions
        for (const cond of [...applicableRules, ...generalRules]) {
            if (!satisfiesCondition(h, k, l, cond)) {
                isViolation = true;
                
                // --- *** MODIFICATION *** ---
                // Create the new, more detailed violation string
                const tth_string = calc_tth ? ` at ${calc_tth.toFixed(3)}°` : '';
                details.push(`(${h},${k},${l})${tth_string} violates ${zone}: ${cond}`);
                // --- *** END MODIFICATION *** ---
                
                break;
            }
        }
        
        if (isViolation) count++;
    }
    
    return { count, details: details.slice(0, 5) }; // Limit details
}



/**
 * Determines the zone designation for a reflection
 * (This function is a helper for analyzeSystematicAbsences)
 */
function getReflectionZone(h, k, l) {
    if (k === 0 && l === 0 && h !== 0) return 'h00';
    if (h === 0 && l === 0 && k !== 0) return '0k0';
    if (h === 0 && k === 0 && l !== 0) return '00l';
    if (h === 0 && k !== 0 && l !== 0) return '0kl';
    if (k === 0 && h !== 0 && l !== 0) return 'h0l';
    if (l === 0 && h !== 0 && k !== 0) return 'hk0';
    if (h !== 0 && h === k && l !== 0 && h !== l) return 'hhl';
    if (k !== 0 && k === l && h !== 0 && h !== k) return 'hkk';
    if (h !== 0 && h === l && k !== 0 && k !== h) return 'hll';
    return 'hkl';
}

    const inputsToValidate = [
        { id: 'wavelength', el: ui.wavelength, default: 1.541780 },
        { id: 'max-volume', el: ui.maxVolume, default: 1000 },
        { id: 'tth-error', el: ui.tthError, default: 0.05 },
        { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 0 },
    ];

    inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
        if (el) {
            el.addEventListener('blur', () => {
                const min = parseFloat(el.min);
                const max = parseFloat(el.max);
                let value = parseFloat(el.value);
                if (isNaN(value)) { el.value = defaultValue; return; }
                if (!isNaN(min) && value < min) el.value = min;
                if (!isNaN(max) && value > max) el.value = max;
            });
        } else {
            console.error(`Initialization Error: The element with id="${id}" was not found.`);
        }
    });

    if (ui.wavelength) {
        ui.wavelength.addEventListener('change', () => {
            if (pickedPeaks.length > 0) {
                recalculatePeakValues();
                updatePeakTable();
            }
        });
    }


        const detectAndParseFile = (fileName, fileContent) => {
    const name = fileName.toLowerCase();
    const lines = fileContent.trim().split(/\r?\n/);
    const firstLine = lines.length > 0 ? lines[0].trim() : '';
    
    if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) return parseUxdFile(fileContent);
    if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) return parseXrdmlFile(fileContent);
    if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) return parseBrukerBrmlFile(fileContent);
    if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) return parseRigakuRasFile(fileContent);
    if (name.endsWith('.udf')) return parsePhilipsUdfFile(fileContent);

    // better GSAS detection logic
    const bankLine = lines.find(line => line.trim().toUpperCase().startsWith('BANK'));
    if (bankLine) {
        // XRA format has 'STD' on the same line as 'BANK'
        if (bankLine.toUpperCase().includes('STD')) {
            return parseGsasXraFile(fileContent);
        }
        // Otherwise, assume it's the ESD format (Y, sigY pairs)
        return parseGsasEsdFile(fileContent);
    }

    // Fallback to generic two-column parser
    return parseDataFile(fileContent);
};
        
        const parseDataFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; lines.forEach(line => { if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return; const parts = line.trim().split(/[\s,;]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } }); return { tth, intensity }; };
        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            // This format has CONST at index 4, start at 5, step at 6
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1; // Data starts on the next line
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        // Ignore blank lines that might be at the end of the file
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        // This loop reads every value, as XRA format is intensity-only
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };





    ui.fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        ui.fileInputLabel.classList.remove('error');
        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                const parsedData = detectAndParseFile(file.name, evt.target.result);
                if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points could be parsed from the file.");
                fullExperimentalData = parsedData;
                const maxIntensity = Math.max(...fullExperimentalData.intensity);
                if (maxIntensity > 0) fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                solutions = [];
                displayedSolutions = [];
                updateSolutionsTable();
                ui.solutionsLed.className = 'led-indicator gray';
                if (parsedData.wavelength) ui.wavelength.value = parsedData.wavelength.toFixed(5);
                selectedSolution = null;
                currentHklList = [];
                ui.fileName.textContent = file.name;
                ui.placeholder.style.display = 'none';
                ui.resultsContainer.style.display = 'flex';
                ui.peakControls.classList.remove('hidden');
                ui.indexingControls.classList.remove('hidden');
                initializeChart();
                setupTthSliders();
                findPeaks();
                showStatus(`File "${file.name}" loaded successfully.`, 'success');
            } catch (error) {
                showStatus(`Error reading file: ${error.message}`, 'error');
                ui.fileInputLabel.classList.add('error');
                console.error(error);
            }
        };
        reader.onerror = () => {
             showStatus('Error: Could not read the selected file.', 'error');
             ui.fileInputLabel.classList.add('error');
        };
        reader.readAsText(file);
    });

    const setupTthSliders = () => {
        if (fullExperimentalData.tth.length === 0) return;
        const min = fullExperimentalData.tth[0];
        const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
        const step = (max - min) / 2000;
        [ui.tthMinSlider, ui.tthMaxSlider].forEach(el => { el.disabled = false; Object.assign(el, { min, max, step }); });
        const initialMin = Math.floor(min);
        const initialMax = Math.ceil(max);
        ui.tthMinSlider.value = initialMin;
        ui.tthMaxSlider.value = initialMax;
        ui.tthMinValue.textContent = initialMin.toFixed(2);
        ui.tthMaxValue.textContent = initialMax.toFixed(2);
        updatePlotRange(true);
    };

    const updatePlotRange = (updateYScale = false) => {
        if(!xrdChart) return;
        const min = parseFloat(ui.tthMinSlider.value);
        const max = parseFloat(ui.tthMaxSlider.value);
        xrdChart.options.scales.x.min = min;
        xrdChart.options.scales.x.max = max;
        if (updateYScale) {
            const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                const tth = fullExperimentalData.tth[index];
                return tth >= min && tth <= max;
            });
            if (visibleIntensities.length > 0) {
                const yMaxInRange = Math.max(...visibleIntensities);
                xrdChart.options.scales.y.min = -yMaxInRange * 0.05;
                xrdChart.options.scales.y.max = yMaxInRange * 1.1;
            } else {
                const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                xrdChart.options.scales.y.min = -yMax * 0.05;
                xrdChart.options.scales.y.max = yMax * 1.1;
            }
        }
        xrdChart.update('none');
        updateAllMarkers();
    };

    ui.tthMinSlider.addEventListener('input', () => {
        let minVal = parseFloat(ui.tthMinSlider.value);
        let maxVal = parseFloat(ui.tthMaxSlider.value);
        if (minVal >= maxVal) { minVal = maxVal - parseFloat(ui.tthMinSlider.step); ui.tthMinSlider.value = minVal; }
        ui.tthMinValue.textContent = minVal.toFixed(2);
        updatePlotRange();
    });
     ui.tthMaxSlider.addEventListener('input', () => {
        let minVal = parseFloat(ui.tthMinSlider.value);
        let maxVal = parseFloat(ui.tthMaxSlider.value);
        if (maxVal <= minVal) { maxVal = minVal + parseFloat(ui.tthMaxSlider.step); ui.tthMaxSlider.value = maxVal; }
        ui.tthMaxValue.textContent = maxVal.toFixed(2);
        updatePlotRange();
    });
    
    ui.ballRadiusSlider.addEventListener('input', () => { ui.ballRadiusValue.textContent = ui.ballRadiusSlider.value; debouncedFindPeaks(); });
    ui.smoothingWidthSlider.addEventListener('input', () => { ui.smoothingWidthValue.textContent = ui.smoothingWidthSlider.value; debouncedFindPeaks(); });
    ui.peakThresholdSlider.addEventListener('input', () => { const value = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)); ui.peakThresholdValue.textContent = value.toFixed(1); debouncedFindPeaks(); });

    const rollingBallBackground = (y, radius, smoothingWidth) => {
        const n = y.length;
        if (n === 0 || radius <= 0) return new Array(n).fill(0);
        let smoothed_y = y;
        if (smoothingWidth > 1) {
            smoothed_y = new Array(n);
            const halfWidth = Math.floor(smoothingWidth / 2);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWidth);
                const end = Math.min(n, i + halfWidth + 1);
                let sum = 0;
                for (let j = start; j < end; j++) sum += y[j];
                smoothed_y[i] = sum / (end - start);
            }
        }
        const eroded = new Array(n);
        for (let i = 0; i < n; i++) {
            const start = Math.max(0, i - radius);
            const end = Math.min(n, i + radius + 1);
            let min = Infinity;
            for (let j = start; j < end; j++) if (smoothed_y[j] < min) min = smoothed_y[j];
            eroded[i] = min;
        }
        const background = new Array(n);
        for (let i = 0; i < n; i++) {
            const start = Math.max(0, i - radius);
            const end = Math.min(n, i + radius + 1);
            let max = -Infinity;
            for (let j = start; j < end; j++) if (eroded[j] > max) max = eroded[j];
            background[i] = max;
        }
        return background;
    };

    const savitzkyGolay = (data, windowSize = 9, polyOrder = 2) => {
        const n = data.length; if (n === 0) return [];
        windowSize = Math.max(3, windowSize); if (windowSize % 2 === 0) windowSize += 1; windowSize = Math.min(windowSize, n);
        const halfWindow = Math.floor(windowSize / 2);
        const result = new Array(n);
        const coefficients = (windowSize === 9 && polyOrder === 2) ? [-0.0909, 0.0606, 0.1687, 0.2333, 0.2545, 0.2333, 0.1687, 0.0606, -0.0909] : (() => { const weights = []; for (let i = -halfWindow; i <= halfWindow; i++) weights.push(1 - Math.abs(i) / (halfWindow + 1)); const sum = weights.reduce((a, b) => a + b, 0); return weights.map(w => w / sum); })();
        for (let i = 0; i < n; i++) {
            let smoothedValue = 0;
            for (let j = -halfWindow; j <= halfWindow; j++) {
                let idx = i + j;
                if (idx < 0) idx = Math.abs(idx);
                else if (idx >= n) idx = n - 1 - (idx - (n - 1));
                smoothedValue += data[idx] * coefficients[j + halfWindow];
            }
            result[i] = smoothedValue;
        }
        return result;
    };

    function findPeaks() {
        if (!fullExperimentalData || !fullExperimentalData.intensity || fullExperimentalData.intensity.length < 5) return;
        const { intensity, tth } = fullExperimentalData; const n = tth.length;
        const minTth = parseFloat(ui.tthMinSlider.value) || tth[0];
        const maxTth = parseFloat(ui.tthMaxSlider.value) || tth[n - 1];
        const minHeightPercent = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)) || 2;
        const ballRadius = parseInt(ui.ballRadiusSlider.value, 10);
        const smoothingWidth = parseInt(ui.smoothingWidthSlider.value, 10);
        const background = rollingBallBackground(intensity, ballRadius, smoothingWidth);
        const backgroundCorrected = intensity.map((y, i) => Math.max(0, y - background[i]));
        const windowSize = Math.max(5, Math.min(11, Math.floor(n / 100)));
        const smoothed = savitzkyGolay(backgroundCorrected, windowSize, 2);
        const maxCorrectedIntensity = Math.max(...backgroundCorrected) || 1;
        const minAbsoluteHeight = (minHeightPercent / 100) * maxCorrectedIntensity;
        const calculateNoiseLevel = (data) => { const n_s = data.length; if (n_s < 10) return 0; const sample = []; for (let i = 0; i < n_s; i += Math.max(1, Math.floor(n_s / 100))) sample.push(data[i]); sample.sort((a, b) => a - b); const median = sample[Math.floor(sample.length / 2)]; const deviations = sample.map(x => Math.abs(x - median)); deviations.sort((a, b) => a - b); return deviations[Math.floor(deviations.length / 2)] * 1.4826; };
        const adaptiveThreshold = Math.max(minAbsoluteHeight, calculateNoiseLevel(backgroundCorrected) * 3);
        const localMaxIndices = [];
        for (let i = 1; i < n - 1; i++) {
            const current = smoothed[i]; if (current < adaptiveThreshold) continue;
            if (current > smoothed[i - 1] && current > smoothed[i + 1]) localMaxIndices.push(i);
            else if (current === smoothed[i + 1] && current > smoothed[i - 1]) { let plateauEnd = i + 1; while (plateauEnd < n - 1 && Math.abs(smoothed[plateauEnd] - current) < maxCorrectedIntensity * 0.001) plateauEnd++; if (plateauEnd < n && smoothed[plateauEnd] < current) localMaxIndices.push(Math.round((i + plateauEnd - 1) / 2)); i = plateauEnd - 1; }
        }
        const candidates = localMaxIndices.filter(idx => tth[idx] >= minTth && tth[idx] <= maxTth && backgroundCorrected[idx] >= adaptiveThreshold)
            .map(idx => ({ idx, tth: tth[idx], height: smoothed[idx], backgroundCorrectedHeight: backgroundCorrected[idx] }));
        const refinedPeaks = [];
        for (const peak of candidates) {
            const { idx } = peak; let refinedTth = peak.tth;
            if (idx > 0 && idx < n - 1) { const y1 = smoothed[idx - 1], y2 = smoothed[idx], y3 = smoothed[idx + 1]; const denominator = 2 * (y1 - 2 * y2 + y3); if (Math.abs(denominator) > 1e-10) { const delta = (y1 - y3) / denominator; if (Math.abs(delta) < 1.0) { const stepSize = idx < n - 1 ? tth[idx + 1] - tth[idx] : tth[idx] - tth[idx - 1]; refinedTth = tth[idx] + delta * stepSize; } } }
            refinedPeaks.push({ ...peak, tth: refinedTth });
        }
        refinedPeaks.sort((a, b) => a.tth - b.tth);
        const finalPeaks = []; const mergeThreshold = 0.02;
        for (const peak of refinedPeaks) {
            if (finalPeaks.length === 0 || Math.abs(peak.tth - finalPeaks[finalPeaks.length - 1].tth) >= mergeThreshold) finalPeaks.push(peak);
            else if (peak.height > finalPeaks[finalPeaks.length - 1].height) finalPeaks[finalPeaks.length - 1] = peak;
        }
        const lambda = parseFloat(ui.wavelength.value) || 1.54178;
        pickedPeaks = finalPeaks.map(p => { const d = lambda / (2 * Math.sin(p.tth * Math.PI / 360)); return { tth: p.tth, d: d, q: 1 / (d * d) }; });
        updatePeakTable(); updateStartIndexingButtonState();
    };

    const recalculatePeakValues = () => {
        const lambda = parseFloat(ui.wavelength.value);
        pickedPeaks.forEach(peak => { peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360)); peak.q = 1 / (peak.d * peak.d); });
    };

    const updatePeakTable = () => {
        ui.peakListBody.innerHTML = '';
        pickedPeaks.forEach((peak, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${index + 1}</td><td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td><td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td><td><button class="delete-peak-btn" data-index="${index}">X</button></td>`;
            ui.peakListBody.appendChild(row);
        });
        ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
        updateAllMarkers();
    };
    
    const updateStartIndexingButtonState = () => {
        const needed = 4 - pickedPeaks.length;
        if (needed > 0) { ui.startIndexingButton.disabled = true; ui.startIndexingButton.textContent = `Need ${needed} more peak${needed > 1 ? 's' : ''}`; } 
        else { ui.startIndexingButton.disabled = false; ui.startIndexingButton.textContent = 'Start Indexing'; }
    };

    ui.peakListBody.addEventListener('change', (e) => {
        if (e.target.classList.contains('peak-tth-input')) {
            const index = parseInt(e.target.dataset.index); const tth = parseFloat(e.target.value); const lambda = parseFloat(ui.wavelength.value);
            const d = lambda / (2 * Math.sin(tth * Math.PI / 360)); const q = 1 / (d*d);
            pickedPeaks[index] = {tth, d, q};
            e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
            updateAllMarkers(); updateStartIndexingButtonState();
        }
    });
     ui.peakListBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-peak-btn')) { const index = parseInt(e.target.dataset.index); pickedPeaks.splice(index, 1); updatePeakTable(); updateStartIndexingButtonState(); }
    });
    
    const setUIState = (indexing) => {
        isIndexing = indexing; document.body.style.cursor = indexing ? 'wait' : 'default';
        const controlsToDisable = [ ui.fileInput, ui.peakThresholdSlider, ui.tthMinSlider, ui.tthMaxSlider, ui.ballRadiusSlider, ui.smoothingWidthSlider, ui.wavelength, ui.tthError, ui.maxVolume, ui.impurityPeaksInput, ui.refineZeroCheckbox, ...ui.systemCheckboxes, ...ui.tabButtons ];
        controlsToDisable.forEach(el => { if (el) el.disabled = indexing; });
        ui.peakListBody.querySelectorAll('input, button').forEach(el => { el.disabled = indexing; });
        ui.fileInputLabel.style.pointerEvents = indexing ? 'none' : 'auto'; ui.fileInputLabel.style.opacity = indexing ? '0.7' : '1';
        if (indexing) {
            ui.startIndexingButton.disabled = true;
           // ui.startIndexingButton.textContent = 'Indexing...';
            ui.reportButton.textContent = 'Stop'; ui.reportButton.disabled = false;
            ui.progressBarContainer.classList.remove('hidden'); ui.progressBar.style.width = '0%';
        } else {
            updateStartIndexingButtonState(); ui.reportButton.textContent = 'Generate PDF Report'; ui.reportButton.disabled = (solutions.length === 0);
            ui.progressBarContainer.classList.add('hidden'); ui.progressBar.style.width = '0%';
            if (fullExperimentalData.tth.length > 0) { ui.tthMinSlider.disabled = false; ui.tthMaxSlider.disabled = false; }
        }
    };
    
    const applyFinalSieve = (solutions) => {
        if (solutions.length <= 1) return solutions;
        showStatus('Applying final sieve to results...', 'info', 2000);
        const symmetryOrder = { 'cubic': 5, 'hexagonal': 4, 'tetragonal': 4, 'orthorhombic': 3, 'monoclinic': 2 };
        solutions.sort((a, b) => a.volume - b.volume);
        const toKeep = new Array(solutions.length).fill(true);
        for (let i = 0; i < solutions.length; i++) {
            if (!toKeep[i]) continue;
            for (let j = i + 1; j < solutions.length; j++) {
                if (!toKeep[j]) continue;
                const vol_i = solutions[i].volume; const vol_j = solutions[j].volume;
                if (vol_j > vol_i * 1.01) break;
                const sym_i = symmetryOrder[solutions[i].system]; const sym_j = symmetryOrder[solutions[j].system];
                if (sym_i > sym_j) toKeep[j] = false;
                else if (sym_j > sym_i) { toKeep[i] = false; break; } 
                else { if (solutions[i].m20 >= solutions[j].m20) toKeep[j] = false; else { toKeep[i] = false; break; } }
            }
        }
        const filteredSolutions = solutions.filter((_, index) => toKeep[index]);
        const numDiscarded = solutions.length - filteredSolutions.length;
        if (numDiscarded > 0) showStatus(`Sieve discarded ${numDiscarded} redundant solution(s).`, 'success');
        return filteredSolutions.slice(0, 50);
    };

    // ==================================================================
    // ==         FUNCTION MODIFIED FOR PROGRESS BAR FIX               ==
    // ==================================================================


const startIndexing = () => {
    if (pickedPeaks.length < 4) { showStatus("Please find at least 4 peaks before starting indexing.", 'error'); return; }
    const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
    if (systemsToSearch.length === 0) { showStatus("Please select at least one crystal system to search.", 'error'); return; }
    if (!workerURL) { showStatus("Error: Indexing engine is not available.", "error"); return; }
    
    const statusTextElement = document.getElementById('status-text');
    if (statusTextElement) statusTextElement.textContent = 'Initializing...';

    setUIState(true); 

    // --- Switch to Solutions Tab ---
    ui.tabButtons.forEach(btn => btn.classList.remove('active'));
    ui.tabPanels.forEach(panel => panel.classList.remove('active'));
    document.querySelector('.tab-btn[data-tab="solutions"]').classList.add('active');
    document.getElementById('solutions-tab-content').classList.add('active');
    // --- END ---
    
    solutions = []; 
    displayedSolutions = [];
    selectedSolution = null; 
    currentHklList = []; 
    activeWorkers = [];
    updateSolutionsTable(); 
    updateAllMarkers();
    showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');

    const baseParams = {
        peaks: pickedPeaks,
        wavelength: parseFloat(ui.wavelength.value),
        tth_error: parseFloat(ui.tthError.value),
        max_volume: parseFloat(ui.maxVolume.value),
        impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
        refineZero: ui.refineZeroCheckbox.checked,
        allowedSystems: systemsToSearch
    };

    const totalWorkers = systemsToSearch.length;
    const workerProgress = new Array(totalWorkers).fill(0);

    systemsToSearch.forEach((system, workerIndex) => { 
        const worker = new Worker(workerURL);
        activeWorkers.push(worker);
        worker.onmessage = (e) => {
            const { type, payload } = e.data;

            if (type === 'status') {
                if (statusTextElement) statusTextElement.textContent = payload;
            
            } else if (type === 'progress') {
                workerProgress[workerIndex] = payload; 
                const totalProgress = workerProgress.reduce((sum, p) => sum + p, 0) / totalWorkers;
                ui.progressBar.style.width = `${Math.min(100, totalProgress)}%`;

            } else if (type === 'solution') {
                solutions.push(payload);
                if (solutions.length === 1) {
                    ui.solutionsLed.className = 'led-indicator green';
                }
                sortSolutions(); 
                const selectedSystems = Array.from(ui.systemCheckboxes)
                                             .filter(cb => cb.checked)
                                             .map(cb => cb.value);
                displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
                updateSolutionsTable();
            
            } else if (type === 'done') {
                workerProgress[workerIndex] = 100;
                const totalProgress = workerProgress.reduce((sum, p) => sum + p, 0) / totalWorkers;
                ui.progressBar.style.width = `${totalProgress}%`;

                worker.terminate();
                activeWorkers = activeWorkers.filter(w => w !== worker);
                
                // --- *** MODIFIED BLOCK *** ---
                // Check if all workers are gone
                if (activeWorkers.length === 0) {
                    // Call the new finalize function for a normal finish
                    finalizeIndexing(false);
                }
                // --- *** END MODIFICATION *** ---
            }
        };
        worker.postMessage({ ...baseParams, systemToSearch: system });
    });
};


    const finalizeIndexing = (stoppedByUser = false) => {
        const statusTextElement = document.getElementById('status-text');

        if (statusTextElement) statusTextElement.textContent = 'Applying final sieve...';
        solutions = applyFinalSieve(solutions); 
        
        if (statusTextElement) statusTextElement.textContent = 'Analyzing space groups...';
        
        // --- *** FIX *** ---
        // Get the 2-theta range from the sliders *once*
        const tthMinVal = parseFloat(ui.tthMinSlider.value);
        const tthMaxVal = parseFloat(ui.tthMaxSlider.value);

        // Pre-filter the peaks list based on the slider range
        const filteredPeaks = pickedPeaks.filter(p => p.tth >= tthMinVal && p.tth <= tthMaxVal);
        // --- *** END FIX *** ---

        if (spaceGroupData) {
            solutions.forEach(sol => {
                // --- *** FIX *** ---
                // Pass the *filtered* peak list and the *max 2-theta* value
                // to the analysis function.
                sol.analysis = analyzeSystematicAbsences(
                    sol, 
                    filteredPeaks, // Pass the filtered list
                    spaceGroupData,
                    parseFloat(ui.wavelength.value),     
                    parseFloat(ui.tthError.value),
                    tthMaxVal // Pass the slider max value
                );
                // --- *** END FIX *** ---
            });
        } else {
            console.warn('Space group data not available');
            solutions.forEach(sol => {
                sol.analysis = {
                    centering: 'Unknown (data not loaded)',
                    rankedSpaceGroups: [],
                    detectedExtinctions: []
                };
            });
        }
                                    
        if (statusTextElement) statusTextElement.textContent = '';
        
        // This will set isIndexing to false
        setUIState(false); 
        
        sortSolutions();
        displayedSolutions = [...solutions]; // Ensure displayedSolutions is updated
        updateSolutionsTable();

        if (solutions.length > 0) {
            const message = stoppedByUser ? 'Indexing stopped by user.' : 'Indexing complete.';
            showStatus(`${message} Found ${solutions.length} potential solution(s).`, 'success');
            ui.solutionsLed.className = 'led-indicator green';
        } else {
            const message = stoppedByUser ? 'Indexing stopped by user.' : 'Indexing finished.';
            showStatus(`${message} No valid solutions were found.`, 'info');
            // Only set to red if no solutions, otherwise keep it green if it was already green
            if (solutions.length === 0) {
                ui.solutionsLed.className = 'led-indicator red';
            }
        }
    };



    ui.startIndexingButton.addEventListener('click', startIndexing);

    ui.reportButton.addEventListener('click', () => {
        if (isIndexing) {
            // 1. Kill all running workers
            activeWorkers.forEach(w => w.terminate()); 
            activeWorkers = [];
            
            // 2. Call the finalize function (passing 'true' for "stopped by user")
            // This will run the sieve, space group analysis, and then reset the UI.
            finalizeIndexing(true); 
            
        } else { 
            // If not indexing, just generate the report
            generatePDFReport(); 
        }
    });
    
    const sortSolutions = () => {
        const { column, direction } = sortState;
        const dir = direction === 'asc' ? 1 : -1;
        solutions.sort((a, b) => {
            if (column === 'system') {
                return (a.system || '').localeCompare(b.system || '') * dir;
            } else {
                let valA = a[column]; let valB = b[column];
                if (isNaN(valA) || valA == null) valA = -Infinity;
                if (isNaN(valB) || valB == null) valB = -Infinity;
                return (valA - valB) * dir;
            }
        });
    };

    const updateSolutionsTable = () => {
        ui.solutionsTableBody.innerHTML = '';
        displayedSolutions.forEach((sol, index) => {
            const row = document.createElement('tr'); row.dataset.index = index; 
            let paramsCell = '', anglesCell = '';
            switch(sol.system) {
                case 'cubic': paramsCell = `a = ${sol.a.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'tetragonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'hexagonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 120`; break;
                case 'orthorhombic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'monoclinic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, ${sol.beta.toFixed(3)}, 90`; break;
                default: paramsCell = `${sol.a.toFixed(4)}`; anglesCell = `-`;
            }
            if (sol.zero_correction) {
                anglesCell += `<br><span style="font-size:0.9em; color: var(--text-dark);">(Z=${sol.zero_correction.toFixed(4)}°)</span>`;
            }
            row.innerHTML = `<td>${sol.system.substring(0,4)}</td><td>${paramsCell}</td><td>${anglesCell}</td><td>${sol.volume.toFixed(2)}</td><td>${sol.m20.toFixed(2)}</td>`;
            ui.solutionsTableBody.appendChild(row);
        });
        
        ui.solutionsTableHeaders.forEach(h => {
            h.classList.remove('sort-asc', 'sort-desc');
            if (h.dataset.sort === sortState.column) {
               h.classList.add(sortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            }
        });
    };

    ui.solutionsTableBody.addEventListener('click', (e) => {
        const row = e.target.closest('tr'); if (!row) return;
        document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        const index = parseInt(row.dataset.index);
        selectedSolution = displayedSolutions[index];
        const lambda = parseFloat(ui.wavelength.value);
        const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
        currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);
        updateAllMarkers();
    });

    Chart.register({ id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x; let yAxis = chart.scales.y; let ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } });
    Chart.register({ id: 'legendMargin', beforeInit(chart) { const originalFit = chart.legend.fit; chart.legend.fit = function() { originalFit.bind(chart.legend)(); this.height += 15; }; } });

    const initializeChart = () => {
        if (xrdChart) xrdChart.destroy();
        const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, fullExperimentalData.intensity[i]) }));
        const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
        xrdChart = new Chart(ui.chartCanvas, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Intensity', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', showLine: true, borderWidth: 0.75, pointRadius: 1.5, pointHoverRadius: 4, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)' },
                    { type: 'bar', label: 'Observed Peaks', data: [], backgroundColor: 'rgba(239, 68, 68, 0.7)', barThickness: 1 },
                    { type: 'bar', label: 'Calculated Peaks', data: [], backgroundColor: 'rgba(59, 130, 246, 0.9)', barThickness: 1 }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                    y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.05, max: yMax * 1.1, suggestedMin: 0 }
                },
                plugins: {
                    zoom: {
                        pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => { updateAllMarkers(); } },
                        zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => { updateAllMarkers(); } }
                    },
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                if (!tooltipItems.length) return '';
                                const tth = tooltipItems[0].parsed.x;
                                let title = `2θ: ${tth.toFixed(3)}°`;
                                if (currentHklList && currentHklList.length > 0) {
                                    let closestPeak = null; let minDiff = Infinity;
                                    for (const hkl of currentHklList) {
                                        const diff = Math.abs(tth - hkl.tth);
                                        if (diff < minDiff) { minDiff = diff; closestPeak = hkl; }
                                    }
                                    const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                    if (closestPeak && minDiff < tolerance) {
title += `, HKL: (${closestPeak.h},${closestPeak.k},${closestPeak.l}), d: ${closestPeak.d.toFixed(4)} Å`;                                    }
                                }
                                return title;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label || '';
                                if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') return null;
                                let label = datasetLabel ? `${datasetLabel}: ` : '';
                                if (context.parsed.y !== null) { label += Math.round(context.parsed.y); }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    };

    ui.chartCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        if (!xrdChart || !xrdChart.chartArea) return;
        const { left, right, top, bottom } = xrdChart.chartArea;
        const zoomDirection = e.deltaY < 0 ? 1.1 : 0.9;
        const zoomOptions = { x: 1, y: 1 };
        if (e.offsetY > bottom && e.offsetX > left && e.offsetX < right) {
            zoomOptions.x = zoomDirection;
        } else if (e.offsetX < left && e.offsetY > top && e.offsetY < bottom) {
            zoomOptions.y = zoomDirection;
        } else if (e.offsetX >= left && e.offsetX <= right && e.offsetY >= top && e.offsetY <= bottom) {
            zoomOptions.x = zoomDirection;
            zoomOptions.y = zoomDirection;
        } else {
            return;
        }
        xrdChart.zoom(zoomOptions, 'none');
        updateAllMarkers();
    });

    const updateAllMarkers = () => {
        if (!xrdChart) return;
        const xMin = xrdChart.scales.x.min; const xMax = xrdChart.scales.x.max;
        const yMin = xrdChart.scales.y.min; const yMax = xrdChart.scales.y.max;
        const yRange = yMax - yMin;
        const markerHeight = yRange * 0.02;
        const visibleObsPeaks = pickedPeaks.filter(p => p.tth >= xMin && p.tth <= xMax);
        xrdChart.data.datasets[1].data = visibleObsPeaks.map(p => ({ x: p.tth, y: [yMin, yMin + markerHeight] }));
        if (selectedSolution) {
            const calculatedBottom = yMin + markerHeight * 1.2;
            const calculatedTop = calculatedBottom + markerHeight;
            const visibleCalcPeaks = currentHklList.filter(hkl => hkl.tth >= xMin && hkl.tth <= xMax);
            xrdChart.data.datasets[2].data = visibleCalcPeaks.map(hkl => ({ x: hkl.tth, y: [calculatedBottom, calculatedTop] }));
        } else {
            xrdChart.data.datasets[2].data = [];
        }
        xrdChart.update('none');
    };
    
    // ==================================================================
    const generateHKL = (maxTth, params, system) => {
        const { a, b, c, beta, lambda } = params; if (!a || !lambda) return [];
        const reflections = [];
        const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
        const q_max_limit = (1 / (d_min * d_min)) * 1.05;
        const h_max = Math.ceil(a / d_min);
        const k_max = b ? Math.ceil(b / d_min) : h_max;
        const l_max = c ? Math.ceil(c / d_min) : h_max;

        const processHKL = (h, k, l) => {
            if (h === 0 && k === 0 && l === 0) return;
            let inv_d_sq = 0;
            switch (system) {
                case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                case 'monoclinic':
                    const sinBeta = Math.sin(beta*Math.PI/180); const cosBeta = Math.cos(beta*Math.PI/180);
                    inv_d_sq = (1/(sinBeta*sinBeta))*(h*h/(a*a)+l*l/(c*c)-2*h*l*cosBeta/(a*c))+k*k/(b*b);
                    break;
            }
            if (inv_d_sq > 0 && inv_d_sq <= q_max_limit) {
                const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                if (sinThetaSq <= 1) {
                    const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                    reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                }
            }
        };

        if (system === 'cubic') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= k; l++) processHKL(h,k,l);
        } else if (system === 'hexagonal' || system === 'tetragonal') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= l_max; l++) {
                if(h===0 && k===0 && l===0) continue;
                processHKL(h,k,l);
            }
        } else if (system === 'orthorhombic') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= k_max; k++) for (let l = 0; l <= l_max; l++) processHKL(h,k,l);
        } else { // Monoclinic & Triclinic (fallback)
             for (let h = -h_max; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) { // k >= 0 is sufficient
                    for (let l = -l_max; l <= l_max; l++) {
                        
                        // Add uniqueness filter for monoclinic (k=0, h>0 or h=0,l>0)
                        if (system === 'monoclinic' && k === 0) {
                           if (h < 0) continue;
                           if (h === 0 && l <= 0) continue;
                        }
                        
                        processHKL(h,k,l);
                    }
                }
             }
        }

        const uniqueReflections = [];
        const tolerance = 1e-4;
        if (reflections.length > 0) {
            reflections.sort((a,b) => a.tth - b.tth);
            uniqueReflections.push(reflections[0]);
            for(let i=1; i<reflections.length; i++){
                if(Math.abs(reflections[i].tth - uniqueReflections[uniqueReflections.length-1].tth) > tolerance){
                    uniqueReflections.push(reflections[i]);
                }
            }
        }
        return uniqueReflections;
    };

    const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel');
    resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize';
        const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
        const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
        window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
    });
    
    ui.chartCanvas.addEventListener('contextmenu', e => { e.preventDefault(); if (xrdChart) { xrdChart.resetZoom('none'); updateAllMarkers(); } });
    ui.chartCanvas.addEventListener('click', (e) => {
        if (!e.ctrlKey || !xrdChart) return;
        const rect = xrdChart.canvas.getBoundingClientRect(); const x = e.clientX - rect.left;
        if (x < xrdChart.chartArea.left || x > xrdChart.chartArea.right) return;
        const tth = xrdChart.scales.x.getValueForPixel(x); if (!tth) return;
        const lambda = parseFloat(ui.wavelength.value); if (isNaN(lambda)) { showStatus('Wavelength is not a valid number.', 'error'); return; }
        const sin_theta = Math.sin(tth * Math.PI / 360); if (sin_theta <= 0) return;
        const d = lambda / (2 * sin_theta); const q = 1 / (d * d);
        pickedPeaks.push({ tth, d, q }); pickedPeaks.sort((a, b) => a.tth - b.tth);
        updatePeakTable(); updateStartIndexingButtonState(); showStatus(`Peak added at ${tth.toFixed(3)}°`, 'success', 2000);
    });

const formatWithError = (value, error) => {
        if (error === undefined || error === null || !isFinite(error) || error <= 0) {
            const places = Math.abs(value) > 10 ? 3 : 4;
            return value.toFixed(places);
        }

        // --- CORRECTED LOGIC ---
        const errorMagnitude = Math.floor(Math.log10(error));
        const firstSigDigit = Math.floor(error / Math.pow(10, errorMagnitude));

        let decimalPlaces;
        if (firstSigDigit >= 3) {
            // Use 1 significant figure for error (e.g., error=0.3 -> 1dp; error=3 -> 0dp)
            decimalPlaces = -errorMagnitude;
        } else {
            // Use 2 significant figures for error (e.g., error=0.28 -> 3dp; error=2.8 -> 1dp)
            decimalPlaces = -errorMagnitude + 1;
        }
        
        // Ensure decimalPlaces is reasonable and non-negative
        decimalPlaces = Math.max(0, Math.min(8, decimalPlaces));
        

        const multiplier = Math.pow(10, decimalPlaces);
        const roundedValue = (Math.round(value * multiplier) / multiplier).toFixed(decimalPlaces);
        const errorInLastDigits = Math.round(error * multiplier);
        return `${roundedValue}(${errorInLastDigits})`;
    };



        const generatePDFReport = async () => {
    if (displayedSolutions.length === 0) {
        showStatus("No solutions found to generate a report.", 'info');
        return;
    }
    ui.reportButton.textContent = 'Generating...';
    ui.reportButton.disabled = true;
    document.body.style.cursor = 'wait';

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'p',
            unit: 'mm',
            format: 'a4'
        });

        const margin = 15;
        let yPos = 20;
        const pdfWidth = doc.internal.pageSize.getWidth();
        const lambda = parseFloat(ui.wavelength.value);
        const tthError = parseFloat(ui.tthError.value);
        
        const tthMinVal = parseFloat(ui.tthMinSlider.value);
        const tthMaxVal = parseFloat(ui.tthMaxSlider.value);

        // --- FONTS & SIZES ---
        const FONT = {
            TITLE: 'helvetica',
            LABEL: 'helvetica',
            DATA: 'courier'
        };
        const SIZE = {
            TITLE: 18,
            H1: 14,
            H2: 12,
            BODY: 9,
            TABLE_HEADER: 8,
            TABLE_BODY: 8,
            SMALL: 7
        };

        // --- Page Header & Chart ---
        const now = new Date();
        const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

        doc.setFont(FONT.TITLE, 'bold').setFontSize(SIZE.TITLE).text('Combs - Powder Indexing Report', pdfWidth / 2, yPos, { align: 'center' });
        yPos += 10;
        
        doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
        doc.text(`Generated:`, margin, yPos);
        doc.setFont(FONT.DATA, 'normal').text(timestamp, margin + 25, yPos);
        yPos += 5;

        doc.setFont(FONT.LABEL, 'normal').text(`Data File:`, margin, yPos);
        doc.setFont(FONT.DATA, 'normal').text(ui.fileName.textContent, margin + 25, yPos);
        yPos += 10;
        
        const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff', scale: 2 });
        const imgData = canvas.toDataURL('image/png');
        const imgProps = doc.getImageProperties(imgData);
        const availableWidth = pdfWidth - 2 * margin;
        let imgHeight = (imgProps.height * availableWidth) / imgProps.width;
        doc.addImage(imgData, 'PNG', margin, yPos, availableWidth, imgHeight);

        // --- Parameters & Summary Table Page ---
        doc.addPage();
        yPos = 20;

        // --- Indexing Parameters Section ---
        doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1).text('Indexing Parameters', margin, yPos);
        yPos += 8;

        const paramData = [
            { label: 'Min Peak (%):', value: ui.peakThresholdValue.textContent },
            { label: 'Wavelength (A):', value: parseFloat(ui.wavelength.value).toFixed(5) },
            { label: 'Roll. Radius:', value: `${ui.ballRadiusValue.textContent} pts` },
            { label: 'Max Volume (A^3):', value: ui.maxVolume.value },
            { label: 'Smooth (pts):', value: ui.smoothingWidthValue.textContent },
            { label: 'Tolerance (2theta):', value: ui.tthError.value },
            { label: '2theta Min (deg):', value: tthMinVal.toFixed(2) },
            { label: 'Impurity Peaks:', value: ui.impurityPeaksInput.value },
            { label: '2theta Max (deg):', value: tthMaxVal.toFixed(2) },
            { label: 'Refine Zero:', value: ui.refineZeroCheckbox.checked ? 'True' : 'False' }
        ];

        const col1X = margin;
        const col2X = margin + 85;
        const labelWidth = 35;

        paramData.forEach((item, index) => {
            const isCol1 = index % 2 === 0;
            const x = isCol1 ? col1X : col2X;
            if (isCol1) yPos += 5;
            
            doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text(item.label, x, yPos);
            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(String(item.value), x + labelWidth, yPos);
        });
        yPos += 7;
        
        doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text('Systems Searched:', margin, yPos);
        const systems = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value.charAt(0).toUpperCase() + cb.value.slice(1));
        const systemsText = systems.join(', ');
        doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(systemsText, margin + labelWidth, yPos);
        yPos += 8;

        doc.setDrawColor(200); doc.line(margin, yPos, pdfWidth - margin, yPos); yPos += 8;

        // --- Indexing Solutions Summary Section ---
        doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1).text('Indexing Solutions Summary', margin, yPos); yPos += 8;
        doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER);
        doc.text('Sys', margin, yPos);
        doc.text('M(20)', margin + 15, yPos);
        doc.text('Volume(A^3)', margin + 35, yPos);
        doc.text('Parameters', margin + 65, yPos);
        yPos += 5;

        doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY);
        displayedSolutions.slice(0, 30).forEach(sol => {
            if (yPos > 280) { doc.addPage(); yPos = 20; }
            let paramStr = '';
            const p = sol.errors || {};
            switch (sol.system) {
                 case 'cubic': paramStr = `a=${formatWithError(sol.a, p.s_a)}`; break;
                 case 'tetragonal': paramStr = `a=${formatWithError(sol.a, p.s_a)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                 case 'hexagonal': paramStr = `a=${formatWithError(sol.a, p.s_a)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                 case 'orthorhombic': paramStr = `a=${formatWithError(sol.a, p.s_a)}, b=${formatWithError(sol.b, p.s_b)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                 case 'monoclinic': paramStr = `a=${formatWithError(sol.a, p.s_a)}, b=${formatWithError(sol.b, p.s_b)}, c=${formatWithError(sol.c, p.s_c)}, beta=${formatWithError(sol.beta, p.s_beta)}`; break;
            }
            doc.text(sol.system.substring(0,4), margin, yPos);
            doc.text(sol.m20.toFixed(2), margin + 15, yPos);
            doc.text(sol.volume.toFixed(2), margin + 35, yPos);
            doc.text(paramStr, margin + 65, yPos);
            yPos += 5;
        });

        // --- Detailed Solution Pages ---
        displayedSolutions.forEach((sol, solIndex) => {
            doc.addPage(); yPos = 20;
            doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H2);
            doc.text(`Details for Solution #${solIndex + 1}: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos); yPos += 7;
            
            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY);
            const p = sol.errors || {};
            const paramLines = [];
            switch (sol.system) {
                 case 'cubic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`); break;
                 case 'tetragonal': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                 case 'hexagonal': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                 case 'orthorhombic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `b = ${formatWithError(sol.b, p.s_b)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                 case 'monoclinic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `b = ${formatWithError(sol.b, p.s_b)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`, `beta = ${formatWithError(sol.beta, p.s_beta)} deg`); break;
            }
            paramLines.forEach(line => { doc.text(line, margin, yPos); yPos += 4; });

            if (sol.zero_correction !== undefined) { doc.text(`Zero Error (2theta) = ${formatWithError(sol.zero_correction, p.s_zero)} deg`, margin, yPos); yPos += 4; }
            doc.text(`Volume = ${sol.volume.toFixed(2)} A^3`, margin, yPos); yPos += 6;

            if (sol.analysis) {
                 doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text(`Lattice Centering:`, margin, yPos);
                 doc.setFont(FONT.DATA, 'normal').text(sol.analysis.centering, margin + 42, yPos); yPos += 5;
                 
                 doc.setFont(FONT.LABEL, 'normal').text('Possible Extinctions:', margin, yPos);
                 let extinctionList = sol.analysis.detectedExtinctions || [];
                 if (extinctionList.length > 0) {
                     doc.setFont(FONT.DATA, 'normal').text(extinctionList.join(', '), margin + 42, yPos);
                 } else {
                     doc.setFont(FONT.DATA, 'italic').text("None clearly detected", margin + 42, yPos);
                 }
                 yPos += 7;
                 
                 if (sol.analysis.rankedSpaceGroups && sol.analysis.rankedSpaceGroups.length > 0) {
                     if (yPos > 260) { doc.addPage(); yPos = 20; }
                     doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.BODY).text('Possible Space Groups:', margin, yPos); yPos += 5;
                     
                     // ... Space group listing logic remains the same ...
                     const sgList = sol.analysis.rankedSpaceGroups.slice(0, 20);
                     const groupsByViolation = {};
                     sgList.forEach(sg => { 
                         const v = sg.violations || 0; 
                         if (!groupsByViolation[v]) groupsByViolation[v] = []; 
                         groupsByViolation[v].push(sg); 
                     });

                     const maxViolationsToShow = 2;
                     for (let v = 0; v <= maxViolationsToShow; v++) {
                         if (groupsByViolation[v] && groupsByViolation[v].length > 0) {
                             if (yPos > 270) { doc.addPage(); yPos = 20; }
                             doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.BODY).text(`[${v} violation${v !== 1 ? 's' : ''}]:`, margin, yPos); yPos += 5;
                             
                             const groupsByNumber = new Map();
                             groupsByViolation[v].forEach(sg => {
                                 if (!groupsByNumber.has(sg.number)) groupsByNumber.set(sg.number, []);
                                 groupsByNumber.get(sg.number).push(sg.symbol);
                             });
                             
                             const sortedNumbers = Array.from(groupsByNumber.keys()).sort((a, b) => a - b);
                             doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY);
                             const maxLineLength = 85; 
                             
                             for (const number of sortedNumbers) {
                                 let line = `${number}: ${groupsByNumber.get(number).join(', ')}`;
                                 const splitLines = doc.splitTextToSize(line, maxLineLength);
                                 splitLines.forEach(splitLine => {
                                     if (yPos > 275) { doc.addPage(); yPos = 20; }
                                     doc.text(splitLine, margin + 5, yPos); 
                                     yPos += 4;
                                 });
                             }

                             if (v > 0) {
                                 const groupsToDetail = groupsByViolation[v].slice(0, 8); 
                                 groupsToDetail.forEach(sg => {
                                     if (yPos > 275) { doc.addPage(); yPos = 20; }
                                     if (sg.violatedReflections && sg.violatedReflections.length > 0) {
                                         doc.setFont(FONT.DATA, 'bold').setFontSize(SIZE.SMALL).text(`  ${sg.symbol}:`, margin + 5, yPos); yPos += 3.5;
                                         doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.SMALL);
                                         sg.violatedReflections.slice(0, 4).forEach(viol => { if (yPos > 280) { doc.addPage(); yPos = 20; } doc.text(`    ${viol}`, margin + 5, yPos); yPos += 3; });
                                         yPos += 1;
                                     }
                                 });
                             }
                             yPos += 3;
                         }
                     }
                 }
                 
                 if (sol.analysis.centeringViolations && Object.keys(sol.analysis.centeringViolations).length > 0) {
                     if (yPos > 268) { doc.addPage(); yPos = 20; }
                     doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text('Centering test violations:', margin, yPos); yPos += 5;
                     const violText = Object.entries(sol.analysis.centeringViolations).sort(([,a], [,b]) => a - b).map(([key, val]) => `${key}:${val}`).join(', ');
                     doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(violText, margin, yPos);
                     yPos += 5;
                 }
            } 
            yPos += 4;
            if (yPos > 255) { doc.addPage(); yPos = 20; }

            // --- REFLECTION TABLE ---
            doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER);
            const tableHeader = ' h k l   | 2th_meas 2th_corr 2th_calc | d_corr     d_calc    | diff(2th)';
            doc.text(tableHeader, margin, yPos); yPos += 4;
            
            const hklList = generateHKL_for_analysis(sol, lambda, tthMaxVal);
            
            if (hklList.length === 0) {
                 doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.BODY).text('Could not generate theoretical reflections for this cell.', margin, yPos);
                 yPos += 5;
                 return; 
            }

            const ambiguousHkls = sol.analysis.ambiguousHkls || new Set();
            const corrected_tth_obs = pickedPeaks.map(p => ({ ...p, tth_corr: p.tth - (sol.zero_correction || 0) }));
            const reportLines = []; 
            const assignedHkls = new Set();

            corrected_tth_obs.forEach((corr_peak) => {
                let bestMatchHkl = null; let minDiff = Infinity;
                hklList.forEach(hkl => { const diff = Math.abs(hkl.tth - corr_peak.tth_corr); if (diff < minDiff) { minDiff = diff; bestMatchHkl = hkl; } });
                
                if (bestMatchHkl && minDiff < tthError * 2 && corr_peak.tth_corr >= tthMinVal && corr_peak.tth_corr <= tthMaxVal) {
                    reportLines.push({ h: bestMatchHkl.h, k: bestMatchHkl.k, l: bestMatchHkl.l, tth_meas: corr_peak.tth, tth_corr: corr_peak.tth_corr, tth_calc: bestMatchHkl.tth, d_calc: bestMatchHkl.d });
                    assignedHkls.add(`${bestMatchHkl.h},${bestMatchHkl.k},${bestMatchHkl.l}`);
                }
            });

            hklList.forEach(hkl => {
                if (!assignedHkls.has(`${hkl.h},${hkl.k},${hkl.l}`) && hkl.tth >= tthMinVal && hkl.tth <= tthMaxVal) {
                    reportLines.push({ h: hkl.h, k: hkl.k, l: hkl.l, tth_meas: null, tth_corr: null, tth_calc: hkl.tth, d_calc: hkl.d });
                }
            });
            
            reportLines.sort((a, b) => a.tth_calc - b.tth_calc);
            
            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY);
            reportLines.forEach(line => {
                if (yPos > 285) { doc.addPage(); yPos = 20; doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER); doc.text(tableHeader, margin, yPos); yPos += 4; doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY); }
                
                const hkl_key = `${line.h},${line.k},${line.l}`;
                if (ambiguousHkls.has(hkl_key)) {
                    doc.setFont(FONT.DATA, 'italic');
                }

                const d_corr = line.tth_corr ? lambda / (2 * Math.sin(line.tth_corr * Math.PI / 360)) : null;
                const tth_m = line.tth_meas ? line.tth_meas.toFixed(3) : '   -   '; 
                const tth_c = line.tth_corr ? line.tth_corr.toFixed(3) : '   -   '; 
                const d_c_str = d_corr ? d_corr.toFixed(5) : '    -    '; 
                const diff_2t = line.tth_corr ? (line.tth_corr - line.tth_calc).toFixed(3) : '   -   ';
                
                const hkl_str = `${String(line.h).padStart(2)} ${String(line.k).padStart(2)} ${String(line.l).padStart(2)}`.padEnd(8);
                const pdfLine = `${hkl_str}| ${tth_m.padStart(7)} ${tth_c.padStart(7)} ${line.tth_calc.toFixed(3).padStart(7)} | ${d_c_str.padStart(9)} ${line.d_calc.toFixed(5).padStart(9)} | ${diff_2t.padStart(8)}`;
                doc.text(pdfLine, margin, yPos);
                
                doc.setFont(FONT.DATA, 'normal'); // Reset font to normal for the next line
                yPos += 3.5;
            });
        });

        const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
        doc.save(filename);
        showStatus('PDF report generated and saved.', 'success');

    } catch (error) {
        console.error("Failed to generate PDF:", error);
        showStatus("An error occurred during PDF generation.", 'error');
    } finally {
        ui.reportButton.textContent = 'Generate PDF Report';
        ui.reportButton.disabled = (solutions.length === 0);
        document.body.style.cursor = 'default';
    }
};






    window.addEventListener('beforeunload', () => { if (workerURL) URL.revokeObjectURL(workerURL); });
});

    </script>
    


<script id="indexing-worker" type="text/javascript">

self.onmessage = function(e) {
    // --- INITIAL SETUP ---
const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks, refineZero, allowedSystems } = e.data;

// --- DEBUG LOGGING ---
//    console.log(`[Worker] Received ${peaks.length} peaks. Wavelength: ${wavelength}`);
//    console.log("[Worker] Calculating q_obs (1/d^2) for all peaks:");
    const q_values_full = peaks.map(p => {
        const q = (4 * Math.sin(p.tth * Math.PI / 360)**2) / (wavelength**2);
//        console.log(`  2θ: ${p.tth.toFixed(4)} -> q: ${q.toFixed(6)}`);
        return q;
    });
    // --- END DEBUG LOGGING ---

const N_FOR_M20 = Math.min(20, peaks.length);
    const min_m20 = 2.0;
    const d_min = wavelength / (2 * Math.sin(Math.max(...peaks.map(p => p.tth)) * Math.PI / 360));
    const q_max = 1 / (d_min * d_min);
    
    const peaks_sorted_by_q = peaks.map((p, i) => ({...p, original_index: i})).sort((a,b) => a.q - b.q);
    const q_obs = new Float64Array(peaks_sorted_by_q.map(p => p.q));
    const original_indices = peaks_sorted_by_q.map(p => p.original_index);
    const tth_obs_rad = new Float64Array(peaks.map(p => p.tth * Math.PI / 180));
    
    const foundSolutions = [];
    const foundSolutionMap = new Map();

    // --- UTILITY & CRYSTALLOGRAPHY HELPER FUNCTIONS ---
    const metricFromCell = (cell) => {
        const deg2rad = Math.PI / 180;
        const a = cell.a; const b = cell.b ?? cell.a; const c = cell.c ?? cell.a;
        const alpha = (cell.alpha ?? 90) * deg2rad; const beta  = (cell.beta  ?? 90) * deg2rad; const gamma = (cell.gamma ?? 90) * deg2rad;
        const ca = Math.cos(alpha), cb = Math.cos(beta), cg = Math.cos(gamma);
        return [ [a*a, a*b*cg, a*c*cb], [a*b*cg, b*b, b*c*ca], [a*c*cb, b*c*ca, c*c] ];
    };
    const cellFromMetric = (G) => {
        const a = Math.sqrt(G[0][0]), b = Math.sqrt(G[1][1]), c = Math.sqrt(G[2][2]);
        const clamp = v => Math.max(-1, Math.min(1, v));
        const alpha = Math.acos(clamp(G[1][2]/(b*c)))*180/Math.PI, beta=Math.acos(clamp(G[0][2]/(a*c)))*180/Math.PI, gamma=Math.acos(clamp(G[0][1]/(a*b)))*180/Math.PI;
        return { a, b, c, alpha, beta, gamma };
    };
    const transpose = (M) => M[0].map((_,i) => M.map(r => r[i]));
    const matMul = (A,B) => {
        const r=A.length, c=B[0].length, k=A[0].length;
        const C = Array.from({length:r}, () => Array(c).fill(0));
        for(let i=0; i<r; i++) for(let j=0; j<c; j++) for(let t=0; t<k; t++) C[i][j] += A[i][t] * B[t][j];
        return C;
    };
    const getSymmetry = (a, b, c, alpha, beta, gamma, tol = 0.02) => {
        const eq = (v1, v2) => Math.abs(v1 - v2) < tol;
        const is90 = (v) => Math.abs(v - 90) < tol; const is120 = (v) => Math.abs(v - 120) < tol;
        const angles90 = is90(alpha) && is90(beta) && is90(gamma);
        if (angles90) {
            if (eq(a, b) && eq(b, c)) return 'cubic';
            if (eq(a, b) || eq(b, c) || eq(a, c)) return 'tetragonal';
            return 'orthorhombic';
        }
        if (is90(alpha) && is90(gamma) && is120(beta)) return 'hexagonal'; // Check for permuted hexagonal
        if (is90(beta) && is90(gamma) && is120(alpha)) return 'hexagonal'; // Check for permuted hexagonal
        if (is90(alpha) && is90(beta) && is120(gamma)) return 'hexagonal';
        if (is90(alpha) && is90(gamma) && !is90(beta)) return 'monoclinic';
        if (is90(beta) && is90(gamma) && !is90(alpha)) return 'monoclinic'; // b,c unique
        if (is90(alpha) && is90(beta) && !is90(gamma)) return 'monoclinic'; // a,b unique
        return 'triclinic';
    };
    const standardizeCell = (cell) => {
        const newCell = { ...cell };
        switch (cell.system) {
            case 'tetragonal': {
                const axes = [cell.a, cell.b, cell.c];
                const tol = 0.02;
                let uniqueAxis, repeatedAxis;
    
                if (Math.abs(axes[0] - axes[1]) < tol) { // a == b
                    uniqueAxis = axes[2];
                    repeatedAxis = axes[0];
                } else if (Math.abs(axes[0] - axes[2]) < tol) { // a == c
                    uniqueAxis = axes[1];
                    repeatedAxis = axes[0];
                } else { // b and c must be equal
                    uniqueAxis = axes[0];
                    repeatedAxis = axes[1];
                }
                newCell.a = repeatedAxis;
                newCell.b = repeatedAxis;
                newCell.c = uniqueAxis;
                break;
            }
            case 'orthorhombic': { const sorted = [cell.a, cell.b, cell.c].sort((x,y)=>x-y); newCell.a=sorted[0]; newCell.b=sorted[1]; newCell.c=sorted[2]; break; }
            case 'cubic': { newCell.b = newCell.a; newCell.c = newCell.a; break; }
        }
        return newCell;
    };
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const gcdOfList = (arr) => arr.length > 0 ? arr.reduce((acc, val) => gcd(acc, val), arr[0]) : 1;
    

// == Enforces crystallographic conventions to avoid listing
// == redundant equivalent reflections (e.g., (100) vs (010) in cubic).
// ==================================================================
const generateHKL_for_indexing = (maxTth, params, system) => {
     const { a, b, c, beta, lambda } = params; if (!a || !lambda) return []; const reflections = [];
     const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360)); const q_max_limit = (1 / (d_min * d_min)) * 1.05;
     const h_max = Math.ceil(a / d_min); 
     const k_max = b ? Math.ceil(b / d_min) : h_max; 
     const l_max = c ? Math.ceil(c / d_min) : h_max;
     
     if (system === 'monoclinic') {
        const sinBeta = Math.sin(beta*Math.PI/180); 
        const cosBeta = Math.cos(beta*Math.PI/180);
        const sinBetaSq = sinBeta * sinBeta;
        if (sinBetaSq < 1e-6) return []; // Invalid cell

        for (let h = -h_max; h <= h_max; h++) {
            for (let k = 0; k <= k_max; k++) { // k >= 0 is sufficient
                for (let l = -l_max; l <= l_max; l++) {
                    if (h === 0 && k === 0 && l === 0) continue;
                    
                    // Add uniqueness filter for monoclinic (k=0, h>0 or h=0,l>0)
                    if (k === 0) {
                        if (h < 0) continue;
                        if (h === 0 && l <= 0) continue;
                    }

                    const inv_d_sq = (1/sinBetaSq)*(h*h/(a*a)+l*l/(c*c)-2*h*l*cosBeta/(a*c))+k*k/(b*b); 
                    
                    if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue; 
                    const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                    if (sinThetaSq <= 1) { 
                        const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); 
                        reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)}); 
                    }
                }
            }
        }
     } else {
         // Original logic for all other systems
         for (let h = 0; h <= h_max; h++) { 
            for (let k = 0; k <= k_max; k++) {
                if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                for (let l = 0; l <= l_max; l++) { 
                    if (system === 'cubic' && l > k) continue;
                    if (h === 0 && k === 0 && l === 0) continue;

                    let inv_d_sq = 0;
                     switch (system) {
                         case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                         case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                         case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                         // monoclinic case removed from here
                     }
                     if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue; 
                     const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                     if (sinThetaSq <= 1) { 
                        const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); 
                        reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)}); 
                    }
                }
            }
        }
     }

     return reflections.sort((a, b) => a.tth - b.tth);
 };

    const findIndexedPeaksForSolution = (solution, tthError) => {
        const maxTth = Math.max(...peaks.map(p => p.tth));
        const theoreticalHKLs = generateHKL_for_indexing(maxTth, { ...solution, lambda: wavelength }, solution.system);
        if (!theoreticalHKLs || theoreticalHKLs.length === 0) return [];
        const indexedPeaks = []; const usedTheoreticalPeaks = new Set();
        for (const obsPeak of peaks) {
            let bestMatch = null; let minDiff = Infinity;
            for (let i = 0; i < theoreticalHKLs.length; i++) {
                if (usedTheoreticalPeaks.has(i)) continue;
                const diff = Math.abs(obsPeak.tth - theoreticalHKLs[i].tth);
                if (diff < minDiff) { minDiff = diff; bestMatch = { ...theoreticalHKLs[i], originalIndex: i }; }
            }
            if (bestMatch && minDiff < tthError) { indexedPeaks.push({ h: bestMatch.h, k: bestMatch.k, l: bestMatch.l }); usedTheoreticalPeaks.add(bestMatch.originalIndex); }
        }
        return indexedPeaks;
    };

    // --- CORE REFINEMENT AND ANALYSIS FUNCTIONS ---

    const generateHKL_for_worker = (cell) => {
    const { system, a, b, c, beta } = cell;
    const reflections = [];
    const q_max_limit = q_max * 1.05; // Use the global q_max from the worker's scope
    const h_max = Math.ceil((a || 0) / d_min);
    const k_max = Math.ceil((b || a || 0) / d_min);
    const l_max = Math.ceil((c || a || 0) / d_min);

    for (let h = -h_max; h <= h_max; h++) {
        for (let k = 0; k <= k_max; k++) { // k from 0
            for (let l = -l_max; l <= l_max; l++) {
                if (h === 0 && k === 0 && l === 0) continue;

                // Add uniqueness filter for monoclinic
                if (system === 'monoclinic' && k === 0) {
                    if (h < 0) continue;
                    if (h === 0 && l <= 0) continue;
                }

                let q_calc = 0;
                switch (system) {
                    case 'cubic':
                        q_calc = (h * h + k * k + l * l) / (a * a);
                        break;
                    case 'tetragonal':
                        q_calc = (h * h + k * k) / (a * a) + (l * l) / (c * c);
                        break;
                    case 'hexagonal':
                        q_calc = (4 / 3) * (h * h + h * k + k * k) / (a * a) + (l * l) / (c * c);
                        break;
                    case 'orthorhombic':
                        q_calc = (h * h) / (a * a) + (k * k) / (b * b) + (l * l) / (c * c);
                        break;
                    case 'monoclinic':
                        const sinBeta = Math.sin(beta * Math.PI / 180);
                        const cosBeta = Math.cos(beta * Math.PI / 180);
                        q_calc = (1 / (sinBeta * sinBeta)) * ((h * h) / (a * a) + (l * l) / (c * c) - (2 * h * l * cosBeta) / (a * c)) + (k * k) / (b * b);
                        break;
                }
                if (q_calc > 0 && q_calc <= q_max_limit) {
                    reflections.push({ q: q_calc, h, k, l });
                }
            }
        }
    }
    // Sort by q-value for efficient searching
    return reflections.sort((a, b) => a.q - b.q);
};

    const getQcalc = (hkl, cell) => {
        const [h, k, l] = hkl;
        const { a, b, c, beta, system } = cell;
        switch (system) {
            case 'cubic': return (h*h + k*k + l*l) / (a*a);
            case 'tetragonal': return (h*h + k*k) / (a*a) + (l*l) / (c*c);
            case 'hexagonal': return (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c);
            case 'orthorhombic': return h*h/(a*a) + k*k/(b*b) + l*l/(c*c);
            case 'monoclinic':
                const sinBeta = Math.sin(beta * Math.PI / 180), cosBeta = Math.cos(beta * Math.PI / 180);
                return (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
        }
        return 0;
    };
    
    const getLSDesignRow = (hkl, system) => {
        const [h, k, l] = hkl;
        switch(system) {
            case 'cubic': return [h*h + k*k + l*l];
            case 'tetragonal': return [h*h + k*k, l*l];
            case 'hexagonal': return [(4/3)*(h*h + h*k + k*k), l*l];
            case 'orthorhombic': return [h*h, k*k, l*l];
            case 'monoclinic': return [h*h, k*k, l*l, h*l];
        }
    };
    
    const extractCellFromFit = (params, system) => {
        let cell = { system, alpha: 90, gamma: 90 };
        try {
            if (params.some(p => isNaN(p))) return null;

            switch(system) {
    case 'cubic':
        if (params[0] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = cell.a;
        cell.beta = 90;
        break;

    case 'tetragonal':
        if (params[0] <= 0 || params[1] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = 1/Math.sqrt(params[1]);
        cell.beta = 90;
        break;

    case 'hexagonal':
        if (params[0] <= 0 || params[1] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = 1/Math.sqrt(params[1]);
        cell.beta = 90;
        cell.gamma = 120;
        break;

    case 'orthorhombic':
        if (params.slice(0, 3).some(p => p <= 0)) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = 1/Math.sqrt(params[1]);
        cell.c = 1/Math.sqrt(params[2]);
        cell.beta = 90;
        break;

    case 'monoclinic':
        const cell_params = params.slice(0, 4);
        let [A, B, C, D] = cell_params;
        
        // D*D >= 4*A*C is check for |cos(beta)| >= 1
        if (A <= 0 || B <= 0 || C <= 0 || D*D >= 4*A*C) return null;
        
        const cosBeta_calc = -D / (2 * Math.sqrt(A*C));
        if (Math.abs(cosBeta_calc) >= 1) return null;
        
        let beta_calc = Math.acos(cosBeta_calc) * 180 / Math.PI;

        // Enforce convention: beta >= 90
        // If beta is acute (< 90), flip it to the obtuse angle
        if (beta_calc < 90.0) {
            beta_calc = 180.0 - beta_calc;
        }

        // Now check the conventional beta (relaxed range)
        if (beta_calc < 90.0 || beta_calc > 150.0) return null;

        cell.beta = beta_calc;
        const sinBetaSq = Math.sin(cell.beta * Math.PI / 180)**2;
        
        if (sinBetaSq <= 1e-6) return null; // Avoid division by zero
        
        cell.a = 1/Math.sqrt(A * sinBetaSq);
        cell.b = 1/Math.sqrt(B);
        cell.c = 1/Math.sqrt(C * sinBetaSq);
        break;
}

        } catch { return null; }
        
        if (isNaN(cell.a) || isNaN(cell.b) || isNaN(cell.c) || isNaN(cell.beta)) return null;

        return cell;
    };
    
    const getVolume = (cell) => {
        const { a, b, c, beta, system } = cell;
        switch(system){
            case 'cubic': return a**3;
            case 'tetragonal': return a**2 * c;
            case 'hexagonal': return a**2 * c * Math.sqrt(3)/2;
            case 'orthorhombic': return a * b * c;
            case 'monoclinic': return a * b * c * Math.sin(beta * Math.PI / 180);
        }
    };
    
    const getSolutionKey = (cell) => {
        const P = 2;
        const std = standardizeCell(cell);
        switch(std.system) {
            case 'cubic': return `${std.system}_${std.a.toFixed(P)}`;
            case 'tetragonal': case 'hexagonal': return `${std.system}_${std.a.toFixed(P)}_${std.c.toFixed(P)}`;
            case 'orthorhombic': return `${std.system}_${[std.a,std.b,std.c].sort().map(p => p.toFixed(P)).join('_')}`;
            case 'monoclinic': return `${std.system}_${std.volume.toFixed(2)}_${std.beta.toFixed(2)}`;
        }
    };
    
    const get_q_tolerance = (original_peak_index) => {
        const theta_rad = tth_obs_rad[original_peak_index] / 2.0;
        const d_theta_rad = tth_error * Math.PI / 360;
        return ((8 * Math.sin(theta_rad) * Math.cos(theta_rad)) / (wavelength**2)) * d_theta_rad;
    };

    const binarySearchClosest = (arr, target) => {
        let low = 0, high = arr.length - 1;
        if (arr.length === 0 || target <= arr[low]) return 0;
        if (target >= arr[high]) return high;
        while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (arr[mid] < target) low = mid + 1; else high = mid - 1;
        }
        return (low >= arr.length) ? high : ((arr[low] - target) < (target - arr[high]) ? low : high);
    };
    
    const calculateM20 = (q_calc_sorted, q_obs_for_m20, original_indices_for_m20) => {
        if (!q_calc_sorted || q_calc_sorted.length === 0) return 0;
        let N_indexed = 0, sum_delta_q = 0;
        for (let i = 0; i < N_FOR_M20; i++) {
            const q_o = q_obs_for_m20[i];
            const tolerance = get_q_tolerance(original_indices_for_m20[i]);
            const diff = Math.abs(q_o - q_calc_sorted[binarySearchClosest(q_calc_sorted, q_o)]);
            if (diff < tolerance) { N_indexed++; sum_delta_q += diff; }
        }
        if (N_FOR_M20 - N_indexed > impurity_peaks || N_indexed === 0) return 0;
        const q_n = q_obs_for_m20[N_FOR_M20 - 1];
        let N_calc = q_calc_sorted.filter(q => q <= q_n * 1.05).length;
        if (N_calc === 0) return 0;
        const avg_delta_q = sum_delta_q / N_indexed;
        return avg_delta_q > 0 ? (q_n / (2 * avg_delta_q * N_calc)) : 0;
    };

    const solveLeastSquares = (M, q_vec, weights) => {
    const num_eq = M.length, num_params = M[0].length;
    if (num_eq < num_params) return null;

    // --- Create a diagonal weight matrix conceptually ---
    // If no weights are provided, default to an unweighted fit (all weights are 1)
    const w = weights || Array(num_eq).fill(1);
    
    // Pre-weight the design matrix M and the observation vector q_vec
    // This is equivalent to W*M and W*q_vec where W is a diagonal matrix
    const weighted_M = M.map((row, i) => row.map(val => val * w[i]));
    const weighted_q_vec = q_vec.map((q, i) => q * w[i]);
    
    // Standard least-squares calculations now use the weighted values
    const MT = Array(num_params).fill(0).map((_, i) => Array(num_eq).fill(0).map((_, j) => M[j][i]));
    
    // Calculate M_transpose * Weighted_M, which is equivalent to MᵀWM
    const MTWM = Array(num_params).fill(0).map((_, i) => 
        Array(num_params).fill(0).map((_, j) => 
            MT[i].reduce((s, v, k) => s + v * weighted_M[k][j], 0)
        )
    );
    
    const cofactor = (mat, r, c) => mat.slice(0, r).concat(mat.slice(r + 1)).map(row => row.slice(0, c).concat(row.slice(c + 1)));
    const determinant = (mat) => {
        if (mat.length === 0) return 1;
        if (mat.length === 1) return mat[0][0];
        if (mat.length === 2) return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
        return mat[0].reduce((sum, el, i) => sum + el * determinant(cofactor(mat, 0, i)) * (i % 2 === 0 ? 1 : -1), 0);
    };
    
    const det = determinant(MTWM);
    if (Math.abs(det) < 1e-12) return null; // Matrix is singular, no unique solution

    const adjugate = (mat) => {
        const n = mat.length;
        if (n === 1) return [[1]];
        const adj = Array(n).fill(0).map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                adj[j][i] = determinant(cofactor(mat, i, j)) * ((i + j) % 2 === 0 ? 1 : -1);
            }
        }
        return adj;
    };

    const invDet = 1.0 / det;
    const MTWM_inv = adjugate(MTWM).map(row => row.map(el => el * invDet));
    
    // Calculate M_transpose * Weighted_q_vec, which is MᵀWq
    const MTWq = Array(num_params).fill(0).map((_, i) => MT[i].reduce((s, v, j) => s + v * weighted_q_vec[j], 0));
    
    // The solution vector x = (MᵀWM)⁻¹ * (MᵀWq)
    const x = Array(num_params).fill(0).map((_, i) => MTWM_inv[i].reduce((s, v, j) => s + v * MTWq[j], 0));
    
    const df = num_eq - num_params;
    if (df <= 0) return { solution: x, covarianceMatrix: null };
    
    const q_calc = M.map(row => row.reduce((s, v, j) => s + v * x[j], 0));
    
    // ---Calculate the weighted sum of squared residuals ---
    const SSR = q_vec.reduce((sum, q_obs, i) => sum + w[i] * (q_obs - q_calc[i])**2, 0);
    
    // The covariance matrix V = (MᵀWM)⁻¹ * (SSR / df)
    const V = MTWM_inv.map(row => row.map(el => el * (SSR / df)));

    return { solution: x, covarianceMatrix: V };
};

    const propagateErrors = (system, fitResult, cell) => {
        if (!fitResult || !fitResult.covarianceMatrix) return {};
        const V = fitResult.covarianceMatrix, errors = {}, num_params = V.length;
        try {
            switch (system) {
                case 'cubic': errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0])); break;
                case 'tetragonal': case 'hexagonal':
                    errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_c = 0.5 * cell.c**3 * Math.sqrt(Math.abs(V[1][1]));
                    break;
                case 'orthorhombic':
                    errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_b = 0.5 * cell.b**3 * Math.sqrt(Math.abs(V[1][1]));
                    errors.s_c = 0.5 * cell.c**3 * Math.sqrt(Math.abs(V[2][2]));
                    break;
                case 'monoclinic':
                    const [A,B,C,D] = fitResult.solution;
                    errors.s_b = 0.5 * cell.b**3 * Math.sqrt(Math.abs(V[1][1]));
                    const betaRad = cell.beta*Math.PI/180, sinBeta=Math.sin(betaRad), sqrtAC=Math.sqrt(A*C);
                    const d_beta_d_A = (-1/sinBeta)*(D/(4*A*sqrtAC)), d_beta_d_C = (-1/sinBeta)*(D/(4*C*sqrtAC)), d_beta_d_D = (-1/sinBeta)*(-1/(2*sqrtAC));
                    errors.s_beta = Math.sqrt(Math.abs(d_beta_d_A**2*V[0][0] + d_beta_d_C**2*V[2][2] + d_beta_d_D**2*V[3][3] + 2*(d_beta_d_A*d_beta_d_C*V[0][2] + d_beta_d_A*d_beta_d_D*V[0][3] + d_beta_d_C*d_beta_d_D*V[2][3]))) * 180 / Math.PI;
                    errors.s_a = (cell.a / (2*A)) * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_c = (cell.c / (2*C)) * Math.sqrt(Math.abs(V[2][2]));
                    break;
            }
            const cell_param_count = { cubic: 1, tetragonal: 2, hexagonal: 2, orthorhombic: 3, monoclinic: 4 };
            if (num_params > cell_param_count[system]) {
                errors.s_zero = Math.sqrt(Math.abs(V[num_params - 1][num_params - 1])) * 180 / Math.PI;
            }
        } catch (e) { console.error("Error during propagation:", e); }
        return errors;
    };

    const hkl_search_list_cache = {};
    const get_hkl_search_list = (system) => {
        if (hkl_search_list_cache[system]) return hkl_search_list_cache[system];
        
        const hkls = [];
        const max_h = 6; // Max index for non-mono systems
        const max_mono = 4; // Max index for mono system

        if (system === 'monoclinic') {
            // --- Monoclinic ---
            // Needs k >= 0 and full h, l plane
            for (let h = -max_mono; h <= max_mono; h++) {
                for (let k = 0; k <= max_mono; k++) { // k >= 0
                    for (let l = -max_mono; l <= max_mono; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        // Enforce uniqueness convention
                        if (k === 0) {
                            if (h < 0) continue;
                            if (h === 0 && l <= 0) continue;
                        }
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'orthorhombic') {
            // --- Orthorhombic ---
            // All positive octant (h,k,l) are unique
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= max_h; k++) {
                    for (let l = 0; l <= max_h; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'tetragonal' || system === 'hexagonal') {
            // --- Tetragonal & Hexagonal ---
            // (hkl) equiv to (khl). Enforce h >= k >= 0. l is independent.
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= h; k++) { // k <= h
                    for (let l = 0; l <= max_h; l++) { // l is independent
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'cubic') {
            // --- Cubic ---
            // (hkl) equiv to all permutations. Enforce h >= k >= l >= 0.
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= h; k++) { // k <= h
                    for (let l = 0; l <= k; l++) { // l <= k
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        }
        
        // Sort by complexity (h^2+k^2+l^2)
        hkls.sort((a,b) => (a[0]*a[0]+a[1]*a[1]+a[2]*a[2])-(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]));
        return hkl_search_list_cache[system] = hkls;
    };

        const refineAndTestSolution = (initialParams) => {
    if (!initialParams || !initialParams.system) return;
    
    const min_lp = 2, max_lp = 50.0;
    const params_to_check = [];
    if (initialParams.a !== undefined) params_to_check.push(initialParams.a);
    if (initialParams.b !== undefined) params_to_check.push(initialParams.b);
    if (initialParams.c !== undefined) params_to_check.push(initialParams.c);

    if (params_to_check.some(p => (isNaN(p) || p < min_lp || p > max_lp))) {
        return; 
    }
    
    let candidate_cell = { ...initialParams }; 
    const { system } = initialParams;

    // --- STEP 1: Perform the initial indexing ---
    let initial_indexed_pairs = [];
    let initial_peak_indices = []; 
    
    const hkl_search_list = get_hkl_search_list(system); 
    
    for (let i = 0; i < N_FOR_M20; i++) {
        const q_o = q_obs[i], tolerance = get_q_tolerance(original_indices[i]);
        let best_match = null, min_diff = Infinity;
        
        for (const hkl of hkl_search_list) { 
            const q_calc = getQcalc(hkl, candidate_cell);
            const diff = Math.abs(q_calc - q_o);
            
            if (diff < min_diff) { 
                min_diff = diff; 
                best_match = hkl; 
            }
            
            if (system !== 'monoclinic' && q_calc > q_o + tolerance * 2) {
                 break; 
            }
        }
        
        if (best_match && min_diff < tolerance) {
            initial_indexed_pairs.push({ q_obs: q_o, hkl: best_match });
            initial_peak_indices.push(original_indices[i]);
        }
    }
    
    const min_indexed = { cubic: 4, tetragonal: 5, hexagonal: 5, orthorhombic: 6, monoclinic: 7 };
    
    if (initial_indexed_pairs.length < min_indexed[system]) {
        return;
    }
    
    // --- STEP 2: Perform Least-Squares Refinement ---
    // --- *** MODIFICATION: This block now ALWAYS runs *** ---
    let fitResult_no_zero = null;
    const q_vec_initial = initial_indexed_pairs.map(p => p.q_obs);

    // 1. Build a design matrix *with* a zero-error column
    let M_with_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
    M_with_zero.forEach((row, i) => {
        const tth_rad = tth_obs_rad[initial_peak_indices[i]];
        row.push((2 / (wavelength**2)) * Math.sin(tth_rad));
    });

    // 2. Solve for cell params *and* zero error
    const fitResult_with_zero = solveLeastSquares(M_with_zero, q_vec_initial, q_vec_initial);

    if (fitResult_with_zero && fitResult_with_zero.solution) {
        // 3. Get the initial zero correction (in degrees)
        let initial_zero_correction_rad = fitResult_with_zero.solution[fitResult_with_zero.solution.length - 1];
        let initial_zero_correction_deg = initial_zero_correction_rad * 180 / Math.PI;

        // 4. LIMIT the correction to the tth_error tolerance
        initial_zero_correction_deg = Math.max(-tth_error, Math.min(tth_error, initial_zero_correction_deg));
        
        // 5. Apply this *limited* correction to the observed q values
        const q_vec_corrected = [];
        for (let i = 0; i < initial_indexed_pairs.length; i++) {
            const original_tth_deg = tth_obs_rad[initial_peak_indices[i]] * 180 / Math.PI;
            const corrected_tth_rad = (original_tth_deg - initial_zero_correction_deg) * Math.PI / 180;
            const corrected_q = (4 * Math.sin(corrected_tth_rad / 2)**2) / (wavelength**2);
            q_vec_corrected.push(corrected_q);
        }

        // 6. Now solve *only* for cell params using the corrected q values
        let M_no_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
        fitResult_no_zero = solveLeastSquares(M_no_zero, q_vec_corrected, q_vec_corrected);
    }
    
    // Fallback: If the zero-refinement failed, run the original (non-zero-corrected) refinement.
    if (!fitResult_no_zero) {
        let M_no_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
        fitResult_no_zero = solveLeastSquares(M_no_zero, q_vec_initial, q_vec_initial);
    }
    // --- *** END OF MODIFICATION *** ---

    if (!fitResult_no_zero || !fitResult_no_zero.solution) {
        return;
    }
    
    const initial_cell = extractCellFromFit(fitResult_no_zero.solution, system);
    if (!initial_cell) {
        return;
    }

    initial_cell.volume = getVolume(initial_cell);
    if (initial_cell.volume > max_volume || initial_cell.volume < 20) {
        return;
    }

    // --- STEP 3: Validate the refined cell with an M(20) score ---
    const q_calc_set = new Set(generateHKL_for_worker(initial_cell).map(r => r.q));
    const q_calc_sorted = new Float64Array(Array.from(q_calc_set)).sort((a,b)=>a-b);
    const m20 = calculateM20(q_calc_sorted, q_obs, original_indices);
    
    if (m20 <= min_m20) {
        return;
    }

    let final_solution_to_post = initial_cell;
    final_solution_to_post.m20 = m20;
    final_solution_to_post.errors = propagateErrors(system, fitResult_no_zero, initial_cell);
    
    // --- STEP 4: Perform the FINAL refinement WITH zero error, ONLY if the user enabled it ---
    if (refineZero) {
        const all_possible_reflections = generateHKL_for_worker(initial_cell);
        const final_indexed_pairs = [];
        const final_peak_indices_for_ls = [];
        const used_reflections = new Set();

        for (let i = 0; i < N_FOR_M20; i++) { 
            const q_o = q_obs[i];
            const tolerance = get_q_tolerance(original_indices[i]);
            let best_match_idx = -1, min_diff = Infinity;

            for (let j = 0; j < all_possible_reflections.length; j++) {
                const diff = Math.abs(all_possible_reflections[j].q - q_o);
                if (diff < min_diff) {
                    min_diff = diff;
                    best_match_idx = j;
                }
            }

            if (best_match_idx !== -1 && min_diff < tolerance && !used_reflections.has(best_match_idx)) {
                const {h, k, l} = all_possible_reflections[best_match_idx];
                final_indexed_pairs.push({ q_obs: q_o, hkl: [h, k, l] });
                final_peak_indices_for_ls.push(original_indices[i]);
                used_reflections.add(best_match_idx);
            }
        }
        
        if (final_indexed_pairs.length > min_indexed[system]) {
            let M_with_zero_final = final_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
            const q_vec_final = final_indexed_pairs.map(p => p.q_obs);
            M_with_zero_final.forEach((row, i) => {
                const tth_rad = tth_obs_rad[final_peak_indices_for_ls[i]];
                row.push((2 / (wavelength**2)) * Math.sin(tth_rad));
            });

            const fitResult_with_zero_final = solveLeastSquares(M_with_zero_final, q_vec_final, q_vec_final);
            
            if (fitResult_with_zero_final && fitResult_with_zero_final.solution) {
                const refined_cell = extractCellFromFit(fitResult_with_zero_final.solution, system);
                if (refined_cell) {
                    refined_cell.zero_correction = fitResult_with_zero_final.solution[fitResult_with_zero_final.solution.length - 1] * 180 / Math.PI;
                    refined_cell.volume = getVolume(refined_cell);
                    
                    const q_calc_set_refined = new Set(generateHKL_for_worker(refined_cell).map(r => r.q));
                    const q_calc_sorted_refined = new Float64Array(Array.from(q_calc_set_refined)).sort((a,b)=>a-b);
                    const q_obs_for_m20_refined = new Float64Array(peaks_sorted_by_q.map(p => {
                        const corrected_tth_rad = (peaks[p.original_index].tth - refined_cell.zero_correction) * Math.PI / 180;
                        return (4 * Math.sin(corrected_tth_rad / 2)**2) / (wavelength**2);
                    }));
                    const final_m20 = calculateM20(q_calc_sorted_refined, q_obs_for_m20_refined, original_indices);
                    
                    if (final_m20 > min_m20) {
                        refined_cell.m20 = final_m20;
                        refined_cell.errors = propagateErrors(system, fitResult_with_zero_final, refined_cell);
                        final_solution_to_post = refined_cell; 
                    }
                }
            }
        }
    }

    // --- STEP 5: Post the best found solution to the UI ---
    const key = getSolutionKey(final_solution_to_post);
    const existing = foundSolutionMap.get(key);
    if (!existing || final_solution_to_post.m20 > existing.m20) {
        self.postMessage({ type: 'solution', payload: final_solution_to_post });
        if (existing) {
            foundSolutions[existing.index] = final_solution_to_post;
        } else {
            foundSolutions.push(final_solution_to_post);
        }
        foundSolutionMap.set(key, { m20: final_solution_to_post.m20, index: existing ? existing.index : foundSolutions.length - 1 });
    }
};



    // --- SEARCH ALGORITHMS 
    const indexCubic = () => {
        const h_max = 8;
        const totalIterations = Math.min(peaks.length, 10);
        if (totalIterations === 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) { 
            for (let h = 1; h <= h_max; h++) {
                for (let k = 0; k <= h; k++) {
                    for (let l = 0; l <= k; l++) {
                        if (!h && !k && !l) continue;
                        refineAndTestSolution({ a: Math.sqrt((h * h + k * k + l * l) / q_obs[i]), system: 'cubic' });
                    }
                }
            }
            // Report progress based on the outer loop
            const progress = ((i + 1) / totalIterations) * 80; // Scale to 80% (20% for transforms)
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };

    const indexTetragonalOrHexagonal = (system) => {
        const max_hkl = 5, i_depth = Math.min(10, peaks.length), j_depth = Math.min(10, peaks.length);
        // --- MODIFIED ---
        const totalIterations = i_depth;
        if (totalIterations === 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) { // <-- MODIFIED
            for (let j = i + 1; j < j_depth; j++) {
                for (let h1 = 0; h1 <= max_hkl; h1++) for (let k1 = 0; k1 <= h1; k1++) for (let l1 = 0; l1 <= max_hkl; l1++) {
                    if (!h1 && !k1 && !l1) continue;
                    const S1 = system === 'tetragonal' ? h1 * h1 + k1 * k1 : h1 * h1 + h1 * k1 + k1 * k1;
                    for (let h2 = 0; h2 <= max_hkl; h2++) for (let k2 = 0; k2 <= h2; k2++) for (let l2 = 0; l2 <= max_hkl; l2++) {
                        if (!h2 && !k2 && !l2) continue;
                        const S2 = system === 'tetragonal' ? h2 * h2 + k2 * k2 : h2 * h2 + h2 * k2 + k2 * k2;
                        const det = S1 * l2 * l2 - S2 * l1 * l1;
                        if (Math.abs(det) < 1e-6) continue;
                        const a_term_inv = (q_obs[i] * l2 * l2 - q_obs[j] * l1 * l1) / det, c_term_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                        if (a_term_inv > 0 && c_term_inv > 0) {
                            const a = system === 'tetragonal' ? 1 / Math.sqrt(a_term_inv) : Math.sqrt(4 / (3 * a_term_inv));
                            refineAndTestSolution({ a: a, c: 1 / Math.sqrt(c_term_inv), system });
                        }
                    }
                }
            }
            const progress = ((i + 1) / totalIterations) * 80; 
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };

    const indexOrthorhombic = () => {
        const max_p = Math.min(10, q_obs.length), basis_hkls = get_hkl_search_list('orthorhombic').slice(0, 30);
        const totalIterations = max_p - 2;
        if (totalIterations <= 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) { 
            for (let j = i + 1; j < max_p - 1; j++) {
                for (let k = j + 1; k < max_p; k++) {
                    for (let n1 = 0; n1 < basis_hkls.length - 2; n1++) for (let n2 = n1 + 1; n2 < basis_hkls.length - 1; n2++) for (let n3 = n2 + 1; n3 < basis_hkls.length; n3++) {
                        const M = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]].map(hkl => [hkl[0] ** 2, hkl[1] ** 2, hkl[2] ** 2]);
                        const q_vec_for_guess = [q_obs[i], q_obs[j], q_obs[k]];
                        const fit = solveLeastSquares(M, q_vec_for_guess, q_vec_for_guess);

                        if (fit && fit.solution && fit.solution.every(s => s > 0)) {
                            refineAndTestSolution({ a: 1 / Math.sqrt(fit.solution[0]), b: 1 / Math.sqrt(fit.solution[1]), c: 1 / Math.sqrt(fit.solution[2]), system: 'orthorhombic' });
                        }
                    }
                }
            }
            // 
            const progress = ((i + 1) / totalIterations) * 80; // Scale to 80%
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };


    // Helper function for indexMonoclinic
const generateBasisHKLs = (max_index = 3) => {
    const hkls = [];
    // Generate h,k,l up to max_index
    for (let h = -max_index; h <= max_index; h++) {
        for (let k = 0; k <= max_index; k++) { // k >= 0
            for (let l = -max_index; l <= max_index; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                
                // Enforce monoclinic uniqueness
                if (k === 0) {
                    if (h < 0) continue;
                    if (h === 0 && l <= 0) continue;
                }
                hkls.push([h, k, l]);
            }
        }
    }
    // Sort by complexity (sum of h^2+k^2+l^2)
    hkls.sort((a,b) => (a[0]*a[0]+a[1]*a[1]+a[2]*a[2]) - (b[0]*b[0]+b[1]*b[1]+b[2]*b[2]));
    return hkls;
};


// Improved indexMonoclinic
const indexMonoclinic = (opts = {}) => {
    // Options (override if needed)
    // --- INCREASED DEFAULTS ---
    const MAX_BASIS = opts.maxBasis || 50;        // max basis size to use (was 30)
    const MAX_PEAKS = opts.maxPeaks || 20;       // use first N peaks (was 12)
    // ---
    const SAMPLE_COMBINATIONS = opts.sampleCombinations || false; // sample instead of exhaustive
    const SAMPLE_TRIES = opts.sampleTries || 20000; // if sampling, how many random tries
    const MIN_DET = opts.minDeterminant || 1e-8; // threshold for degenerate M
    const CELL_LIMITS = opts.cellLimits || { a: [0.5, 50], b: [0.5, 50], c: [0.5, 50] }; // plausible Å ranges

    // 1) Decide peaks to use
    const max_p = Math.min(MAX_PEAKS, q_obs.length);
    if (max_p < 4) return;

    // 2) Define HKL basis (expanded).
    // --- NEW DYNAMIC LIST ---
    const basis_hkls_full = generateBasisHKLs(3); // Generate hkls up to index 3
    const basis_hkls = basis_hkls_full.slice(0, Math.min(basis_hkls_full.length, MAX_BASIS));
    // ---

    const num_hkls = basis_hkls.length;
    if (num_hkls < 4) return;

    // Helper: check if two HKLs are linearly dependent / duplicates (simple check)
    const isDuplicateHKL = (hkl1, hkl2) => {
        // trivial equality
        if (hkl1[0] === hkl2[0] && hkl1[1] === hkl2[1] && hkl1[2] === hkl2[2]) return true;
        // proportional check (avoid zero)
        const a = hkl1[0], b = hkl1[1], c = hkl1[2];
        const x = hkl2[0], y = hkl2[1], z = hkl2[2];
        // if one is zero vector, treat as duplicate (degenerate)
        if ((a===0 && b===0 && c===0) || (x===0 && y===0 && z===0)) return true;
        // ratio approach but guard zeros:
        let r = null;
        const pairs = [[a,x],[b,y],[c,z]];
        for (const [p,q] of pairs) {
            if (q === 0) {
                if (p !== 0) return false;
                continue;
            }
            if (r === null) r = p / q;
            else if (Math.abs(r - p/q) > 1e-8) return false;
        }
        return true;
    };

    // Helper: build M (4x4) from 4 hkls where Q = A*h^2 + B*k^2 + C*l^2 + D*h*l
    const buildM = (hkls) => hkls.map(hkl => [hkl[0]*hkl[0], hkl[1]*hkl[1], hkl[2]*hkl[2], hkl[0]*hkl[2]]);

    // Robust 4x4 solver using Gaussian elimination with partial pivoting
    const solve4x4 = (A, b) => {
        // A: array of 4 arrays (length 4), b: length 4
        // Work on copies
        const M = A.map(r => r.slice());
        const v = b.slice();
        const n = 4;
        const idx = Array.from({length:n}, (_,i)=>i);

        let det = 1;
        for (let i = 0; i < n; i++) {
            // partial pivot
            let maxRow = i;
            let maxVal = Math.abs(M[i][i]);
            for (let r = i+1; r < n; r++) {
                const val = Math.abs(M[r][i]);
                if (val > maxVal) { maxVal = val; maxRow = r; }
            }
            if (maxVal < 1e-14) {
                return null; // singular or nearly singular
            }
            if (maxRow !== i) {
                [M[i], M[maxRow]] = [M[maxRow], M[i]];
                [v[i], v[maxRow]] = [v[maxRow], v[i]];
                det = -det;
            }
            const pivot = M[i][i];
            det *= pivot;
            // normalize and eliminate
            for (let r = i+1; r < n; r++) {
                const fac = M[r][i] / pivot;
                for (let c = i; c < n; c++) M[r][c] -= fac * M[i][c];
                v[r] -= fac * v[i];
            }
        }

        if (Math.abs(det) < MIN_DET) return null;

        // back substitution
        const x = new Array(n).fill(0);
        for (let i = n-1; i >= 0; i--) {
            let s = v[i];
            for (let j = i+1; j < n; j++) s -= M[i][j] * x[j];
            x[i] = s / M[i][i];
        }
        return { solution: x, det };
    };

    // Simple plausibility test for the extracted cell
    const plausibleCellCheck = (cell) => {
        if (!isFinite(cell.a) || !isFinite(cell.b) || !isFinite(cell.c) || !isFinite(cell.beta)) return false;
        if (cell.a <= 0 || cell.b <= 0 || cell.c <= 0) return false;
        if (cell.beta <= 0 || cell.beta >= 180) return false;
        if (cell.a < CELL_LIMITS.a[0] || cell.a > CELL_LIMITS.a[1]) return false;
        if (cell.b < CELL_LIMITS.b[0] || cell.b > CELL_LIMITS.b[1]) return false;
        if (cell.c < CELL_LIMITS.c[0] || cell.c > CELL_LIMITS.c[1]) return false;
        return true;
    };

    // Prepare combinations generator (exhaustive or sampling)
    const combos = [];
    if (!SAMPLE_COMBINATIONS) {
        // Exhaustive indices for 4 peaks
        for (let i = 0; i < max_p - 3; i++) {
            for (let j = i + 1; j < max_p - 2; j++) {
                for (let k = j + 1; k < max_p - 1; k++) {
                    for (let l = k + 1; l < max_p; l++) {
                        combos.push([i,j,k,l]);
                    }
                }
            }
        }
    } else {
        // Random sampling of peak-quads
        const rng = () => Math.floor(Math.random() * max_p);
        for (let t = 0; t < SAMPLE_TRIES; t++) {
            let s = new Set();
            while (s.size < 4) s.add(rng());
            const arr = Array.from(s).sort((a,b)=>a-b);
            combos.push(arr);
        }
    }

    // For progress:
    const totalProgressIterations = combos.length || 1;
    let progressCount = 0;

    // Now loop: for each 4-peak combination, pick 4 hkls from basis
    // To avoid combinatorial explosion when basis is large, we can sample HKL combos too if necessary.
    const hklsCombosLimit = 200000; // safety limit before sampling HKL combos
    const allHKLCombos = [];
    // If small enough, build exhaustive list of hkl index quadruples
    const estimatedHKLQuads = (num_hkls * (num_hkls-1) * (num_hkls-2) * (num_hkls-3)) / 24;
    const hklsShouldSample = estimatedHKLQuads > hklsCombosLimit;

    // Precompute HKL combos (either exhaustive or will sample inside loop)
    if (!hklsShouldSample) {
        for (let n1 = 0; n1 < num_hkls - 3; n1++) {
            for (let n2 = n1 + 1; n2 < num_hkls - 2; n2++) {
                for (let n3 = n2 + 1; n3 < num_hkls - 1; n3++) {
                    for (let n4 = n3 + 1; n4 < num_hkls; n4++) {
                        allHKLCombos.push([n1,n2,n3,n4]);
                    }
                }
            }
        }
    }

    // Main loops
    for (const peakIndices of combos) {
        // early exit not used (we must run now)
        // For each selection of hkl quadruples (either exhaustive or sampled ones)
        const hklsIter = hklsShouldSample ? (() => {
            // generator that yields a limited number of random HKL quadruples
            const tries = Math.min(5000, SAMPLE_TRIES); // cap per peak-quad
            const yielded = [];
            for (let t = 0; t < tries; t++) {
                const pick = [];
                while (pick.length < 4) {
                    const r = Math.floor(Math.random() * num_hkls);
                    if (!pick.includes(r)) pick.push(r);
                }
                pick.sort((a,b)=>a-b);
                yielded.push(pick);
            }
            return yielded;
        })() : allHKLCombos;

        for (const [n1,n2,n3,n4] of hklsIter) {
            // quick duplicate hkl rejection
            const h1 = basis_hkls[n1], h2 = basis_hkls[n2], h3 = basis_hkls[n3], h4 = basis_hkls[n4];
            if (isDuplicateHKL(h1,h2) || isDuplicateHKL(h1,h3) || isDuplicateHKL(h1,h4) ||
                isDuplicateHKL(h2,h3) || isDuplicateHKL(h2,h4) || isDuplicateHKL(h3,h4)) continue;

            // Build M and q
            const hkls = [h1,h2,h3,h4];
            const M = buildM(hkls);
            const q_vec_for_guess = [ q_obs[peakIndices[0]], q_obs[peakIndices[1]],
                                      q_obs[peakIndices[2]], q_obs[peakIndices[3]] ];

            // Solve M * x = q
            const fit = solve4x4(M, q_vec_for_guess);
            if (!fit) continue;

            const [P1, P2, P3, P4] = fit.solution; // P1->A, P2->B, P3->C, P4->D (per your formula)

            // Physical checks: A,B,C positive
            if (!(P1 > 0 && P2 > 0 && P3 > 0)) continue;

            // From the standard monoclinic (unique b) reciprocal-lattice/d-spacing formula:
            // Q = P1*h^2 + P2*k^2 + P3*l^2 + P4*h*l
            // Where:
            // P1 = 1 / (a^2 * sin^2(beta))
            // P2 = 1 / b^2
            // P3 = 1 / (c^2 * sin^2(beta))
            // P4 = -2 * cos(beta) / (a * c * sin^2(beta))
            
            const A = P1, B = P2, C = P3, D = P4;

            // compute cos(beta)
            const denom = 2 * Math.sqrt(A * C);
            if (!isFinite(denom) || Math.abs(denom) < 1e-14) continue;
            
            const cosBeta = -D / denom; // cos(beta) = -P4 / (2 * sqrt(P1*P3))
            
            if (!isFinite(cosBeta) || Math.abs(cosBeta) > 1 - 1e-6) continue; // must be < 1

            // clamp to [-1,1]
            const cosB_clamped = Math.max(-1, Math.min(1, cosBeta));
            const betaRad = Math.acos(cosB_clamped);
            const beta = betaRad * 180 / Math.PI;
            const sinBetaSq = 1 - cosB_clamped * cosB_clamped;

            // Check for sin(beta) being near zero
            if (sinBetaSq < 1e-6) continue;

            // --- *** THIS IS THE CRITICAL FIX *** ---
            // compute lattice parameters a,b,c
            const a = 1 / Math.sqrt(A * sinBetaSq);
            const b = 1 / Math.sqrt(B);
            const c = 1 / Math.sqrt(C * sinBetaSq);
            // --- *** END FIX *** ---

            // quick plausibility filters
            const trialCell = { a, b, c, beta, system: 'monoclinic' };

            if (!plausibleCellCheck(trialCell)) continue;

            // --- *** ADDED CONSOLE LOG *** ---
//if (Math.abs(a - 11.243) < 0.56 && Math.abs(b - 8.195) < 0.41 && Math.abs(c - 19.949) < 1.00 && Math.abs(beta - 106.728) < 5.34) { console.log(`[Worker] NEAR TARGET: a=${a.toFixed(3)}, b=${b.toFixed(3)}, c=${c.toFixed(3)}, beta=${beta.toFixed(3)} -- (Peaks: ${peakIndices.join(',')}, HKLs: ${n1},${n2},${n3},${n4})`); }
            // --- *** END LOG *** ---

            // Pass to refinement and testing (user's existing routine)
            try {
                refineAndTestSolution(trialCell);
            } catch (e) {
                // keep going if refinement throws
                console.warn('refineAndTestSolution threw', e);
            }
        } // end hkls selection

        // Progress reporting (scale to 80% like your original)
        progressCount++;
        const progress = (progressCount / totalProgressIterations) * 80;
        self.postMessage({ type: 'progress', payload: progress });
    } // end peak combos

    // finish progress at 100%
    self.postMessage({ type: 'progress', payload: 100 });
};


// Helper function to calculate 3x3 determinant
function calculateDeterminant3x3(M) {
    return M[0][0] * (M[1][1]*M[2][2] - M[1][2]*M[2][1]) -
           M[0][1] * (M[1][0]*M[2][2] - M[1][2]*M[2][0]) +
           M[0][2] * (M[1][0]*M[2][1] - M[1][1]*M[2][0]);
}

// Helper function to validate cell parameters
function isValidCellParams(a, b, c, beta) {
    // Check for reasonable cell dimensions (e.g., 2-50 Angstroms)
    if (a < 2 || a > 50 || b < 2 || b > 50 || c < 2 || c > 50) return false;
    
    // Check beta is in valid range for monoclinic (typically 90° < beta < 180°)
    if (beta < 70 || beta > 110) return false;
    
    // Check all values are finite
    if (!isFinite(a) || !isFinite(b) || !isFinite(c) || !isFinite(beta)) return false;
    
    return true;
}

// --- DERIVED/TRANSFORMED CELL SEARCH (MODIFIED) ---
const findTransformedSolutions = (initialSolutions) => {
        const cellTransforms = [ { P: [[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]] }, { P: [[-0.5, 0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, -0.5]] }, { P: [[0.5, 0.5, 0], [-0.5, 0.5, 0], [0, 0, 1]] }, { P: [[0.5, 0, 0], [0, 1, 0], [0, 0, 1]] }, { P: [[1, 0, 0], [0, 0.5, 0], [0, 0, 1]] }, { P: [[1, 0, 0], [0, 1, 0], [0, 0, 0.5]] }, { P: [[0.5, -0.5, 0], [0.5, 0.5, 0], [0, 0, 1]] } ];
        const totalSolutions = initialSolutions.length;
        if (totalSolutions === 0) return;

        initialSolutions.forEach((sol, index) => {
            // --- 1. Original Transformations ---
            cellTransforms.forEach(tf => {
                try {
                    const G = metricFromCell(sol); const Pt = transpose(tf.P); const Gprime = matMul(matMul(Pt, G), tf.P);
                    const candCell = cellFromMetric(Gprime);
                    const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
                    if (allowedSystems.includes(newSystem)) refineAndTestSolution({ ...candCell, system: newSystem });
                } catch {}
            });
            
            const indexedPeaks = []; // Re-index for GCD and Ortho-Hexagonal checks
            const theoretical_hkls_for_tf = generateHKL_for_worker(sol);
            for(let i=0; i<N_FOR_M20; i++){
                 const q_o = q_obs[i];
                 const best_match_idx = binarySearchClosest(theoretical_hkls_for_tf.map(h => h.q), q_o);
                 if(Math.abs(q_o - theoretical_hkls_for_tf[best_match_idx].q) < get_q_tolerance(original_indices[i])){
                     indexedPeaks.push(theoretical_hkls_for_tf[best_match_idx]);
                 }
            }

            if (indexedPeaks.length > 5) {
                const h_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.h)).filter(h => h > 0));
                const k_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.k)).filter(k => k > 0));
                const l_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.l)).filter(l => l > 0));
                if (h_div > 1 || k_div > 1 || l_div > 1) {
                    const candCell = { ...sol, a: sol.a/h_div, b: (sol.b??sol.a)/k_div, c:(sol.c??sol.a)/l_div };
                    const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
                    if (allowedSystems.includes(newSystem)) refineAndTestSolution({ ...candCell, system: newSystem });
                }
            }
            if (sol.system === 'orthorhombic' && allowedSystems.includes('hexagonal')) {
                const axes = { a: sol.a, b: sol.b, c: sol.c }; const pairs = [['a','b','c'], ['a','c','b'], ['b','c','a']];
                pairs.forEach(([ax1, ax2, unique_ax]) => {
                    if (Math.abs(axes[ax2] / axes[ax1] / Math.sqrt(3) - 1) < 0.03) {
                        refineAndTestSolution({ system: 'hexagonal', a: axes[ax1], c: axes[unique_ax], beta: 90, gamma: 120 });
                    }
                });
            }

            // --- 2. "Swap Fishing" Strategy ---
            try {
                const system = sol.system;
                const min_peaks_needed = {cubic: 1, tetragonal: 2, hexagonal: 2, orthorhombic: 3, monoclinic: 4}[system];
                if (!min_peaks_needed || peaks.length < min_peaks_needed) return;

                const theoretical_hkls = generateHKL_for_worker(sol);
                const first_four_indexed = [];
                for(let i=0; i<4 && i < q_obs.length; i++){
                    const q_o = q_obs[i];
                    const best_match_idx = binarySearchClosest(theoretical_hkls.map(h => h.q), q_o);
                    if(Math.abs(q_o - theoretical_hkls[best_match_idx].q) < get_q_tolerance(original_indices[i])){
                        first_four_indexed.push({q_obs: q_o, hkl: [theoretical_hkls[best_match_idx].h, theoretical_hkls[best_match_idx].k, theoretical_hkls[best_match_idx].l]});
                    }
                }
                if (first_four_indexed.length < min_peaks_needed) return;

                let closest_pair = {i: -1, j: -1, diff: Infinity};
                for(let i=0; i<first_four_indexed.length; i++){
                    for(let j=i+1; j<first_four_indexed.length; j++){
                        const diff = Math.abs(first_four_indexed[i].q_obs - first_four_indexed[j].q_obs);
                        if(diff < closest_pair.diff){
                            closest_pair = {i, j, diff};
                        }
                    }
                }
                
                if(closest_pair.i !== -1){
                    const swapped_indexed_peaks = JSON.parse(JSON.stringify(first_four_indexed));
                    const temp_hkl = swapped_indexed_peaks[closest_pair.i].hkl;
                    swapped_indexed_peaks[closest_pair.i].hkl = swapped_indexed_peaks[closest_pair.j].hkl;
                    swapped_indexed_peaks[closest_pair.j].hkl = temp_hkl;
                    
                    const peaks_for_solve = swapped_indexed_peaks.slice(0, min_peaks_needed);
                    const M = peaks_for_solve.map(p => getLSDesignRow(p.hkl, system));
                    const q_vec = peaks_for_solve.map(p => p.q_obs);

                    const fit = solveLeastSquares(M, q_vec);
                    if(fit && fit.solution){
                        const new_trial_cell = extractCellFromFit(fit.solution, system);
                        if(new_trial_cell){
                           refineAndTestSolution(new_trial_cell);
                        }
                    }
                }
            } catch (e) {
                console.warn("Swap-fishing attempt failed:", e);
            }

            const progress = 80 + ((index + 1) / totalSolutions) * 15;
            self.postMessage({ type: 'progress', payload: progress });
        });
    };
       


    // --- EXECUTION & REPORTING (MODIFIED) ---
    postMessage({ type: 'status', payload: `Searching for ${systemToSearch} cells...` });
    self.postMessage({ type: 'progress', payload: 1 }); // Start at 1%

    if (systemToSearch === 'cubic') indexCubic();
    if (systemToSearch === 'tetragonal') indexTetragonalOrHexagonal('tetragonal');
    if (systemToSearch === 'hexagonal') indexTetragonalOrHexagonal('hexagonal');
    if (systemToSearch === 'orthorhombic') indexOrthorhombic();
    if (systemToSearch === 'monoclinic') indexMonoclinic();
    
    self.postMessage({ type: 'progress', payload: 80 });
    postMessage({ type: 'status', payload: `Analyzing transformations for ${systemToSearch}...` });
  
    findTransformedSolutions([...foundSolutions]);
    
  
    // Mark transform phase as 95% complete
    self.postMessage({ type: 'progress', payload: 95 });
    postMessage({ type: 'status', payload: `Analyzing ${systemToSearch}...` });
    // ---
    
    foundSolutions.forEach(solution => self.postMessage({ type: 'solution', payload: solution }));
  
    // Mark as 100% complete just before sending 'done'
    self.postMessage({ type: 'progress', payload: 100 });
    self.postMessage({ type: 'done' });
    // ---
};


</script>

<div id="app-footer">Combs, version 21 oct 2025</div>
</body>
</html>
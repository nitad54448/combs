<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combs-Powder Indexing</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #1a73e8;
            --primary-accent-hover: #1765cc;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
            --led-gray: #6b7280;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        
        #controls-panel { 
            width: 400px; min-width: 300px; max-width: 700px; flex-shrink: 0; 
            padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); 
            overflow-y: visible; color: var(--text-medium); display: flex; flex-direction: column;
            position: relative;
            z-index: 20;
        }
        
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        
        #results-area { 
            flex-grow: 1; position: relative; background-color: #ffffff; 
            min-width: 0; display: flex; flex-direction: column; 
            padding: 1.5rem; color: var(--medium-bg);
            z-index: 10;
        }

        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.35rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .control-input:read-only { background-color: var(--medium-bg); opacity: 0.7; }
 
        .btn-like {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }

        .btn {
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }

        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--light-bg); color: var(--text-light); border-color: var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: #4a5568; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }

        .file-input-label {
            background-color: var(--border-color);
            color: var(--text-medium);
        }
        .file-input-label:hover { background-color: #6b7280; }
        .file-input-label.error { border: 1px solid var(--error-red); color: var(--error-red); }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}
        .checkbox-label input:disabled + span { opacity: 0.5; cursor: not-allowed; }
        .checkbox-label input:disabled { cursor: not-allowed; }


        input[type="checkbox"] {
            accent-color: var(--primary-accent);
            transform: scale(1.1);
            vertical-align: middle; 
        }
        .hidden { display: none !important; }

        /* Tab Styles */
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
        .tab-btn { flex: 1; padding: 0.75rem 0.5rem; background: none; border: none; color: var(--text-dark); font-weight: 600; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .tab-btn:hover { color: var(--text-light); }
        .tab-btn.active { color: var(--primary-accent); border-bottom-color: var(--primary-accent); }
        .tab-content-panels { flex-grow: 1; min-height: 0; position: relative; }
        .tab-content-panel { display: none; flex-direction: column; height: 100%; overflow-y: auto; padding-right: 8px; margin-right: -8px;}
        .tab-content-panel.active { display: flex; }
        .tab-content-panel::-webkit-scrollbar { width: 6px; }
        .tab-content-panel::-webkit-scrollbar-track { background: var(--dark-bg); }
        .tab-content-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        .tab-content-panel::-webkit-scrollbar-thumb:hover { background: var(--light-bg); }
        #solutions-tab-content .control-group { flex-grow: 1; display: flex; flex-direction: column; margin-bottom: 0;}
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); }

        /* --- LED Indicator Styles --- */
        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        .led-indicator.gray { background-color: var(--led-gray); }
        .led-indicator.green { background-color: var(--success-green); box-shadow: 0 0 5px var(--success-green);}
        .led-indicator.red { background-color: var(--error-red); box-shadow: 0 0 5px var(--error-red); }

        #peak-table-container {
            overflow-y: auto;
            background-color: var(--medium-bg);
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            margin-top: 1rem;
        }
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; position: sticky; top: 0; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .peak-table th, .peak-table td, .peak-table input { text-align: center; }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }

        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle;}
        .solutions-table th { background-color: #2a3547; font-weight: 600; position: sticky; top: 0;}
        .solutions-table th[data-sort] { cursor: pointer; } 
        .solutions-table th[data-sort]:hover { background-color: var(--light-bg); }
        .solutions-table th.sort-asc::after,
        .solutions-table th.sort-desc::after {
            content: ''; display: inline-block; margin-left: 5px; width: 0; height: 0;
            border-left: 4px solid transparent; border-right: 4px solid transparent;
        }
        .solutions-table th.sort-asc::after { border-bottom: 4px solid var(--text-light); }
        .solutions-table th.sort-desc::after { border-top: 4px solid var(--text-light); }
        .solutions-table td:nth-child(4), .solutions-table td:nth-child(5) { text-align: right; } /* Align Vol and M20 right */

        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        .bottom-actions { margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--light-bg); }

        #status-box {
            position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; border-radius: 6px;
            color: white; font-size: 0.8rem; font-weight: 500; z-index: 1000;
            opacity: 0; visibility: hidden; transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show { opacity: 1; visibility: visible; transform: translateY(0); }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

        /* --- Help Tooltip Styles --- */
        .help-tooltip-container { position: relative; display: inline-block; }
        .help-icon {
            display: flex; align-items: center; justify-content: center; width: 28px; height: 28px;
            background-color: var(--border-color); color: var(--text-light); border-radius: 50%;
            font-weight: bold; font-size: 1rem; cursor: help; transition: background-color: 0.2s;
        }
        .help-icon:hover { background-color: #6b7280; }


        .tooltip-content {
    visibility: hidden;
    opacity: 0;
    width: 400px;
    background-color: var(--light-bg);
    color: var(--text-medium);
    text-align: left;
    border-radius: 0.375rem;
    padding: 1rem;
    position: absolute;
    z-index: 1001;
    top: -15px;
    left: 115%;
    margin-left: 10px;
    /* This transition applies when hiding the tooltip */
    transition: opacity 0.3s;
    /* Wait 1 second after the mouse leaves before starting to hide */
    transition-delay: 2s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.help-tooltip-container:hover .tooltip-content {
     visibility: visible;
     opacity: 1;
     transition-delay: 0s;
}

.help-tooltip-container::after {
    content: '';
    position: absolute;
    /* This creates a transparent element over the gap */
    left: 100%;
    width: 10px; 
    /* This makes it cover the full height of the icon */
    top: 0;
    bottom: 0;
}


        .tooltip-content::after {
            content: ""; position: absolute;
            top: 20px; 
            right: 100%;
            margin-top: -5px; 
            border-width: 5px; border-style: solid;
            border-color: transparent var(--light-bg) transparent transparent;
        }
        
        .tooltip-content h4 { color: var(--text-light); font-size: 0.9rem; margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; }
        .tooltip-content p { margin-top: 0; margin-bottom: 0.75rem; line-height: 1.4; }
        .tooltip-content p:last-child { margin-bottom: 0; }
        .tooltip-content hr { border: none; border-top: 1px solid var(--border-color); margin: 0.75rem 0; }

        #app-footer {
    position: fixed;   /* Keeps it on the screen even if you scroll */
    bottom: 8px;      
    right: 15px;      
    font-size: 0.75rem; 
    color: var(--text-dark); 
    z-index: 1001;     
}

        /* --- Compact Slider Styles --- */
        .slider-group {
            display: grid;
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 12px;
            align-items: center;
            margin-bottom: 1rem;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-group > .control-label {
            margin-bottom: 0;
            font-size: 0.875rem;
            white-space: nowrap;
        }
        .slider-value-track {
            grid-column: 2;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
        }
        .slider-value-track > * {
            grid-column: 1;
            grid-row: 1;
        }
        .slider-value-display {
            text-align: center;
            color: var(--text-dark);
            font-weight: 500;
            font-size: 0.8rem;
            pointer-events: none;
        }
        input[type="range"].custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px;
            background: var(--medium-bg);
            border-radius: 6px;
            outline: none;
            padding: 0;
            margin: 0;
        }
        input[type="range"].custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider:disabled {
            background: var(--light-bg);
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb {
            background: var(--border-color);
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb {
            background: var(--border-color);
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">

            <div class="control-group">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <label for="file-input" class="file-input-label btn-like" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon" aria-label="Help and usage information">?</span>
                        <div class="tooltip-content">
    <h4>Combs - Powder XRD Indexing</h4>
    <p>This program uses a system-specific, exhaustive search to find potential unit cells based on the first 20 peaks.</p>
    <ul>
        <li style="margin-bottom: 5px;"><b>Cubic:</b> Tests single peaks.</li>
        <li style="margin-bottom: 5px;"><b>Tetra/Hexa:</b> Solves using peak pairs.</li>
        <li style="margin-bottom: 5px;"><b>Ortho:</b> Solves using peak triplets.</li>
        <li style="margin-bottom: 5px;"><b>Monoclinic:</b> Solves using peak quadruplets.</li>
    </ul>
    <p>All trial cells are refined, scored (M(20)), and analyzed for space groups. For a full breakdown, <a href="combs_help.html" target="_blank" style="color: #6495ED;">read the technical guide.</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2&theta; intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the plot, X-axis, or Y-axis. Right-click to reset zoom.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Add Peak:</b> Hold <b>Ctrl</b> and click on the chart to manually add a peak at that position.</p>
</div>

                    </div>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf,.xra,.gsa">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="peaks">Peaks</button>
                <button class="tab-btn" data-tab="parameters">Parameters</button>
                <button class="tab-btn" data-tab="solutions">
                    Solutions
                    <span id="solutions-led" class="led-indicator gray" aria-label="Solutions status indicator"></span>
                </button>
            </div>

            <div class="tab-content-panels">
                <div id="peaks-tab-content" class="tab-content-panel active">
                     <div class="control-group" style="width: 100%; flex-grow: 1; display: flex; flex-direction: column;">
                        <div id="peak-controls" class="hidden" style="display: flex; flex-direction: column; flex-grow: 1;">
                            
                            <div class="slider-group">
                                <label class="control-label">Min peak (%)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="peak-threshold-slider" class="custom-slider" min="0" max="100" value="56">
                                    <span id="peak-threshold-value" class="slider-value-display">2.0</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Radius (pts)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="200" value="40" step="1">
                                    <span id="ball-radius-value" class="slider-value-display">40</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Points</label>
                                <div class="slider-value-track">
                                    <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="100" value="10" step="1">
                                    <span id="smoothing-width-value" class="slider-value-display">10</span>
                                </div>
                            </div>

                            <div style="border-top: 1px solid var(--border-color); margin: 1.5rem 0;"></div>

                            <div class="slider-group">
                                <label class="control-label">2θ Min</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                                    <span id="tth-min-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            <div class="slider-group">
                                <label class="control-label">2θ Max</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                                    <span id="tth-max-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            
                            <div id="peak-table-container" class="hidden" style="flex-grow: 1; min-height: 0;">
                                <table class="peak-table">
                                    <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                                    <tbody id="peak-list-body"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>


                <div id="parameters-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                        <div class="parameter-grid">
                            <div>
                                <label for="wavelength-preset" class="control-label">Radiation Preset</label>
                         <select id="wavelength-preset" class="control-select">
                            <option value="Cu">Cu Ka</option>
                            <option value="Co">Co Ka</option>
                            <option value="Fe">Fe Ka</option>
                            <option value="Cr">Cr Ka</option>
                            <option value="Mo">Mo Ka</option>
                            <option value="custom">Custom (Monochromatic)</option>
                        </select>
                            </div>
                             <div>
                                <label for="wavelength" class="control-label">Ka1 Wavelength (Å)</label>
                                <input type="number" id="wavelength" value="1.54056" step="0.00001" min="0.1" class="control-input" readonly>
                            </div>
                        </div>
                        
                        <label class="checkbox-label" style="margin-top: 1rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" id="strip-ka2-checkbox">
                            <span>Strip K-alpha2</span>
                        </label>
                    </div>

                    <div class="control-group" style="width: 100%; border-top: 1px solid var(--light-bg); padding-top: 1.5rem;">
                        <div id="indexing-controls" class="hidden">
                            <div class="parameter-grid">
                                <div>
                                    <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                                    <input type="number" id="max-volume" value="1000" step="100" min="60" max="12000" class="control-input">
                                </div>
                                <div>
                                    <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                                    <input type="number" id="impurity-peaks" value="0" min="0" max="5" step="1" class="control-input">
                                </div>
                            </div>
                            
                            <div class="parameter-grid" style="margin-top: 1rem; align-items: end;">
                                <div>
                                    <label for="tth-error" class="control-label">2θ Error (°)</label>
                                    <input type="number" id="tth-error" value="0.06" step="0.002" min="0.0001" class="control-input">
                                </div>
                                <label class="checkbox-label" style="padding-bottom: 0.5rem;">
                                    <input type="checkbox" id="refine-zero-checkbox" checked> 
                                    <span>Refine Zero Error</span>
                                </label>
                            </div>
                            
                            <label class="control-label" style="margin-top: 1.5rem; margin-bottom: 1rem;">Crystal Systems to Search:</label>
                            <div class="parameter-grid">
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> <span>Cubic</span></label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> <span>Tetragonal</span></label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> <span>Hexagonal</span></label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > <span>Orthorhombic</span></label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > <span>Monoclinic</span></label>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="solutions-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                         <div id="solutions-table-container">
                            <table class="solutions-table">
                                <thead><tr>
                                    <th data-sort="system">Sys.</th>
                                    <th>Parameters (Å)</th>
                                    <th>Angles (°)</th>
                                    <th data-sort="volume">Vol</th>
                                    <th data-sort="m20">M(20)</th>
                                </tr></thead>
                                <tbody id="solutions-table-body"></tbody>
                            </table>
                         </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <p id="status-text" style="text-align: center; font-size: 0.8rem; color: var(--text-dark); margin: 0 0 0.5rem 0; height: 1.2em;"></p>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary btn-like" style="flex: 1;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary btn-like" style="flex: 1;" disabled>Generate PDF Report</button>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>

        </div>
    </div>

    <div id="status-box"></div>

    <script>

document.addEventListener('DOMContentLoaded', () => {

const WAVELENGTH_PRESETS = {
        'Cu': { ka1: 1.54056, ka2: 1.54439, ka_avg: 1.54183, ratio: 0.497 },
        'Co': { ka1: 1.78897, ka2: 1.79285, ka_avg: 1.79012, ratio: 0.497 },
        'Fe': { ka1: 1.93604, ka2: 1.93998, ka_avg: 1.93741, ratio: 0.497 },
        'Cr': { ka1: 2.28970, ka2: 2.29361, ka_avg: 2.29100, ratio: 0.497 },
        'Mo': { ka1: 0.70930, ka2: 0.71359, ka_avg: 0.71072, ratio: 0.497 },
        'custom': { ka1: null, ka2: null, ka_avg: null, ratio: 0.5 } // 'null' indicates user-defined
    };


    const ui = {
        fileInput: document.getElementById('file-input'),
        fileInputLabel: document.querySelector('.file-input-label'),
        fileName: document.getElementById('file-name'),
        peakControls: document.getElementById('peak-controls'),
        peakThresholdSlider: document.getElementById('peak-threshold-slider'),
        peakThresholdValue: document.getElementById('peak-threshold-value'),
        peakTableContainer: document.getElementById('peak-table-container'),
        peakListBody: document.getElementById('peak-list-body'),
        indexingControls: document.getElementById('indexing-controls'),
        
        // --- *** NEW/MODIFIED: Wavelength Controls *** ---
        wavelengthPreset: document.getElementById('wavelength-preset'),
        stripKa2Checkbox: document.getElementById('strip-ka2-checkbox'),
        wavelength: document.getElementById('wavelength'), // This is the K-alpha1 input
        
        tthError: document.getElementById('tth-error'),
        maxVolume: document.getElementById('max-volume'),
        impurityPeaksInput: document.getElementById('impurity-peaks'),
        refineZeroCheckbox: document.getElementById('refine-zero-checkbox'),
        systemCheckboxes: document.querySelectorAll('.system-checkbox'),
        startIndexingButton: document.getElementById('start-indexing-button'),
        reportButton: document.getElementById('report-button'),
        progressBar: document.getElementById('progress-bar'),
        progressBarContainer: document.getElementById('progress-bar-container'),
        solutionsTableBody: document.getElementById('solutions-table-body'),
        solutionsTableHeaders: document.querySelectorAll('#solutions-table-container th'),
        solutionsLed: document.getElementById('solutions-led'),
        chartCanvas: document.getElementById('xrd-chart'),
        placeholder: document.getElementById('placeholder'),
        resultsContainer: document.getElementById('results-container'),
        tthMinSlider: document.getElementById('tth-min-slider'),
        tthMaxSlider: document.getElementById('tth-max-slider'),
        tthMinValue: document.getElementById('tth-min-value'),
        tthMaxValue: document.getElementById('tth-max-value'),
        ballRadiusSlider: document.getElementById('ball-radius-slider'),
        ballRadiusValue: document.getElementById('ball-radius-value'),
        smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
        smoothingWidthValue: document.getElementById('smoothing-width-value'),
        statusBar: document.getElementById('status-box'),
        tabButtonsContainer: document.querySelector('.tab-buttons'),
        tabButtons: document.querySelectorAll('.tab-btn'),
        tabPanels: document.querySelectorAll('.tab-content-panel')
    };
    
    // Global variable for space group data ---
    let spaceGroupData = null;

    // Function to load space group JSON data ---
   // Function to load space group JSON data ---
    async function loadSpaceGroupData() {
        try {
            const response = await fetch('space_groups_all_settings.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            spaceGroupData = await response.json();
            console.log("Space group data (all settings) loaded successfully.");
        } catch (error) {
            console.error("Could not load space group data:", error);
            showStatus("Warning: Could not load space_groups_all_settings.json. Space group analysis will be disabled.", "error", 8000);
        }
    }
    
    // --Load data on startup, add message to console, see file event 
    loadSpaceGroupData();

    
    ui.solutionsTableHeaders.forEach(header => {
        header.addEventListener('click', () => {
            const column = header.dataset.sort;
            if (!column) return;

            if (sortState.column === column) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.column = column;
                sortState.direction = (column === 'm20' || column === 'volume') ? 'desc' : 'asc';
            }

            sortSolutions();
            const selectedSystems = Array.from(ui.systemCheckboxes)
                                         .filter(cb => cb.checked)
                                         .map(cb => cb.value);
            displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
            updateSolutionsTable();
        });
    });

    ui.systemCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            const selectedSystems = Array.from(ui.systemCheckboxes)
                                         .filter(cb => cb.checked)
                                         .map(cb => cb.value);
            displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
            updateSolutionsTable();
        });
    });

    // --- LOGARITHMIC SLIDER CONFIGURATION ---
    const minPeak = 0.1;
    const maxPeak = 20;
    const minLog = Math.log(minPeak);
    const maxLog = Math.log(maxPeak);
    const scale = (maxLog - minLog) / 100;

    function valueToLogSlider(value) {
        if (value <= 0) return 0;
        return (Math.log(value) - minLog) / scale;
    }

    function logSliderToValue(position) {
        return Math.exp(minLog + scale * position);
    }

    // --- DEBOUNCE 
    const debounce = (func, delay) => {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    };
    const debouncedFindPeaks = debounce(findPeaks, 250);
    
    // --- Debounc
    const debouncedUpdateAndRedraw = debounce(() => {
        updateWorkingData();
        if (xrdChart) {
            const experimentalPoints = workingExperimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, workingExperimentalData.intensity[i]) }));
            xrdChart.data.datasets[0].data = experimentalPoints;
            xrdChart.update('none'); // pas d'animation, sinon c'est trop lent
        }
        findPeaks();
    }, 250);


    // --- log slider, 0.1% c'est assez ?
    const initialPeakThreshold = 2.0;
    ui.peakThresholdSlider.value = valueToLogSlider(initialPeakThreshold);
    ui.peakThresholdValue.textContent = initialPeakThreshold.toFixed(1);

    // --- TAB SWITCHING --
    ui.tabButtonsContainer.addEventListener('click', (e) => {
        const clickedTab = e.target.closest('.tab-btn');
        if (!clickedTab || clickedTab.disabled) return;
        const tabTarget = clickedTab.dataset.tab;
        ui.tabButtons.forEach(btn => btn.classList.remove('active'));
        ui.tabPanels.forEach(panel => panel.classList.remove('active'));
        clickedTab.classList.add('active');
        document.getElementById(`${tabTarget}-tab-content`).classList.add('active');
    });

    let statusTimeout;
    const showStatus = (message, type = 'info', duration = 4000) => {
        if (!ui.statusBar) {
            console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
            return;
        }
        if (statusTimeout) clearTimeout(statusTimeout);
        ui.statusBar.textContent = message;
        ui.statusBar.className = `show ${type}`;
        statusTimeout = setTimeout(() => {
            if (ui.statusBar) {
                ui.statusBar.classList.remove('show');
            }
        }, duration);
    };

    // --- data, si Ka stripped ou pas, on copie les données
    let fullExperimentalData = { tth: [], intensity: [] }; // The original, unmodified data
    let workingExperimentalData = { tth: [], intensity: [] }; // The data to be plotted and analyzed (raw or stripped)

    let pickedPeaks = [];
    let solutions = [];
    let displayedSolutions = [];
    let selectedSolution = null;
    let currentHklList = [];
    let xrdChart;
    let isIndexing = false;
    let activeWorkers = [];
    let sortState = { column: 'm20', direction: 'desc' };
    let workerURL = null;    
    // --- Dynamic Pruning Constants ---
    const MAX_SOLUTIONS_BEFORE_PRUNING = 50;
    const PRUNE_TO_COUNT = 40; // Prune down to this many

    /**
     * Dynamically prunes the global 'solutions' list if it exceeds the max count.
     * It sorts by M(20) descending and keeps only the best ones.
     */
    const pruneSolutions = () => {
        // Only run if we are over the limit
        if (solutions.length <= MAX_SOLUTIONS_BEFORE_PRUNING) return;

        // Sort by m20 descending to find the best ones
        solutions.sort((a, b) => b.m20 - a.m20);
        
        // Keep only the top PRUNE_TO_COUNT solutions
        solutions = solutions.slice(0, PRUNE_TO_COUNT);
        
        // The main 'onmessage' handler will call sortSolutions() *after* this,
        // which will re-sort the newly pruned list based on the user's UI selection.
    };




    const setupWorker = () => {
        try {
            const workerScript = document.getElementById('indexing-worker').textContent;
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            workerURL = URL.createObjectURL(blob);
        } catch (error) {
            console.error("Failed to create worker blob URL:", error);
            showStatus("Critical error: Could not initialize indexing engine.", "error", 10000);
        }
    };
    setupWorker();

    // --- SYSTEMATIC ABSENCE ANALYSIS HELPERS -
    const max_hkl_analysis = 10;

    function generateHKL_for_analysis(params, lambda, maxTth) {
        const { a, b: b_in, c: c_in, beta: beta_in, system } = params;
        const b = b_in ?? a;
        const c = c_in ?? a;
        const beta = beta_in ?? 90;
        const reflections = [];

        const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
        // Use a 1.05 safety margin for the q-limit
        const q_max_limit = (1 / (d_min * d_min)) * 1.05; 
        // Add +1 to max h/k/l to ensure the loop includes the largest possible index
        const h_max = Math.ceil(a / d_min) + 1;
        const k_max = Math.ceil(b / d_min) + 1;
        const l_max = Math.ceil(c / d_min) + 1;

        const processReflection = (h, k, l, inv_d_sq) => {
            // This final check is still necessary
            if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) return; 
            const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
            if (sinThetaSq <= 1) {
                const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                reflections.push({ tth, h, k, l, d: 1 / Math.sqrt(inv_d_sq) });
            }
        };

        switch (system) {
            case 'cubic':
                for (let h = 0; h <= h_max; h++) {
                    const h_term = (h * h) / (a * a);
                    if (h_term > q_max_limit) break; 
                    for (let k = 0; k <= h; k++) {
                        const hk_term = h_term + (k * k) / (a * a);
                        if (hk_term > q_max_limit) break; 
                        for (let l = 0; l <= k; l++) {
                            if (h === 0 && k === 0 && l === 0) continue;
                            const inv_d_sq = hk_term + (l * l) / (a * a);
                            // processReflection handles the final q_max check
                            processReflection(h, k, l, inv_d_sq);
                        }
                    }
                }
                break;

            case 'tetragonal':
            case 'hexagonal':
                 for (let l = 0; l <= l_max; l++) {
                    const l_term = (l * l) / (c * c);
                    if (l_term > q_max_limit) break; 
                    
                    for (let h = 0; h <= h_max; h++) {
                        let h_term_base;
                        if (system === 'tetragonal') {
                            h_term_base = (h * h) / (a * a);
                        } else { // hexagonal
                            h_term_base = (4 / 3) * (h * h) / (a * a);
                        }
                        if (l_term + h_term_base > q_max_limit && h > 0) break; 

                        for (let k = 0; k <= h; k++) {
                            if (h === 0 && k === 0 && l === 0) continue;

                            let inv_d_sq;
                            if (system === 'tetragonal') {
                                inv_d_sq = l_term + (h * h + k * k) / (a * a);
                            } else { // hexagonal
                                inv_d_sq = l_term + (4 / 3) * (h * h + h * k + k * k) / (a * a);
                            }
                            
                            processReflection(h, k, l, inv_d_sq);
                        }
                    }
                }
                break;

            case 'orthorhombic':
                for (let h = 0; h <= h_max; h++) {
                    const h_term = (h * h) / (a * a);
                    if (h_term > q_max_limit) break; 
                    
                    for (let k = 0; k <= k_max; k++) {
                        const hk_term = h_term + (k * k) / (b * b);
                        if (hk_term > q_max_limit) break; 
                        
                        for (let l = 0; l <= l_max; l++) {
                            if (h === 0 && k === 0 && l === 0) continue;
                            const inv_d_sq = hk_term + (l * l) / (c * c);
                            processReflection(h, k, l, inv_d_sq);
                        }
                    }
                }
                break;

            case 'monoclinic':
                const sinBeta = Math.sin(beta * Math.PI / 180);
                const cosBeta = Math.cos(beta * Math.PI / 180);
                const sinBetaSq = sinBeta * sinBeta;
                if (sinBetaSq < 1e-6) return []; // Invalid cell

                // --- OPTIMIZATION: Pre-calculate reciprocal parameters ---
                const a_star_sq = 1 / (a * a * sinBetaSq);
                const b_star_sq = 1 / (b * b);
                const c_star_sq = 1 / (c * c * sinBetaSq);
                // This is the coefficient for the h*l term (q = ... - h*l*ac_star_term + ...)
                const ac_star_term = 2 * cosBeta / (a * c * sinBetaSq); 
                // ---

                for (let h = -h_max; h <= h_max; h++) {
                    const h_term = h * h * a_star_sq;
                    const h_l_coeff = h * ac_star_term; // (h * ac_star_term)
                    
                    // --- OPTIMIZATION 1: Check min q for this 'h' (at k=0) ---
                    // Vertex of the parabola q(l) = (c_star_sq * l^2) - (h_l_coeff * l) + h_term
                    const l_vertex_h_only = (c_star_sq !== 0) ? h_l_coeff / (2 * c_star_sq) : 0;
                    const q_min_for_h = (c_star_sq * l_vertex_h_only * l_vertex_h_only) - (h_l_coeff * l_vertex_h_only) + h_term;
                    
                    if (q_min_for_h > q_max_limit) {
                        continue; // Skip this 'h' entirely
                    }
                    // ---
                    
                    for (let k = 0; k <= k_max; k++) {
                        const k_term = (k * k) * b_star_sq;
                        const hk_term = h_term + k_term; // This is the q-value for l=0

                        // --- OPTIMIZATION 2: Check min q for this (h, k) ---
                        // Vertex of the parabola q(l) = (c_star_sq * l^2) - (h_l_coeff * l) + hk_term
                        const l_vertex = l_vertex_h_only; // Vertex l-coordinate is independent of k
                        const q_min_for_hk = (c_star_sq * l_vertex * l_vertex) - (h_l_coeff * l_vertex) + hk_term;
                        
                        if (q_min_for_hk > q_max_limit) {
                            // If k=0 failed, all k>0 will also fail for this h.
                            if (k === 0) break; 
                            // If k>0 failed, skip to the next k.
                            else continue; 
                        }
                        // ---

                        for (let l = -l_max; l <= l_max; l++) {
                            if (h === 0 && k === 0 && l === 0) continue;
                            // Uniqueness condition for k=0 plane
                            if (k === 0) {
                                if (h < 0) continue;
                                if (h === 0 && l <= 0) continue;
                            }
                            
                            // Calculate q using the pre-calculated terms
                            const inv_d_sq = (c_star_sq * l * l) - (h_l_coeff * l) + hk_term;
                            
                            processReflection(h, k, l, inv_d_sq);
                        }
                    }
                }
                break;
        }

        // De-duplicate reflections with very similar tth values
        const uniqueReflections = [];
        const tolerance = 1e-4; // tth tolerance for uniqueness
        if (reflections.length > 0) {
            reflections.sort((a, b) => a.tth - b.tth);
            uniqueReflections.push(reflections[0]);
            for (let i = 1; i < reflections.length; i++) {
                if (Math.abs(reflections[i].tth - uniqueReflections[uniqueReflections.length - 1].tth) > tolerance) {
                    uniqueReflections.push(reflections[i]);
                }
            }
        }
        return uniqueReflections;
    }


/**
 * Analyzes observed diffraction peaks to determine compatible space groups.
 * Uses an INCLUSIVE approach: only flags violations when forbidden reflections are OBSERVED.
 * * @param {object} solution - Crystal solution with unit cell parameters and system
 * @param {Array<object>} obs_peaks - **Already-filtered** observed peaks
 * @param {object} spaceGroupData - Parsed reflection_conditions.json
 * @param {string} wavelength - Radiation wavelength (e.g., 'CuKa')
 * @param {number} tthError - Tolerance for matching 2-theta values
 * @param {number} tthMax - The max 2-theta value from the UI slider
 * @returns {object} {centering, rankedSpaceGroups, detectedExtinctions}
 */
function analyzeSystematicAbsences(solution, obs_peaks, spaceGroupData, wavelength, tthError, tthMax) {
    const MAX_VIOLATIONS = 2; // Allow a few violations for experimental error
    
    const fallbackResult = {
        centering: 'Unknown',
        rankedSpaceGroups: [],
        detectedExtinctions: [],
        ambiguousHkls: new Set() // Add default empty set
    };

    if (!spaceGroupData?.space_groups) {
        console.warn("Space group data not loaded");
        return fallbackResult;
    }

    // This now calls the CORRECTED hkl generation function
    const all_calc_hkls = generateHKL_for_analysis(
        solution, 
        wavelength, 
        tthMax
    );
    
    if (all_calc_hkls.length === 0) return fallbackResult;

    const indexed_hkls = [];
    const zero_correction = solution.zero_correction || 0;

    obs_peaks.forEach(peak => {
        const corrected_tth = peak.tth - zero_correction;
        const bestMatch = all_calc_hkls.reduce((best, hkl) => {
            const diff = Math.abs(hkl.tth - corrected_tth);
            return diff < best.minDiff ? { hkl, minDiff: diff } : best;
        }, { hkl: null, minDiff: Infinity });

        if (bestMatch.hkl && bestMatch.minDiff < (tthError * 1.5)) {
            indexed_hkls.push({ 
                h: bestMatch.hkl.h, 
                k: bestMatch.hkl.k, 
                l: bestMatch.hkl.l,
                tth: peak.tth,
                calc_tth: bestMatch.hkl.tth 
            });
        }
    });

    const unique_indexed_hkls = Array.from(
        new Map(indexed_hkls.map(r => [`${r.h},${r.k},${r.l}`, r])).values()
    );

    // This filter will now work correctly because all_calc_hkls is a unique list
    const unambiguous_hkls = unique_indexed_hkls.filter(refl => {
        const nearbyCount = all_calc_hkls.filter(calc => {
            if (calc.h === refl.h && calc.k === refl.k && calc.l === refl.l) return false;
            return Math.abs(calc.tth - refl.calc_tth) < tthError;
        }).length;
        return nearbyCount === 0; 
    });

    const hkls_for_analysis = unambiguous_hkls.length > 0 ? unambiguous_hkls : unique_indexed_hkls;
    
    if (hkls_for_analysis.length < 5) {
        fallbackResult.centering = 'Unknown (too few unambiguous peaks in range)';
        return fallbackResult;
    }

    const unambiguousSet = new Set(unambiguous_hkls.map(r => `${r.h},${r.k},${r.l}`));
    const ambiguousHkls = new Set(
        unique_indexed_hkls
            .filter(r => !unambiguousSet.has(`${r.h},${r.k},${r.l}`))
            .map(r => `${r.h},${r.k},${r.l}`)
    );

    const centeringResult = determineCentering(hkls_for_analysis, solution.system);
    const detectedExtinctions = detectExtinctions(hkls_for_analysis, solution.system, spaceGroupData);

  
    // Pass 'detectedExtinctions' as the final argument
    const rankedSpaceGroups = rankSpaceGroups(
        hkls_for_analysis,
        solution.system,
        centeringResult.plausibleCenterings,
        spaceGroupData,
        MAX_VIOLATIONS,
        detectedExtinctions
    );
    

    return {
        centering: centeringResult.description,
        rankedSpaceGroups: rankedSpaceGroups.slice(0, 20),
        detectedExtinctions: detectedExtinctions,
        centeringViolations: centeringResult.violations,
        centeringViolationDetails: centeringResult.violationDetails,
        ambiguousHkls: ambiguousHkls
    };
}


/*
 * Determines the most likely lattice centering based on observed reflections.
 * RETURNS DETAILS OF VIOLATING REFLECTIONS (up to 2 per type).
 */
function determineCentering(indexed_hkls, system) {
    const centeringTests = {
        'P': { name: 'Primitive (P)', forbidden: (h, k, l) => false },
        'I': { name: 'Body-centered (I)', forbidden: (h, k, l) => (h + k + l) % 2 !== 0 },
        'F': { name: 'Face-centered (F)', forbidden: (h, k, l) => !( (h%2===0 && k%2===0 && l%2===0) || (h%2!==0 && k%2!==0 && l%2!==0) ) },
        'A': { name: 'A-centered (A)', forbidden: (h, k, l) => (k + l) % 2 !== 0 },
        'B': { name: 'B-centered (B)', forbidden: (h, k, l) => (h + l) % 2 !== 0 },
        'C': { name: 'C-centered (C)', forbidden: (h, k, l) => (h + k) % 2 !== 0 }
    };

    const validBravaisCenterings = {
        'cubic': ['P', 'I', 'F'],
        'tetragonal': ['P', 'I'],
        'orthorhombic': ['P', 'I', 'F', 'A', 'B', 'C'],
        'hexagonal': ['P'], // Rhombohedral R handled separately if needed,... à revoir 
        'monoclinic': ['P', 'C'], // Standard setting
    };

    const violations = {};
    const violationDetails = {}; // <-- NEW: Store details here
    const MAX_DETAILS_TO_STORE = 2; // <-- Limit details stored

    for (const [key, test] of Object.entries(centeringTests)) {
        const allowedForSystem = validBravaisCenterings[system] || ['P'];
        if (allowedForSystem.includes(key)) {
            const violatingPeaks = indexed_hkls.filter(({h, k, l}) =>
                test.forbidden(Math.round(h), Math.round(k), Math.round(l)) // Use rounded indices for integer checks
            );
            violations[key] = violatingPeaks.length;

            // <-- NEW: Store details if count is low -->
            if (violations[key] > 0 && violations[key] <= MAX_DETAILS_TO_STORE) {
                violationDetails[key] = violatingPeaks.slice(0, MAX_DETAILS_TO_STORE).map(p => ({
                    h: p.h, k: p.k, l: p.l, tth: p.tth // Store measured tth
                }));
            }
            // <-- END NEW -->
        }
    }

    const minViolations = Object.keys(violations).length > 0 ? Math.min(...Object.values(violations)) : 0;

    let plausible = Object.keys(violations).filter(key =>
        violations[key] === minViolations && (validBravaisCenterings[system] || ['P']).includes(key)
    );

     if (plausible.length === 0 && violations['P'] === minViolations) {
        plausible = ['P'];
     } else if (plausible.length === 0) {
        plausible = ['P']; // Fallback
     }

    let finalCenterings;
    if (plausible.includes('F')) finalCenterings = ['F'];
    else if (plausible.includes('I')) finalCenterings = ['I'];
    else {
        const specialCenterings = plausible.filter(c => ['A', 'B', 'C'].includes(c));
        finalCenterings = specialCenterings.length > 0 ? specialCenterings : ['P'];
        if (plausible.includes('P') && !finalCenterings.includes('P') && specialCenterings.length > 0) {
             finalCenterings.push('P');
        }
         if (finalCenterings.length === 0) finalCenterings = ['P'];
    }

    finalCenterings = finalCenterings.filter(c => (validBravaisCenterings[system] || ['P']).includes(c));
    if (finalCenterings.length === 0) finalCenterings = ['P'];

    return {
        plausibleCenterings: finalCenterings,
        description: finalCenterings.map(c => centeringTests[c]?.name || c).join(' or '),
        violations: violations,
        violationDetails: violationDetails, // <-- NEW: Return details
        minViolations: minViolations
    };
}

/**
 * Detects possible systematic extinctions by checking observed reflections
 * against all rules defined in spaceGroupData for the given system.
 * Only lists rules where *all* observed reflections in the relevant zone
 * satisfy the condition.
 *
 * @param {Array<object>} indexed_hkls - List of observed {h, k, l, ...} reflections.
 * @param {string} system - The crystal system ('cubic', 'monoclinic', etc.).
 * @param {object} spaceGroupData - The parsed space group JSON data.
 * @returns {Array<string>} List of detected extinction rule strings (e.g., ["00l: l=2n", "hk0: h=2n"]) or ["None detected"].
 */
function detectExtinctions(indexed_hkls, system, spaceGroupData) {
    const confirmedRules = new Set(); // Use a Set to store unique confirmed rules

    if (!spaceGroupData?.space_groups || indexed_hkls.length === 0) {
        return ["None detected (no data or rules)"];
    }

    // --- 1. Collect all unique potential rules for this system ---
    const potentialRules = new Set();
    Object.values(spaceGroupData.space_groups).forEach(sg => {
        if (sg.crystal_system === system) {
            sg.settings.forEach(setting => {
                const conditions = setting.reflection_conditions || {};
                Object.entries(conditions).forEach(([zone, condList]) => {
                    condList.forEach(condStr => {
                        potentialRules.add(`${zone}: ${condStr}`); // Store as "zone: condition" string
                    });
                });
            });
        }
    });

    if (potentialRules.size === 0) {
         return ["None detected (no rules for system)"];
    }

    // --- 2. Test each potential rule against observed reflections ---

    // Helper function to parse the rule string "zone: condition"
    const parseRuleString = (ruleStr) => {
        const parts = ruleStr.split(': ');
        if (parts.length === 2) {
            return { zone: parts[0].trim(), condition: parts[1].trim() };
        }
        return null; // Invalid format
    };

    potentialRules.forEach(ruleStr => {
        const parsedRule = parseRuleString(ruleStr);
        if (!parsedRule) return; // Skip if rule string format is wrong

        const { zone, condition } = parsedRule;

        // Filter reflections belonging to this specific zone designation
        // Note: getReflectionZone determines the *most specific* zone type
        const zoneReflections = indexed_hkls.filter(refl => getReflectionZone(refl.h, refl.k, refl.l) === zone);

        // If no reflections were observed in this zone, we can't confirm the rule
        if (zoneReflections.length === 0) {
            return; // Continue to the next rule
        }

        // Check if *all* observed reflections in this zone satisfy the condition
        // We reuse the satisfiesCondition helper from the countViolations function
        const allSatisfy = zoneReflections.every(refl => satisfiesCondition(refl.h, refl.k, refl.l, condition));

        if (allSatisfy) {
            confirmedRules.add(ruleStr); // Add the confirmed rule string
        }
    });

    // --- 3. Return results ---
    if (confirmedRules.size === 0) {
        return ["None detected"];
    } else {
        // Convert Set to array and sort for consistent output
        return Array.from(confirmedRules).sort();
    }
}

function rankSpaceGroups(indexed_hkls, system, allowedCenterings, spaceGroupData, maxViolations, detectedExtinctions) {
    const candidateGroups = Object.values(spaceGroupData.space_groups)
        .filter(sg => sg.crystal_system === system);
    
    const validSettings = [];
    
    // --- [NEW] Create a Set of detected rules for fast lookup ---
    const detectedExtinctionsSet = new Set(detectedExtinctions.filter(e => e !== "None detected"));
    
    for (const sg of candidateGroups) {
        const sgNumber = sg.number;
        
        // Iterate through every setting for this space group
        for (const setting of sg.settings) {
            const centering = setting.symbol.charAt(0);
            
            if (!allowedCenterings.includes(centering) && 
                !(allowedCenterings.includes('P') && !['I','F','A','B','C','R'].includes(centering))) {
                continue;
            }
            
            const rules = setting.reflection_conditions || {};
            const violations = countViolations(indexed_hkls, rules);
            
            if (violations.count <= maxViolations) {
                
                // --- [NEW] SCORING LOGIC ---
                let matchScore = 0;
                const sgRulesSet = new Set();
                
                // 1. Flatten the space group's rules into a set of strings
                Object.entries(rules).forEach(([zone, conditions]) => {
                    conditions.forEach(cond => {
                        sgRulesSet.add(`${zone}: ${cond}`);
                    });
                });

                // 2. Compare with detectedExtinctions
                
                // +10 points for every detected extinction that the space group *also* has.
                detectedExtinctionsSet.forEach(detectedRule => {
                    if (sgRulesSet.has(detectedRule)) {
                        matchScore += 10; 
                    }
                });

                // -1 point for every rule the space group has that was *not* detected.
                sgRulesSet.forEach(sgRule => {
                    if (!detectedExtinctionsSet.has(sgRule)) {
                        matchScore -= 1; 
                    }
                });
                
                // If no extinctions were detected, give a small boost to primitive groups (0 rules)
                if (detectedExtinctionsSet.size === 0 && sgRulesSet.size === 0) {
                    matchScore = 1; 
                }
                // --- [END NEW] SCORING LOGIC ---

                validSettings.push({
                    number: sgNumber,
                    symbol: setting.symbol, 
                    standardSymbol: sg.standard_symbol, 
                    pointGroup: sg.point_group,
                    centrosymmetric: sg.centrosymmetric,
                    violations: violations.count,
                    violatedReflections: violations.details,
                    matchScore: matchScore // <-- Add the new score to the object
                });
            }
        }
    }
    
   
    validSettings.sort((a, b) => {
        // 1. Primary sort: Violations (ascending)
        if (a.violations !== b.violations) {
            return a.violations - b.violations;
        }
        
        // 2. Secondary sort: New matchScore (descending)
        if (a.matchScore !== b.matchScore) {
            return b.matchScore - a.matchScore; // Higher score is better
        }
        
        // 3. Tertiary sort: Space Group Number (descending)
        return b.number - a.number; 
    });
    
    
    return validSettings;
}

/**
     * Helper to check if a reflection satisfies a condition string (e.g., "h+k=2n").
     * Parses conditions like "h+k=2n", "l=4n", "2h+l=4n", "h=2n, l=2n", and "h+k, k+l, h+l=2n".
     * Returns true if the condition is met (reflection allowed), false if violated (reflection should be absent).
     */
    const satisfiesCondition = (h, k, l, condStr) => {
        // --- Special case for F-centering rule ---
        if (condStr === "h+k, k+l, h+l=2n") {
            // All three sums must be even for the reflection to be ALLOWED by F-centering.
            // If any sum is odd, the condition is VIOLATED (returns false).
            const h_int = Math.round(h);
            const k_int = Math.round(k);
            const l_int = Math.round(l);
            return (
                (h_int + k_int) % 2 === 0 &&
                (k_int + l_int) % 2 === 0 &&
                (h_int + l_int) % 2 === 0
            );
        }
        // --- End Special case ---

        // --- Handle comma-separated conditions (e.g., "h=2n, l=2n") ---
        const conditions = condStr.split(',').map(s => s.trim());

        for (const condition of conditions) {
            // Updated regex to handle more complex expressions like 2h+l
            // It expects an '=' sign, a digit, and 'n'
            const match = condition.match(/([0-9]*[hkl\+\-]+)\s*=\s*(\d+)n/); // Added \s* for optional spaces around =
            if (!match) {
                 // If it doesn't match the standard "expr=modN" format, log error and assume allowed for safety.
                 console.warn(`[satisfiesCondition] Could not parse rule part: "${condition}" in rule string "${condStr}"`);
                 continue; // Check the next part of the comma-separated rule, if any
            }

            const [, expr, modStr] = match;
            const mod = parseInt(modStr);
            if (isNaN(mod) || mod <= 0) {
                 console.warn(`[satisfiesCondition] Invalid modulus in rule part: "${condition}"`);
                 continue; // Check next part
            }

            // Evaluate the expression (handles terms like 2h, -k, etc.)
            let value = 0;
            // Matches terms like +h, -2k, 3l, +1h, -k etc.
            const terms = expr.match(/[+-]?[0-9]*[hkl]/g) || [];

            for (const term of terms) {
                let sign = 1;
                let coeff = 1;
                let variable = '';
                // Regex to capture sign (+/-), coefficient (optional digit), and variable (h, k, l)
                const coeffMatch = term.match(/^([+-]?)(\d*)([hkl])$/);

                if (coeffMatch) {
                    sign = (coeffMatch[1] === '-') ? -1 : 1;
                    // If coefficient is absent (like in 'h' or '-k'), default to 1
                    coeff = coeffMatch[2] ? parseInt(coeffMatch[2]) : 1;
                    variable = coeffMatch[3];

                    const h_int = Math.round(h);
                    const k_int = Math.round(k);
                    const l_int = Math.round(l);

                    if (variable === 'h') value += sign * coeff * h_int;
                    else if (variable === 'k') value += sign * coeff * k_int;
                    else if (variable === 'l') value += sign * coeff * l_int;
                } else {
                     console.warn(`[satisfiesCondition] Could not parse term "${term}" in expression "${expr}"`);
                     // If a term can't be parsed, we can't evaluate the rule reliably.
                     // It's safer to assume the condition might be met to avoid incorrectly flagging violations.
                     // However, returning true here might mask issues. For now, let's continue evaluation.
                }
            }

            // Check if the modulo condition is met for *this* part of the rule
            // We use Math.round on the final value before the modulo operation for robustness.
            if (Math.round(value) % mod !== 0) {
                return false; // If any condition part fails, the whole rule fails (reflection should be absent)
            }
        }

        // If all condition parts (separated by comma, or the single F-centering rule) passed
        return true; // Reflection is allowed by this rule string
    };




    /**
     * Counts how many observed reflections violate a space group's conditions.
     * Uses the globally defined `satisfiesCondition` and `getReflectionZone`.
     * @param {Array<object>} indexed_hkls - List of observed {h, k, l, calc_tth} reflections.
     * @param {object} rules - The reflection_conditions object for a specific space group setting.
     * @returns {object} { count: number, details: Array<string> }
     */
    function countViolations(indexed_hkls, rules) {
        let count = 0;
        const details = [];

        for (const reflection of indexed_hkls) {
            const { h, k, l, calc_tth } = reflection;
            let isViolation = false;

            // Determine the most specific zone for this reflection
            const zone = getReflectionZone(h, k, l);

            // Get rules specific to this zone (if any)
            const applicableZoneRules = rules[zone] || [];

            // Always check general 'hkl' rules as well
            const generalRules = rules.hkl || [];

            // Combine specific zone rules and general hkl rules that might apply
            const allPotentiallyViolatedRules = [];

            // Check if the reflection *should* be absent based on zone rules
            for (const cond of applicableZoneRules) {
                if (!satisfiesCondition(h, k, l, cond)) {
                    isViolation = true;
                    const tth_string = calc_tth ? ` at ${calc_tth.toFixed(3)}°` : '';
                    details.push(`(${h},${k},${l})${tth_string} violates ${zone}: ${cond}`);
                    break; // One violation is enough for this reflection
                }
            }

            // If not already flagged, check general 'hkl' rules
            if (!isViolation) {
                for (const cond of generalRules) {
                     // Check if the *zone* itself matches 'hkl' or if the reflection *also* matches a more specific zone covered by this general rule
                     // Example: An hkl rule like "h+k=2n" applies to (110), even though its specific zone is hk0.
                     if (zone === 'hkl' || !rules[zone] || !rules[zone].some(zoneCond => zoneCond === cond)) {
                          if (!satisfiesCondition(h, k, l, cond)) {
                               isViolation = true;
                               const tth_string = calc_tth ? ` at ${calc_tth.toFixed(3)}°` : '';
                               details.push(`(${h},${k},${l})${tth_string} violates hkl: ${cond}`);
                               break; // One violation is enough
                          }
                     }
                }
            }

            if (isViolation) {
                count++;
            }
        }

        return { count, details: details.slice(0, 5) }; // Limit details shown
    }


/**
 * Determines the zone designation for a reflection
 * (This function is a helper for analyzeSystematicAbsences)
 */
function getReflectionZone(h, k, l) {
    if (k === 0 && l === 0 && h !== 0) return 'h00';
    if (h === 0 && l === 0 && k !== 0) return '0k0';
    if (h === 0 && k === 0 && l !== 0) return '00l';
    if (h === 0 && k !== 0 && l !== 0) return '0kl';
    if (k === 0 && h !== 0 && l !== 0) return 'h0l';
    if (l === 0 && h !== 0 && k !== 0) return 'hk0';
    if (h !== 0 && h === k && l !== 0 && h !== l) return 'hhl';
    if (k !== 0 && k === l && h !== 0 && h !== k) return 'hkk';
    if (h !== 0 && h === l && k !== 0 && k !== h) return 'hll';
    return 'hkl';
}

    // --- *** NEW: Ka2 Stripping and Wavelength UI Logic *** ---

    /**
     * Applies the recursive Rachinger algorithm to strip Ka2.
     * I_ka1(i) = I_obs(i) - R * I_ka1(j)
     * where 'j' is the index of the Ka1 peak that *causes* the Ka2 contribution at 'i'.
     */
    const stripRachinger = (tth, intensity, ka1, ka2, ratio) => {
        const n = tth.length;
        if (n === 0) return [];
        
        const stripped = new Array(n).fill(0);
        const tthRad = tth.map(t => t * Math.PI / 180);
        
        // Helper to find index and interpolate *already stripped* data
        const getInterpolatedValue = (targetTthDeg) => {
            if (targetTthDeg < tth[0]) return 0; // Out of range
            
            // Find closest index 'j' where tth[j] <= targetTthDeg
            let low = 0, high = n - 1, j = 0;
            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                if (tth[mid] <= targetTthDeg) {
                    j = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            if (j >= n - 1) return stripped[n-1]; // At the end
            if (j < 0) return 0;

            // Linear interpolation on the 'stripped' array
            const x1 = tth[j], y1 = stripped[j];
            const x2 = tth[j+1], y2 = stripped[j+1];
            const x = targetTthDeg;

            if (Math.abs(x2 - x1) < 1e-6) return y1;
            
            const interpolatedY = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
            return interpolatedY;
        };

        const lambdaRatio = ka1 / ka2;
        
        for (let i = 0; i < n; i++) {
            const sinTh_i = Math.sin(tthRad[i] / 2);
            const sinTh_j_arg = sinTh_i * lambdaRatio;
            
            if (sinTh_j_arg >= 1) {
                stripped[i] = intensity[i]; // No Ka1 can cause this
                continue;
            }
            
            const ka1_pos_rad = 2 * Math.asin(sinTh_j_arg);
            const ka1_pos_deg = ka1_pos_rad * 180 / Math.PI;

            // Get the *already-stripped* intensity at that position
            const ka1_at_j = getInterpolatedValue(ka1_pos_deg);
            
            const correction = ka1_at_j * ratio;
            stripped[i] = Math.max(0, intensity[i] - correction);
        }
        
        return stripped;
    };


    /**
     * Populates `workingExperimentalData` based on stripping checkbox.
     */
    const updateWorkingData = () => {
        if (fullExperimentalData.tth.length === 0) {
            workingExperimentalData = { tth: [], intensity: [] };
            return;
        }

        if (ui.stripKa2Checkbox.checked && ui.wavelengthPreset.value !== 'custom') {
            const preset = WAVELENGTH_PRESETS[ui.wavelengthPreset.value];
            const { tth, intensity } = fullExperimentalData;
            
            console.log(`Stripping Ka2 for ${ui.wavelengthPreset.value}...`);
            const strippedIntensity = stripRachinger(tth, intensity, preset.ka1, preset.ka2, preset.ratio);
            workingExperimentalData = { tth: [...tth], intensity: strippedIntensity };
            console.log("Stripping complete.");

        } else {
            // No stripping, just copy
            console.log("Using raw data (no stripping).");
            workingExperimentalData = { 
                tth: [...fullExperimentalData.tth], 
                intensity: [...fullExperimentalData.intensity] 
            };
        }
    };

    /**
/**
     * Handles changes to the wavelength preset dropdown.
     */
    const handleWavelengthPresetChange = () => {
        const presetKey = ui.wavelengthPreset.value;
        if (presetKey === 'custom') {
            ui.wavelength.readOnly = false;
            ui.stripKa2Checkbox.checked = false;
            ui.stripKa2Checkbox.disabled = true;
            // Note: We don't change the wavelength.value, in case the user set it.
        } else {
            const preset = WAVELENGTH_PRESETS[presetKey];
            ui.wavelength.readOnly = true;
            ui.stripKa2Checkbox.disabled = false;
            
            // Set wavelength based on checkbox
            if (ui.stripKa2Checkbox.checked) {
                ui.wavelength.value = preset.ka1.toFixed(5);
            } else {
                ui.wavelength.value = preset.ka_avg.toFixed(5);
            }
        }
        
        // Trigger a debounced update 
        debouncedUpdateAndRedraw();
        recalculatePeakValues();
        updatePeakTable();
    };

    // --- Add event listeners 
    ui.wavelengthPreset.addEventListener('change', handleWavelengthPresetChange);

    ui.stripKa2Checkbox.addEventListener('change', () => {
        
        const presetKey = ui.wavelengthPreset.value;
        
        // Only update wavelength if we are NOT in custom mode
        if (presetKey !== 'custom') {
            const preset = WAVELENGTH_PRESETS[presetKey];
            
            // Update wavelength value based on new checkbox state
            if (ui.stripKa2Checkbox.checked) {
                ui.wavelength.value = preset.ka1.toFixed(5);
            } else {
                ui.wavelength.value = preset.ka_avg.toFixed(5);
            }
            
            // Wavelength changed, so recalculate d-spacings and q-values
            recalculatePeakValues();
            updatePeakTable();
        }
        
        //  trigger a chart redraw (to add/remove stripping)
        debouncedUpdateAndRedraw();
    });

    // --- Validation and Wavelength Listener ---
    const inputsToValidate = [
        // wavelength is now handled by preset logic
        { id: 'max-volume', el: ui.maxVolume, default: 1000 },
        { id: 'tth-error', el: ui.tthError, default: 0.05 },
        { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 0 },
    ];

    inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
        if (el) {
            el.addEventListener('blur', () => {
                const min = parseFloat(el.min);
                const max = parseFloat(el.max);
                let value = parseFloat(el.value);
                if (isNaN(value)) { el.value = defaultValue; return; }
                if (!isNaN(min) && value < min) el.value = min;
                if (!isNaN(max) && value > max) el.value = max;
            });
        } else {
            console.error(`Initialization Error: The element with id="${id}" was not found.`);
        }
    });

    if (ui.wavelength) {
        // if stripped, Ka1
        ui.wavelength.addEventListener('change', () => {
            if (pickedPeaks.length > 0) {
                recalculatePeakValues();
                updatePeakTable();
            }
        });
    }

/**
         * Smart file detector. It checks for known headers and extensions
         * and falls back to a generic 2-column parser.
         */
        const detectAndParseFile = (fileName, fileContent) => {
            const name = fileName.toLowerCase();
            const lines = fileContent.trim().split(/\r?\n/);
            const firstLine = lines.length > 0 ? lines[0].trim() : '';
            const upperContent = fileContent.substring(0, 500).toUpperCase(); // Check first 500 chars

            // --- Parser Registry ---
            const PARSER_REGISTRY = [
                { // XRDML
                    test: (name, content) => name.endsWith('.xrdml') || (content.includes('<?xml') && content.includes('<xrdMeasurement')),
                    parser: parseXrdmlFile
                },
                { // BRML
                    test: (name, content) => name.endsWith('.brml') || (content.includes('<?xml') && content.includes('<RawDataFile')),
                    parser: parseBrukerBrmlFile
                },
                { // Rigaku RASX (try brml parser)
                    test: (name, content) => name.endsWith('.rasx') && content.includes('<?xml'),
                    parser: parseBrukerBrmlFile
                },
                { // UXD
                    test: (name, content, firstLine) => name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION'),
                    parser: parseUxdFile
                },
                { // Rigaku RAS
                    test: (name, content, firstLine, upper) => name.endsWith('.ras') || upper.includes('*RAS_HEADER_START'),
                    parser: parseRigakuRasFile
                },
                { // Philips UDF/RD/SD
                    test: (name) => name.endsWith('.udf') || name.endsWith('.rd') || name.endsWith('.sd'),
                    parser: parsePhilipsUdfFile
                },
                { // GSAS ESD/XRA
                    test: (name, content, firstLine, upper, allLines) => allLines.some(line => line.trim().toUpperCase().startsWith('BANK')),
                    parser: (content, allLines) => {
                        const bankLine = allLines.find(line => line.trim().toUpperCase().startsWith('BANK'));
                        if (bankLine.toUpperCase().includes('STD')) {
                            return parseGsasXraFile(content);
                        }
                        return parseGsasEsdFile(content);
                    }
                },
                { // Jade MDI (treat as 2-column)
                     test: (name, content, firstLine, upper) => name.endsWith('.mdi') && (upper.includes('2-THETA, INTENSITY') || upper.startsWith('(SAMPLE')),
                     parser: parseDataFile
                }
            ];
            
            // --- Iterate Registry ---
            for (const rule of PARSER_REGISTRY) {
                try {
                    if (rule.test(name, fileContent, firstLine, upperContent, lines)) {
                        // Pass 'content' to parser, but 'lines' to the special GSAS one
                        if (rule.parser.length > 1) {
                             return rule.parser(fileContent, lines); // For GSAS parser
                        }
                        return rule.parser(fileContent);
                    }
                } catch (e) {
                    console.warn(`Parser ${rule.parser.name} failed, trying next...`, e.message);
                }
            }

            // --- Fallback for all other 2-column-like formats ---
            // This will attempt to parse: .xy, .csv, .txt, .dat, .asc, etc.
            return parseDataFile(fileContent, fileName);
        };
    
        /**
         * Generic 2-column parser. This is the fallback for most text files.
         * Includes validation logic for 2-theta (X) and step size (dX).
         */
        const parseDataFile = (text, fileName = "") => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let last_x = -Infinity;
            let suspicious_steps = 0;
            let positive_x_values = 0;
            let negative_steps = 0;
            let headerLines = 0;
            let dataStarted = false;

            lines.forEach(line => {
                // Skip commented or empty lines
                if (line.startsWith('#') || line.startsWith('//') || line.startsWith('!') || line.startsWith(';') || line.trim() === '') {
                    if (!dataStarted) headerLines++;
                    return;
                }
                
                // Skip non-commented header lines (that contain letters)
                if (!dataStarted) {
                    if (/[a-zA-Z]/.test(line)) { 
                        headerLines++;
                        return;
                    }
                }

                const parts = line.trim().split(/[\s,;]+/);
                if (parts.length < 2) return;

                const x = parseFloat(parts[0]);
                const y = parseFloat(parts[1]);

                // If we get non-numeric data, it's either a header or a bad line
                if (isNaN(x) || isNaN(y)) {
                    if (!dataStarted) headerLines++; // Still in the header
                    return;
                }
                
                dataStarted = true; // First valid numeric pair found

                // --- vérif
                if (x > 0) positive_x_values++;

                if (last_x !== -Infinity) {
                    const dX = x - last_x;
                    if (dX < 0) {
                        negative_steps++; // Data is descending
                    } else if (dX > 0 && (dX < 0.0001 || dX > 0.2)) { 
                        suspicious_steps++; // Step size is weird
                    }
                }
                last_x = x;
                

                tth.push(x);
                intensity.push(y);
            });

            // --- Final checks (log warnings to console) ---
            if (tth.length > 10) { 
                if (positive_x_values / tth.length < 0.5) {
                    console.warn(`Data File (${fileName}) Warning: Most 2-theta (X) values are zero or negative. This is unusual for XRD data.`);
                }
                if (negative_steps / tth.length > 0.8) {
                     console.warn(`Data File (${fileName}) Warning: Data appears to be sorted in descending 2-theta order.`);
                }
                if (suspicious_steps / tth.length > 0.2) {
                    console.warn(`Data File (${fileName}) Warning: Many data points have a step size outside the typical range (0.0001° - 0.2°). Check file format.`);
                }
            } else if (tth.length === 0) {
                 throw new Error(`Could not parse any 2-column data from ${fileName}. File may be binary or have an unknown header.`);
            }

            return { tth, intensity };
        };

        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1;
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };


    ui.fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const MAX_FILE_SIZE_MB = 50;
        if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
            showStatus(`Error: File is too large (>${MAX_FILE_SIZE_MB} MB).`, "error");
            ui.fileInputLabel.classList.add('error');
            e.target.value = null; // Clear the input
            return;
        }

        ui.fileName.textContent = file.name;

        // --- Clear previous state 
        pickedPeaks = [];
        solutions = [];
        displayedSolutions = [];
        selectedSolution = null;
        currentHklList = [];
        updatePeakTable();
        updateSolutionsTable();
        updateStartIndexingButtonState();
        ui.solutionsLed.className = 'led-indicator gray';
        

        const text = await file.text();
        let parsed;
        try {
            parsed = detectAndParseFile(file.name, text);
        } catch (error) {
            showStatus(`Error parsing file: ${error.message}`, "error");
            console.error(error);
            ui.fileInputLabel.classList.add('error');
            return;
        }
        
        ui.fileInputLabel.classList.remove('error');

        if (!parsed || !parsed.tth || parsed.tth.length === 0) {
            showStatus("Could not read data from file.", "error");
            return;
        }

        // --- Handle wavelength from file, if any
        if (parsed.wavelength) {
            // This is a monochromatic, known wavelength from the file
            ui.wavelengthPreset.value = 'custom';
            ui.wavelength.value = parsed.wavelength.toFixed(5);
            ui.wavelength.readOnly = false; // Allow user to override
            ui.stripKa2Checkbox.checked = false;
            ui.stripKa2Checkbox.disabled = true;
            showStatus(`Loaded custom wavelength from file: ${parsed.wavelength.toFixed(5)} Å`, 'info');
        } else {
            // File has no wavelength, default to Cu
            ui.wavelengthPreset.value = 'Cu';
            handleWavelengthPresetChange(); // Apply the 'Cu' preset
        }
        
        // Store full dataset
        fullExperimentalData = { tth: parsed.tth, intensity: parsed.intensity };
        updateWorkingData(); // This will apply stripping if needed

        // Build experimental points for Chart.js
        const experimentalPoints = workingExperimentalData.tth.map((t, i) => ({
            x: t,
            y: Math.max(0, workingExperimentalData.intensity[i])
        }));

        // Hide placeholder, show chart, custom cursor depuis sept 2025
        ui.placeholder.style.display = 'none';
        ui.resultsContainer.style.display = 'flex';
        
        const yMax = Math.max(...workingExperimentalData.intensity) || 1000;

        // Initialize chart if not already created
        if (!xrdChart) {
            initializeChart(); // Use the dedicated function
            xrdChart.data.datasets[0].data = experimentalPoints;
            xrdChart.options.scales.y.min = -yMax * 0.05;
            xrdChart.options.scales.y.max = yMax * 1.1;
            xrdChart.update('none');
        } else {
            // Just update existing chart
            xrdChart.data.datasets[0].data = experimentalPoints;
            xrdChart.options.scales.y.min = -yMax * 0.05;
            xrdChart.options.scales.y.max = yMax * 1.1;
            xrdChart.resetZoom('none'); // Reset zoom on new file
            xrdChart.update('none');
        }

        // Enable peak controls
        ui.peakControls.classList.remove('hidden');
        ui.indexingControls.classList.remove('hidden');

              
        setupTthSliders();
        findPeaks();
        
    });

    // ---   setupTthSliders *** ---
    const setupTthSliders = () => {
        // Now uses workingExperimentalData, depuis 22 oct 2025, Ka2 stripping
        if (workingExperimentalData.tth.length === 0) return;
        const min = workingExperimentalData.tth[0];
        const max = workingExperimentalData.tth[workingExperimentalData.tth.length - 1];
        const step = (max - min) / 2000;
        [ui.tthMinSlider, ui.tthMaxSlider].forEach(el => { el.disabled = false; Object.assign(el, { min, max, step }); });
        const initialMin = Math.floor(min);
        const initialMax = Math.ceil(max);
        ui.tthMinSlider.value = initialMin;
        ui.tthMaxSlider.value = initialMax;
        ui.tthMinValue.textContent = initialMin.toFixed(2);
        ui.tthMaxValue.textContent = initialMax.toFixed(2);
        updatePlotRange(true);
    };

    const updatePlotRange = (updateYScale = false) => {
        if(!xrdChart) return;
        const min = parseFloat(ui.tthMinSlider.value);
        const max = parseFloat(ui.tthMaxSlider.value);
        xrdChart.options.scales.x.min = min;
        xrdChart.options.scales.x.max = max;
        if (updateYScale) {
            // Now uses workingExperimentalData
            const visibleIntensities = workingExperimentalData.intensity.filter((_, index) => {
                const tth = workingExperimentalData.tth[index];
                return tth >= min && tth <= max;
            });
            if (visibleIntensities.length > 0) {
                const yMaxInRange = Math.max(...visibleIntensities);
                xrdChart.options.scales.y.min = -yMaxInRange * 0.05;
                xrdChart.options.scales.y.max = yMaxInRange * 1.1;
            } else {
                const yMax = Math.max(...workingExperimentalData.intensity) || 1000;
                xrdChart.options.scales.y.min = -yMax * 0.05;
                xrdChart.options.scales.y.max = yMax * 1.1;
            }
        }
        xrdChart.update('none');
        updateAllMarkers();
    };


ui.tthMinSlider.addEventListener('input', () => {
        let minVal = parseFloat(ui.tthMinSlider.value);
        let maxVal = parseFloat(ui.tthMaxSlider.value);
        if (minVal >= maxVal) { minVal = maxVal - parseFloat(ui.tthMinSlider.step); ui.tthMinSlider.value = minVal; }
        ui.tthMinValue.textContent = minVal.toFixed(2);
        updatePlotRange();
        debouncedFindPeaks(); // 
    });
     ui.tthMaxSlider.addEventListener('input', () => {
        let minVal = parseFloat(ui.tthMinSlider.value);
        let maxVal = parseFloat(ui.tthMaxSlider.value);
        if (maxVal <= minVal) { maxVal = minVal + parseFloat(ui.tthMaxSlider.step); ui.tthMaxSlider.value = maxVal; }
        ui.tthMaxValue.textContent = maxVal.toFixed(2);
        updatePlotRange();
        debouncedFindPeaks(); // v114
    });

    ui.ballRadiusSlider.addEventListener('input', () => { ui.ballRadiusValue.textContent = ui.ballRadiusSlider.value; debouncedFindPeaks(); });
    ui.smoothingWidthSlider.addEventListener('input', () => { ui.smoothingWidthValue.textContent = ui.smoothingWidthSlider.value; debouncedFindPeaks(); });
    ui.peakThresholdSlider.addEventListener('input', () => { const value = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)); ui.peakThresholdValue.textContent = value.toFixed(1); debouncedFindPeaks(); });

    const rollingBallBackground = (y, radius, smoothingWidth) => {
        const n = y.length;
        if (n === 0 || radius <= 0) return new Array(n).fill(0);
        let smoothed_y = y;
        if (smoothingWidth > 1) {
            smoothed_y = new Array(n);
            const halfWidth = Math.floor(smoothingWidth / 2);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWidth);
                const end = Math.min(n, i + halfWidth + 1);
                let sum = 0;
                for (let j = start; j < end; j++) sum += y[j];
                smoothed_y[i] = sum / (end - start);
            }
        }
        const eroded = new Array(n);
        for (let i = 0; i < n; i++) {
            const start = Math.max(0, i - radius);
            const end = Math.min(n, i + radius + 1);
            let min = Infinity;
            for (let j = start; j < end; j++) if (smoothed_y[j] < min) min = smoothed_y[j];
            eroded[i] = min;
        }
        const background = new Array(n);
        for (let i = 0; i < n; i++) {
            const start = Math.max(0, i - radius);
            const end = Math.min(n, i + radius + 1);
            let max = -Infinity;
            for (let j = start; j < end; j++) if (eroded[j] > max) max = eroded[j];
            background[i] = max;
        }
        return background;
    };

    const savitzkyGolay = (data, windowSize = 9, polyOrder = 2) => {
        const n = data.length; if (n === 0) return [];
        windowSize = Math.max(3, windowSize); if (windowSize % 2 === 0) windowSize += 1; windowSize = Math.min(windowSize, n);
        const halfWindow = Math.floor(windowSize / 2);
        const result = new Array(n);
        const coefficients = (windowSize === 9 && polyOrder === 2) ? [-0.0909, 0.0606, 0.1687, 0.2333, 0.2545, 0.2333, 0.1687, 0.0606, -0.0909] : (() => { const weights = []; for (let i = -halfWindow; i <= halfWindow; i++) weights.push(1 - Math.abs(i) / (halfWindow + 1)); const sum = weights.reduce((a, b) => a + b, 0); return weights.map(w => w / sum); })();
        for (let i = 0; i < n; i++) {
            let smoothedValue = 0;
            for (let j = -halfWindow; j <= halfWindow; j++) {
                let idx = i + j;
                if (idx < 0) idx = Math.abs(idx);
                else if (idx >= n) idx = n - 1 - (idx - (n - 1));
                smoothedValue += data[idx] * coefficients[j + halfWindow];
            }
            result[i] = smoothedValue;
        }
        return result;
    };





    

    function findPeaks() {
        // Now uses workingExperimentalData
        if (!workingExperimentalData || !workingExperimentalData.intensity || workingExperimentalData.intensity.length < 5) return;
        
        const { intensity, tth } = workingExperimentalData; const n = tth.length;
        const minTth = parseFloat(ui.tthMinSlider.value) || tth[0];
        const maxTth = parseFloat(ui.tthMaxSlider.value) || tth[n - 1];
        const minHeightPercent = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)) || 2;
        const ballRadius = parseInt(ui.ballRadiusSlider.value, 10);
        const smoothingWidth = parseInt(ui.smoothingWidthSlider.value, 10);
        const background = rollingBallBackground(intensity, ballRadius, smoothingWidth);
        const backgroundCorrected = intensity.map((y, i) => Math.max(0, y - background[i]));
        const windowSize = Math.max(5, Math.min(11, Math.floor(n / 100)));
        const smoothed = savitzkyGolay(backgroundCorrected, windowSize, 2);
        const maxCorrectedIntensity = Math.max(...backgroundCorrected) || 1;
        const minAbsoluteHeight = (minHeightPercent / 100) * maxCorrectedIntensity;
        const calculateNoiseLevel = (data) => { const n_s = data.length; if (n_s < 10) return 0; const sample = []; for (let i = 0; i < n_s; i += Math.max(1, Math.floor(n_s / 100))) sample.push(data[i]); sample.sort((a, b) => a - b); const median = sample[Math.floor(sample.length / 2)]; const deviations = sample.map(x => Math.abs(x - median)); deviations.sort((a, b) => a - b); return deviations[Math.floor(deviations.length / 2)] * 1.4826; };
        const adaptiveThreshold = Math.max(minAbsoluteHeight, calculateNoiseLevel(backgroundCorrected) * 3);
        const localMaxIndices = [];
        for (let i = 1; i < n - 1; i++) {
            const current = smoothed[i]; if (current < adaptiveThreshold) continue;
            if (current > smoothed[i - 1] && current > smoothed[i + 1]) localMaxIndices.push(i);
            else if (current === smoothed[i + 1] && current > smoothed[i - 1]) { let plateauEnd = i + 1; while (plateauEnd < n - 1 && Math.abs(smoothed[plateauEnd] - current) < maxCorrectedIntensity * 0.001) plateauEnd++; if (plateauEnd < n && smoothed[plateauEnd] < current) localMaxIndices.push(Math.round((i + plateauEnd - 1) / 2)); i = plateauEnd - 1; }
        }
        const candidates = localMaxIndices.filter(idx => tth[idx] >= minTth && tth[idx] <= maxTth && backgroundCorrected[idx] >= adaptiveThreshold)
            .map(idx => ({ idx, tth: tth[idx], height: smoothed[idx], backgroundCorrectedHeight: backgroundCorrected[idx] }));
        
        // --- Refinement Loop (with 5-point and 3-point logic) ---
        const refinedPeaks = [];
        for (const peak of candidates) {
            const { idx } = peak; let refinedTth = peak.tth;

            // Calculate a robust average step size around the peak
            const avgStep = (idx > 0 && idx < n - 1) 
                ? (tth[idx+1] - tth[idx-1]) / 2.0 
                : (idx > 0 ? tth[idx] - tth[idx-1] : (idx < n-1 ? tth[idx+1] - tth[idx] : 0.01));

            // --- Try 5-point parabola first (more accurate) ---
            if (idx > 1 && idx < n - 2) { 
                const y1 = smoothed[idx - 2];
                const y2 = smoothed[idx - 1];
                const y3 = smoothed[idx];
                const y4 = smoothed[idx + 1];
                const y5 = smoothed[idx + 2];

                // 5-point least-squares quadratic fit (Savitzky-Golay coefficients)
                // Parabola y = ax^2 + bx + c, centered at x=0 (idx)
                const a = (2*y1 - y2 - 2*y3 - y4 + 2*y5) / 7.0;
                const b = (-2*y1 - y2 + 0*y3 + y4 + 2*y5) / 10.0;
                
                // Check for valid maximum (downward parabola, a < 0)
                if (a < -1e-10) { 
                    const delta = -b / (2 * a); // Vertex x = -b / (2a)
                    
                    // Sanity check: delta should be within the 5-point window
                    if (Math.abs(delta) < 2.0) { 
                        refinedTth = tth[idx] + delta * avgStep;
                    }
                }
            // --- FALLBACK: Use 3-point fit if 5-point fails or is near edge ---
            } else if (idx > 0 && idx < n - 1) { 
                const y1 = smoothed[idx - 1], y2 = smoothed[idx], y3 = smoothed[idx + 1]; 
                const denominator = 2 * (y1 - 2 * y2 + y3); 
                
                // Check for valid maximum (denominator < 0)
                if (denominator < -1e-10) { 
                    const delta = (y1 - y3) / denominator; 
                    if (Math.abs(delta) < 1.0) { // Sanity check: delta must be within -1 to 1
                        refinedTth = tth[idx] + delta * avgStep; 
                    } 
                } 
            } 
            // If neither fit works, refinedTth just remains peak.tth
            
            refinedPeaks.push({ ...peak, tth: refinedTth });
        }
        
        // --- Continue 
        refinedPeaks.sort((a, b) => a.tth - b.tth);
        const finalPeaks = []; const mergeThreshold = 0.02;
        for (const peak of refinedPeaks) {
            if (finalPeaks.length === 0 || Math.abs(peak.tth - finalPeaks[finalPeaks.length - 1].tth) >= mergeThreshold) finalPeaks.push(peak);
            else if (peak.height > finalPeaks[finalPeaks.length - 1].height) finalPeaks[finalPeaks.length - 1] = peak;
        }
        const lambda = parseFloat(ui.wavelength.value) || 1.54178;
        pickedPeaks = finalPeaks.map(p => { const d = lambda / (2 * Math.sin(p.tth * Math.PI / 360)); return { tth: p.tth, d: d, q: 1 / (d * d) }; });
        updatePeakTable(); updateStartIndexingButtonState();
    };


    const recalculatePeakValues = () => {
        const lambda = parseFloat(ui.wavelength.value);
        pickedPeaks.forEach(peak => { peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360)); peak.q = 1 / (peak.d * peak.d); });
    };

    const updatePeakTable = () => {
        ui.peakListBody.innerHTML = '';
        pickedPeaks.forEach((peak, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${index + 1}</td><td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td><td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td><td><button class="delete-peak-btn" data-index="${index}">X</button></td>`;
            ui.peakListBody.appendChild(row);
        });
        ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
        updateAllMarkers();
    };
    
    const updateStartIndexingButtonState = () => {
        const needed = 4 - pickedPeaks.length;
        if (needed > 0) { ui.startIndexingButton.disabled = true; ui.startIndexingButton.textContent = `Need ${needed} more peak${needed > 1 ? 's' : ''}`; } 
        else { ui.startIndexingButton.disabled = false; ui.startIndexingButton.textContent = 'Start Indexing'; }
    };

    ui.peakListBody.addEventListener('change', (e) => {
        if (e.target.classList.contains('peak-tth-input')) {
            const index = parseInt(e.target.dataset.index); const tth = parseFloat(e.target.value); const lambda = parseFloat(ui.wavelength.value);
            const d = lambda / (2 * Math.sin(tth * Math.PI / 360)); const q = 1 / (d*d);
            pickedPeaks[index] = {tth, d, q};
            e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
            updateAllMarkers(); updateStartIndexingButtonState();
        }
    });
     ui.peakListBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-peak-btn')) { const index = parseInt(e.target.dataset.index); pickedPeaks.splice(index, 1); updatePeakTable(); updateStartIndexingButtonState(); }
    });
    
    const setUIState = (indexing) => {
        isIndexing = indexing; document.body.style.cursor = indexing ? 'wait' : 'default';
        const controlsToDisable = [ 
            ui.fileInput, ui.peakThresholdSlider, ui.tthMinSlider, ui.tthMaxSlider, 
            ui.ballRadiusSlider, ui.smoothingWidthSlider, ui.wavelength, ui.tthError, 
            ui.maxVolume, ui.impurityPeaksInput, ui.refineZeroCheckbox, ...ui.systemCheckboxes, 
            ...ui.tabButtons, ui.wavelengthPreset, ui.stripKa2Checkbox 
        ];
        controlsToDisable.forEach(el => { if (el) el.disabled = indexing; });
        ui.peakListBody.querySelectorAll('input, button').forEach(el => { el.disabled = indexing; });
        ui.fileInputLabel.style.pointerEvents = indexing ? 'none' : 'auto'; ui.fileInputLabel.style.opacity = indexing ? '0.7' : '1';
        if (indexing) {
            ui.startIndexingButton.disabled = true;
           // ui.startIndexingButton.textContent = 'Indexing...';
            ui.reportButton.textContent = 'Stop'; ui.reportButton.disabled = false;
            ui.progressBarContainer.classList.remove('hidden'); ui.progressBar.style.width = '0%';
        } else {
            updateStartIndexingButtonState(); ui.reportButton.textContent = 'Generate PDF Report'; ui.reportButton.disabled = (solutions.length === 0);
            ui.progressBarContainer.classList.add('hidden'); ui.progressBar.style.width = '0%';
            
            // Re-enable controls based on state
            if (fullExperimentalData.tth.length > 0) { 
                ui.tthMinSlider.disabled = false; 
                ui.tthMaxSlider.disabled = false; 
                ui.wavelengthPreset.disabled = false;
                // Only re-enable stripping checkbox if not custom
                if (ui.wavelengthPreset.value !== 'custom') {
                    ui.stripKa2Checkbox.disabled = false;
                }
                // Only re-enable wavelength input if custom
                if (ui.wavelengthPreset.value === 'custom') {
                    ui.wavelength.disabled = false;
                }
            }
        }
    };
    
    const applyFinalSieve = (solutions) => {
        if (solutions.length <= 1) return solutions;
        showStatus('Applying final sieve to results...', 'info', 2000);
        const symmetryOrder = { 'cubic': 5, 'hexagonal': 4, 'tetragonal': 4, 'orthorhombic': 3, 'monoclinic': 2 };
        
        // Sort by Volume first
        solutions.sort((a, b) => a.volume - b.volume);
        
        const toKeep = new Array(solutions.length).fill(true);
        for (let i = 0; i < solutions.length; i++) {
            if (!toKeep[i]) continue;
            for (let j = i + 1; j < solutions.length; j++) {
                if (!toKeep[j]) continue;
                const vol_i = solutions[i].volume; const vol_j = solutions[j].volume;
                
                // Break if volumes are different by more than 1%
                if (vol_j > vol_i * 1.01) break;
                
                const sym_i = symmetryOrder[solutions[i].system]; const sym_j = symmetryOrder[solutions[j].system];
                
                if (sym_i > sym_j) {
                    toKeep[j] = false; // i has higher symmetry
                } else if (sym_j > sym_i) {
                    toKeep[i] = false; // j has higher symmetry
                    break;
                } else { 
                    // Symmetries are equal
                    const m20_i = solutions[i].m20;
                    const m20_j = solutions[j].m20;
                    
                    const m20_percent_tolerance = 0.02; // <-- This is 2%

                    // Check if i is significantly better than j (more than 2% higher than j)
                    if (m20_i > (m20_j * (1.0 + m20_percent_tolerance))) {
                        toKeep[j] = false; // i is clearly better
                    
                    // Check if j is significantly better than i (more than 2% higher than i)
                    } else if (m20_j > (m20_i * (1.0 + m20_percent_tolerance))) {
                        toKeep[i] = false; // j is clearly better
                        break;
                    
                    } else {
                        // M(20) are effectively equal, check for monoclinic beta convention
                        if (solutions[i].system === 'monoclinic') {
                            const beta_i = solutions[i].beta || 90;
                            const beta_j = solutions[j].beta || 90;
                            
                            // Calculate "unconventionality" (distance from 90)
                            const conventional_i = Math.abs(beta_i - 90);
                            const conventional_j = Math.abs(beta_j - 90);

                            if (conventional_i <= conventional_j) {
                                 toKeep[j] = false; // i is more conventional (or equal), keep i
                            } else {
                                 toKeep[i] = false; // j is more conventional, keep j
                                 break;
                            }
                        } else {
                            // For other systems with a tie, just keep the first one
                            toKeep[j] = false;
                        }
                    }
                }
            }
        }
        const filteredSolutions = solutions.filter((_, index) => toKeep[index]);
        const numDiscarded = solutions.length - filteredSolutions.length;
        if (numDiscarded > 0) showStatus(`Sieve discarded ${numDiscarded} redundant solution(s).`, 'success');
        return filteredSolutions.slice(0, 50);
    };

    const startIndexing = () => {

        const tthMinVal = parseFloat(ui.tthMinSlider.value);
    const tthMaxVal = parseFloat(ui.tthMaxSlider.value);
    const filteredPeaks = pickedPeaks.filter(p => p.tth >= tthMinVal && p.tth <= tthMaxVal);

    if (pickedPeaks.length < 4) { showStatus("Please find at least 4 peaks before starting indexing.", 'error'); return; }
    const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
    if (systemsToSearch.length === 0) { showStatus("Please select at least one crystal system to search.", "error"); return; }
    if (!workerURL) { showStatus("Error: Indexing engine is not available.", "error"); return; }
    
    const statusTextElement = document.getElementById('status-text');
    if (statusTextElement) statusTextElement.textContent = 'Initializing...';

    setUIState(true); 

    // --- Switch to Solutions Tab when start indexing, the user can see solutions and stop... Add the filtering at the end if the stop is manual
    ui.tabButtons.forEach(btn => btn.classList.remove('active'));
    ui.tabPanels.forEach(panel => panel.classList.remove('active'));
    document.querySelector('.tab-btn[data-tab="solutions"]').classList.add('active');
    document.getElementById('solutions-tab-content').classList.add('active');
    // --- END ---
    
    solutions = []; 
    displayedSolutions = [];
    selectedSolution = null; 
    currentHklList = []; 
    activeWorkers = [];
    updateSolutionsTable(); 
    updateAllMarkers();
    showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');

    const baseParams = {
        peaks: filteredPeaks,
        wavelength: parseFloat(ui.wavelength.value), // This is Ka1
        tth_error: parseFloat(ui.tthError.value),
        max_volume: parseFloat(ui.maxVolume.value),
        impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
        refineZero: ui.refineZeroCheckbox.checked,
        allowedSystems: systemsToSearch
    };

    const totalWorkers = systemsToSearch.length;
    const workerProgress = new Array(totalWorkers).fill(0);

    systemsToSearch.forEach((system, workerIndex) => { 
        const worker = new Worker(workerURL);
        activeWorkers.push(worker);
        worker.onmessage = (e) => {
            const { type, payload } = e.data;

            if (type === 'status') {
                if (statusTextElement) statusTextElement.textContent = payload;
            
            } else if (type === 'progress') {
                workerProgress[workerIndex] = payload; 
                const totalProgress = workerProgress.reduce((sum, p) => sum + p, 0) / totalWorkers;
                ui.progressBar.style.width = `${Math.min(100, totalProgress)}%`;

            } else if (type === 'solution') {
                solutions.push(payload);

                // depuis 25 oct: Call the dynamic pruning function ---
                pruneSolutions(); 
               

                if (solutions.length === 1) {
                    ui.solutionsLed.className = 'led-indicator green';
                }
                
                // These functions will now run on the potentially pruned list
                sortSolutions(); 
                const selectedSystems = Array.from(ui.systemCheckboxes)
                                             .filter(cb => cb.checked)
                                             .map(cb => cb.value);
                displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
                updateSolutionsTable();
            
            } else if (type === 'done') {
                workerProgress[workerIndex] = 100;
                const totalProgress = workerProgress.reduce((sum, p) => sum + p, 0) / totalWorkers;
                ui.progressBar.style.width = `${totalProgress}%`;

                worker.terminate();
                activeWorkers = activeWorkers.filter(w => w !== worker);
                
                    // Check if all workers are gone
                if (activeWorkers.length === 0) {
                    // Call the new finalize function for a normal finish
                    finalizeIndexing(false);
                }
            }
        };

worker.onerror = (err) => {
            console.error(`Worker for ${system} crashed:`, err.message, err);
            showStatus(`Error in ${system} worker. See console.`, "error", 8000);
            
            // Clean up the failed worker
            worker.terminate();
            activeWorkers = activeWorkers.filter(w => w !== worker);
            workerProgress[workerIndex] = 100; // Mark as "done" to not block completion
            
            // Check if all other workers are finished
            if (activeWorkers.length === 0) {
                finalizeIndexing(false); // Finalize with whatever solutions we have
            }
        };

        worker.postMessage({ ...baseParams, systemToSearch: system });
    });
};


    const finalizeIndexing = (stoppedByUser = false) => {
        const statusTextElement = document.getElementById('status-text');

        if (statusTextElement) statusTextElement.textContent = 'Applying final sieve...';
        solutions = applyFinalSieve(solutions); 
        
        if (statusTextElement) statusTextElement.textContent = 'Analyzing space groups...';

        // Get the 2-theta range from the sliders 
        const tthMinVal = parseFloat(ui.tthMinSlider.value);
        const tthMaxVal = parseFloat(ui.tthMaxSlider.value);

        // Pre-filter the peaks list based on the slider range
        const filteredPeaks = pickedPeaks.filter(p => p.tth >= tthMinVal && p.tth <= tthMaxVal);

        if (spaceGroupData) {
            solutions.forEach(sol => {
      
                // Pass the *filtered* peak list and the *max 2-theta* value
                // to the analysis function.
                sol.analysis = analyzeSystematicAbsences(
                    sol, 
                    filteredPeaks, // Pass the filtered list
                    spaceGroupData,
                    parseFloat(ui.wavelength.value),     
                    parseFloat(ui.tthError.value),
                    tthMaxVal // Pass the slider max value
                );
      
            });
        } else {
            console.warn('Space group data not available');
            solutions.forEach(sol => {
                sol.analysis = {
                    centering: 'Unknown (data not loaded)',
                    rankedSpaceGroups: [],
                    detectedExtinctions: []
                };
            });
        }
                                    
        if (statusTextElement) statusTextElement.textContent = '';
        
        // This will set isIndexing to false
        setUIState(false);    
        sortSolutions();
        displayedSolutions = [...solutions]; // Ensure displayedSolutions is updated
        updateSolutionsTable();

        if (solutions.length > 0) {
            const message = stoppedByUser ? 'Indexing stopped by user.' : 'Indexing complete.';
            showStatus(`${message} Found ${solutions.length} potential solution(s).`, 'success');
            ui.solutionsLed.className = 'led-indicator green';
        } else {
            const message = stoppedByUser ? 'Indexing stopped by user.' : 'Indexing finished.';
            showStatus(`${message} No valid solutions were found.`, 'info');
            // Led Only set to red if no solutions, otherwise keep it green if it was already green
            if (solutions.length === 0) {
                ui.solutionsLed.className = 'led-indicator red';
            }
        }
    };



    ui.startIndexingButton.addEventListener('click', startIndexing);

    ui.reportButton.addEventListener('click', () => {
        if (isIndexing) {
            // Kill all running workers... check for memory leaks if workers are going crazy with NaNs ?
            activeWorkers.forEach(w => w.terminate()); 
            activeWorkers = [];
            
            // Call the finalize function (passing 'true' for "stopped by user")
            // This will run the sieve, space group analysis, and then reset the UI.
            finalizeIndexing(true); 
            
        } else { 
            // If not indexing, just generate the report
            generatePDFReport(); 
        }
    });
    
    const sortSolutions = () => {
        const { column, direction } = sortState;
        const dir = direction === 'asc' ? 1 : -1;
        solutions.sort((a, b) => {
            if (column === 'system') {
                return (a.system || '').localeCompare(b.system || '') * dir;
            } else {
                let valA = a[column]; let valB = b[column];
                if (isNaN(valA) || valA == null) valA = -Infinity;
                if (isNaN(valB) || valB == null) valB = -Infinity;
                return (valA - valB) * dir;
            }
        });
    };

    const updateSolutionsTable = () => {
        ui.solutionsTableBody.innerHTML = '';
        displayedSolutions.forEach((sol, index) => {
            const row = document.createElement('tr'); row.dataset.index = index; 
            let paramsCell = '', anglesCell = '';
            switch(sol.system) {
                case 'cubic': paramsCell = `a = ${sol.a.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'tetragonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'hexagonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 120`; break;
                case 'orthorhombic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                case 'monoclinic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, ${sol.beta.toFixed(3)}, 90`; break;
                default: paramsCell = `${sol.a.toFixed(4)}`; anglesCell = `-`;
            }
            if (sol.zero_correction) {
                anglesCell += `<br><span style="font-size:0.9em; color: var(--text-dark);">(Z=${sol.zero_correction.toFixed(4)}°)</span>`;
            }
            row.innerHTML = `<td>${sol.system.substring(0,4)}</td><td>${paramsCell}</td><td>${anglesCell}</td><td>${sol.volume.toFixed(2)}</td><td>${sol.m20.toFixed(2)}</td>`;
            ui.solutionsTableBody.appendChild(row);
        });
        
        ui.solutionsTableHeaders.forEach(h => {
            h.classList.remove('sort-asc', 'sort-desc');
            if (h.dataset.sort === sortState.column) {
               h.classList.add(sortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
            }
        });
    };

    ui.solutionsTableBody.addEventListener('click', (e) => {
        const row = e.target.closest('tr'); if (!row) return;
        document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        const index = parseInt(row.dataset.index);
        selectedSolution = displayedSolutions[index];
        const lambda = parseFloat(ui.wavelength.value);
        const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
        currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);
        updateAllMarkers();
    });

    Chart.register({ id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x; let yAxis = chart.scales.y; let ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } });
    Chart.register({ id: 'legendMargin', beforeInit(chart) { const originalFit = chart.legend.fit; chart.legend.fit = function() { originalFit.bind(chart.legend)(); this.height += 15; }; } });

    //  initializeChart
    const initializeChart = () => {
        if (xrdChart) xrdChart.destroy();
        
        // Now uses workingExperimentalData, depuis 22 oct 2025, 
        const experimentalPoints = workingExperimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, workingExperimentalData.intensity[i]) }));
        const yMax = Math.max(...workingExperimentalData.intensity) || 1000;
        
        xrdChart = new Chart(ui.chartCanvas, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Intensity', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', showLine: true, borderWidth: 0.75, pointRadius: 1.5, pointHoverRadius: 4, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)' },
                    { type: 'bar', label: 'Observed Peaks', data: [], backgroundColor: 'rgba(239, 68, 68, 0.7)', barThickness: 1 },
                    { type: 'bar', label: 'Calculated Peaks', data: [], backgroundColor: 'rgba(59, 130, 246, 0.9)', barThickness: 1 }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                    y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.05, max: yMax * 1.1, suggestedMin: 0 }
                },
                plugins: {
                    zoom: {
                        pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => { updateAllMarkers(); } },
                        zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => { updateAllMarkers(); } }
                    },
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                if (!tooltipItems.length) return '';
                                const tth = tooltipItems[0].parsed.x;
                                let title = `2θ: ${tth.toFixed(3)}°`;
                                if (currentHklList && currentHklList.length > 0) {
                                    let closestPeak = null; let minDiff = Infinity;
                                    for (const hkl of currentHklList) {
                                        const diff = Math.abs(tth - hkl.tth);
                                        if (diff < minDiff) { minDiff = diff; closestPeak = hkl; }
                                    }
                                    const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                    if (closestPeak && minDiff < tolerance) {
                        title += `, HKL: (${closestPeak.h},${closestPeak.k},${closestPeak.l}), d: ${closestPeak.d.toFixed(4)} Å`;                                    }
                                }
                                return title;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label || '';
                                if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') return null;
                                let label = datasetLabel ? `${datasetLabel}: ` : '';
                                if (context.parsed.y !== null) { label += Math.round(context.parsed.y); }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    };

    ui.chartCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        if (!xrdChart || !xrdChart.chartArea) return;
        const { left, right, top, bottom } = xrdChart.chartArea;
        const zoomDirection = e.deltaY < 0 ? 1.1 : 0.9;
        const zoomOptions = { x: 1, y: 1 };
        if (e.offsetY > bottom && e.offsetX > left && e.offsetX < right) {
            zoomOptions.x = zoomDirection;
        } else if (e.offsetX < left && e.offsetY > top && e.offsetY < bottom) {
            zoomOptions.y = zoomDirection;
        } else if (e.offsetX >= left && e.offsetX <= right && e.offsetY >= top && e.offsetY <= bottom) {
            zoomOptions.x = zoomDirection;
            zoomOptions.y = zoomDirection;
        } else {
            return;
        }
        xrdChart.zoom(zoomOptions, 'none');
        updateAllMarkers();
    });

    const updateAllMarkers = () => {
        if (!xrdChart) return;
        const xMin = xrdChart.scales.x.min; const xMax = xrdChart.scales.x.max;
        const yMin = xrdChart.scales.y.min; const yMax = xrdChart.scales.y.max;
        const yRange = yMax - yMin;
        const markerHeight = yRange * 0.02;
        const visibleObsPeaks = pickedPeaks.filter(p => p.tth >= xMin && p.tth <= xMax);
        xrdChart.data.datasets[1].data = visibleObsPeaks.map(p => ({ x: p.tth, y: [yMin, yMin + markerHeight] }));
        if (selectedSolution) {
            const calculatedBottom = yMin + markerHeight * 1.2;
            const calculatedTop = calculatedBottom + markerHeight;
            const visibleCalcPeaks = currentHklList.filter(hkl => hkl.tth >= xMin && hkl.tth <= xMax);
            xrdChart.data.datasets[2].data = visibleCalcPeaks.map(hkl => ({ x: hkl.tth, y: [calculatedBottom, calculatedTop] }));
        } else {
            xrdChart.data.datasets[2].data = [];
        }
        xrdChart.update('none');
    };
    
    // generateHKL... il y a peut être un problème ici, je vais regenerer les HKL pour l'analyse, à voir
    const generateHKL = (maxTth, params, system) => {
        const { a, b, c, beta, lambda } = params; if (!a || !lambda) return [];
        const reflections = [];
        const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
        const q_max_limit = (1 / (d_min * d_min)) * 1.05;
        const h_max = Math.ceil(a / d_min);
        const k_max = b ? Math.ceil(b / d_min) : h_max;
        const l_max = c ? Math.ceil(c / d_min) : h_max;

        const processHKL = (h, k, l) => {
            if (h === 0 && k === 0 && l === 0) return;
            let inv_d_sq = 0;
            switch (system) {
                case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                case 'monoclinic':
                    const sinBeta = Math.sin(beta*Math.PI/180); const cosBeta = Math.cos(beta*Math.PI/180);
                    inv_d_sq = (1/(sinBeta*sinBeta))*(h*h/(a*a)+l*l/(c*c)-2*h*l*cosBeta/(a*c))+k*k/(b*b);
                    break;
            }
            if (inv_d_sq > 0 && inv_d_sq <= q_max_limit) {
                const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                if (sinThetaSq <= 1) {
                    const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                    reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                }
            }
        };

        if (system === 'cubic') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= k; l++) processHKL(h,k,l);
        } else if (system === 'hexagonal' || system === 'tetragonal') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= l_max; l++) {
                if(h===0 && k===0 && l===0) continue;
                processHKL(h,k,l);
            }
        } else if (system === 'orthorhombic') {
            for (let h = 0; h <= h_max; h++) for (let k = 0; k <= k_max; k++) for (let l = 0; l <= l_max; l++) processHKL(h,k,l);
        } else { // Monoclinic & Triclinic (fallback)
             for (let h = -h_max; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) { // k >= 0 is sufficient
                    for (let l = -l_max; l <= l_max; l++) {
                        
                        // Add uniqueness filter for monoclinic (k=0, h>0 or h=0,l>0)
                        if (system === 'monoclinic' && k === 0) {
                           if (h < 0) continue;
                           if (h === 0 && l <= 0) continue;
                        }
                        
                        processHKL(h,k,l);
                    }
                }
             }
        }

        const uniqueReflections = [];
        const tolerance = 1e-4;
        if (reflections.length > 0) {
            reflections.sort((a,b) => a.tth - b.tth);
            uniqueReflections.push(reflections[0]);
            for(let i=1; i<reflections.length; i++){
                if(Math.abs(reflections[i].tth - uniqueReflections[uniqueReflections.length-1].tth) > tolerance){
                    uniqueReflections.push(reflections[i]);
                }
            }
        }
        return uniqueReflections;
    };

    const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel');
    resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize';
        const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
        const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
        window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
    });
    
    ui.chartCanvas.addEventListener('contextmenu', e => { e.preventDefault(); if (xrdChart) { xrdChart.resetZoom('none'); updateAllMarkers(); } });
    ui.chartCanvas.addEventListener('click', (e) => {
        if (!e.ctrlKey || !xrdChart) return;
        const rect = xrdChart.canvas.getBoundingClientRect(); const x = e.clientX - rect.left;
        if (x < xrdChart.chartArea.left || x > xrdChart.chartArea.right) return;
        const tth = xrdChart.scales.x.getValueForPixel(x); if (!tth) return;
        const lambda = parseFloat(ui.wavelength.value); if (isNaN(lambda)) { showStatus('Wavelength is not a valid number.', 'error'); return; }
        const sin_theta = Math.sin(tth * Math.PI / 360); if (sin_theta <= 0) return;
        const d = lambda / (2 * sin_theta); const q = 1 / (d * d);
        pickedPeaks.push({ tth, d, q }); pickedPeaks.sort((a, b) => a.tth - b.tth);
        updatePeakTable(); updateStartIndexingButtonState(); showStatus(`Peak added at ${tth.toFixed(3)}°`, 'success', 2000);
    });

const formatWithError = (value, error) => {
        if (error === undefined || error === null || !isFinite(error) || error <= 0) {
            const places = Math.abs(value) > 10 ? 3 : 4;
            return value.toFixed(places);
        }
        const errorMagnitude = Math.floor(Math.log10(error));
        const firstSigDigit = Math.floor(error / Math.pow(10, errorMagnitude));

        let decimalPlaces;
        if (firstSigDigit >= 3) {
            // Use 1 significant figure for error (e.g., error=0.3 -> 1dp; error=3 -> 0dp)
            decimalPlaces = -errorMagnitude;
        } else {
            // Use 2 significant figures for error (e.g., error=0.28 -> 3dp; error=2.8 -> 1dp)
            decimalPlaces = -errorMagnitude + 1;
        }
        
        // Ensure decimalPlaces is reasonable and non-negative
        decimalPlaces = Math.max(0, Math.min(8, decimalPlaces));
        

        const multiplier = Math.pow(10, decimalPlaces);
        const roundedValue = (Math.round(value * multiplier) / multiplier).toFixed(decimalPlaces);
        const errorInLastDigits = Math.round(error * multiplier);
        return `${roundedValue}(${errorInLastDigits})`;
    };


    /* Niggli Math helpers, there are some duplictaes in this code*/
    const TAU = Math.PI * 2;
    const DEG = 180 / Math.PI;
    const RAD = Math.PI / 180;
    
    function clamp01(x) { return Math.max(-1, Math.min(1, x)); }
    function sgn(x) { return x >= 0 ? 1 : -1; }
    
    /** Build orthonormal Cartesian basis from cell params (a,b,c,alpha,beta,gamma) */
    function cellToBasis(a, b, c, alpha, beta, gamma) {
      const ca = Math.cos(alpha * RAD);
      const cb = Math.cos(beta * RAD);
      const cg = Math.cos(gamma * RAD);
      const sg = Math.sin(gamma * RAD);
    
      // a along x; b in xy-plane; c general
      const ax = a, ay = 0, az = 0;
      const bx = b * cg, by = b * sg, bz = 0;
    
      // cx derived to satisfy cos(beta) = (a·c)/(|a||c|)
      const cx = c * cb;
      // cy from cos(alpha) = (b·c)/(|b||c|)
      const cy = c * (ca - cb * cg) / sg;
      // cz from length
      const cz2 = c * c - cx * cx - cy * cy;
      const cz = cz2 > 0 ? Math.sqrt(cz2) : 0;
    
      // columns are a, b, c
      return [
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz],
      ];
    }
    
    /** Basis to cell params */
    function basisToCell(B) {
      const a = Math.hypot(B[0][0], B[1][0], B[2][0]);
      const b = Math.hypot(B[0][1], B[1][1], B[2][1]);
      const c = Math.hypot(B[0][2], B[1][2], B[2][2]);
    
      const dot_ab = B[0][0] * B[0][1] + B[1][0] * B[1][1] + B[2][0] * B[2][1];
      const dot_ac = B[0][0] * B[0][2] + B[1][0] * B[1][2] + B[2][0] * B[2][2];
      const dot_bc = B[0][1] * B[0][2] + B[1][1] * B[1][2] + B[2][1] * B[2][2];
    
      const alpha = Math.acos(clamp01(dot_bc / (b * c))) * DEG;
      const beta = Math.acos(clamp01(dot_ac / (a * c))) * DEG;
      const gamma = Math.acos(clamp01(dot_ab / (a * b))) * DEG;
    
      return { a, b, c, alpha, beta, gamma };
    }
    
    /** Metric & G6 */
    function basisToMetric(B) {
      // G = B^T B (columns are basis vectors)
      const v = (i, j) => B[0][i] * B[0][j] + B[1][i] * B[1][j] + B[2][i] * B[2][j];
      const G = [
        [v(0, 0), v(0, 1), v(0, 2)],
        [v(1, 0), v(1, 1), v(1, 2)],
        [v(2, 0), v(2, 1), v(2, 2)],
      ];
      // G6 (A, B, C, ξ, η, ζ) with doubled off-diagonals
      const A = G[0][0], Bm = G[1][1], C = G[2][2];
      const zeta = 2 * G[0][1]; // 2 a·b
      const eta = 2 * G[0][2];  // 2 a·c
      const xi = 2 * G[1][2];   // 2 b·c
      return { G, A, B: Bm, C, xi, eta, zeta };
    }
    
    /** Multiply 3x3 integer transform C on the right: columns transform as B' = B * C */
    function rightMul(B, C) {
      const out = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
      for (let r = 0; r < 3; r++) {
        for (let j = 0; j < 3; j++) {
          out[r][j] = B[r][0] * C[0][j] + B[r][1] * C[1][j] + B[r][2] * C[2][j];
        }
      }
      return out;
    }
    
    /** Multiply integer transforms: M' = M * C */
    function matMul3(M, C) {
      const out = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          out[i][j] = M[i][0] * C[0][j] + M[i][1] * C[1][j] + M[i][2] * C[2][j];
        }
      }
      return out;
    }
    
    /** Identity 3x3 */
    function I3() { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; }
    
    /** Sign function for A5–A7: returns +1 or -1 (never 0) */
    function signStrict(x) { return x >= 0 ? 1 : -1; }
    
    /***** ---------- Optional: centering -> primitive ---------- *****/
    const primitiveTransformByCentering = {
  P: [[1,0,0],[0,1,0],[0,0,1]],

  // base-centered
  A: [[0.5, 0.5, 0], [0.5, -0.5, 0], [0, 0, 1]],
  B: [[0.5, 0, 0.5], [0.5, 0, -0.5], [0, 1, 0]],
  C: [[1, 0, 0], [0, 0.5, 0.5], [0, -0.5, 0.5]],

  // body- and face-centered
  I: [[-0.5,  0.5,  0.5],
      [ 0.5, -0.5,  0.5],
      [ 0.5,  0.5, -0.5]],       // a'=(−a+b+c)/2, etc.  (det = 1/2)

  F: [[0,   0.5, 0.5],
      [0.5, 0,   0.5],
      [0.5, 0.5, 0  ]],          // a'=(b+c)/2, etc.     (det = 1/2)

  // rhombohedral from hex setting (obverse)
  R: [[ 2/3, -1/3, -1/3],
      [ 1/3,  1/3, -2/3],
      [ 1/3,  1/3,  1/3]],       // (det = 1/3)
};



    /***** ---------- Niggli reduction (A1–A8) ---------- *****/
    function niggliReduceFromCell(cell, opts = {}) {
      const { a, b, c, alpha, beta, gamma, centering = 'P' } = cell;
      const epsUser = opts.eps;
      const maxIter = opts.maxIterations || 1000;
    
      // Start from a primitive basis (if needed)
      let B = cellToBasis(a, b, c, alpha, beta, gamma);
      
      // --- MODIFICATION: Handle complex centering strings like 'Body-centered (I)' ---
      let centeringKey = (centering || 'P').toUpperCase();
      const match = centeringKey.match(/\(([A-Z])\)/); // Look for (I), (F), (C), etc.
      if (match) {
          centeringKey = match[1];
      } else if (centeringKey.length > 1) {
          // Fallback: take the first letter if it's not a complex string
          centeringKey = centeringKey.charAt(0);
      }
      // --- END MODIFICATION ---

      const Cp = primitiveTransformByCentering[centeringKey];
      
      if (!Cp) {
        // Don't throw an error, just warn and proceed with P
        console.warn(`Unknown centering type: ${centering}. Defaulting to 'P'.`);
        B = cellToBasis(a, b, c, alpha, beta, gamma);
      }
      
      if (Cp && centeringKey !== 'P') {
        B = rightMul(B, Cp);
      }
    
      // Global transform from input to Niggli
      let T = (Cp && centeringKey !== 'P') ? Cp.map(row => row.slice()) : I3();
    
      // Tolerance: relative to typical squared length
      let { A, B: BB, C, xi, eta, zeta } = basisToMetric(B);
      const scale = Math.max(A, BB, C) || 1;
      const eps = typeof epsUser === 'number' ? epsUser : 1e-8 * scale;
    
      function updateState() {
        const s = basisToMetric(B);
        A = s.A; BB = s.B; C = s.C; xi = s.xi; eta = s.eta; zeta = s.zeta;
      }
    
      function angleSigns() {
        let l = 0, m = 0, n = 0;
        if (xi < -eps) l = -1; else if (xi > eps) l = 1;
        if (eta < -eps) m = -1; else if (eta > eps) m = 1;
        if (zeta < -eps) n = -1; else if (zeta > eps) n = 1;
        return { l, m, n, lmn: l * m * n };
      }
    
      // Main loop: apply A1..A8 until nothing changes
      let iter;
      for (iter = 0; iter < maxIter; iter++) {
        let changed = false;
    
        // A1: Ensure A <= B
        if ((A > BB + eps) || (Math.abs(A - BB) <= eps && Math.abs(xi) > Math.abs(eta) + eps)) {
          const C1 = [[0, -1, 0], [-1, 0, 0], [0, 0, -1]];
          B = rightMul(B, C1); T = matMul3(T, C1);
          updateState();  
          changed = true;
        }
    
        // A2: Ensure B <= C
        if (!changed && ((BB > C + eps) || (Math.abs(BB - C) <= eps && Math.abs(eta) > Math.abs(zeta) + eps))) {
          const C2 = [[-1, 0, 0], [0, 0, -1], [0, -1, 0]];
          B = rightMul(B, C2); T = matMul3(T, C2);
          updateState();  
          changed = true;
        }
        
        if (changed) {
          continue; // Restart from A1
        }
    
        // A3 & A4: Handle angle signs
        const { l, m, n, lmn } = angleSigns();
        
        // A3: If all angles have the same sign, make them all positive
        if (lmn === 1) {
          const i = (l === -1) ? -1 : 1;
          const j = (m === -1) ? -1 : 1;
          const k = (n === -1) ? -1 : 1;
          const C3 = [[i, 0, 0], [0, j, 0], [0, 0, k]];
          B = rightMul(B, C3); T = matMul3(T, C3);
          updateState();  
          continue;
        }
    
        // A4: If not all same sign (lmn = 0 or -1), make non-positive
        if (lmn !== 1) {
          let i = 1, j = 1, k = 1;
          
          if (l === 1) i = -1;
          if (m === 1) j = -1;
          if (n === 1) k = -1;
          
          const C4 = [[i, 0, 0], [0, j, 0], [0, 0, k]];
          B = rightMul(B, C4); T = matMul3(T, C4);
          updateState();
        }
    
        // A5: Reduce |xi|
        if ((Math.abs(xi) > BB + eps) ||
            (Math.abs(BB - xi) <= eps && (2 * eta < zeta - eps)) ||
            (Math.abs(BB + xi) <= eps && (zeta < -eps))) {
          const C5 = [[1, 0, 0], [0, 1, -signStrict(xi)], [0, 0, 1]];
          B = rightMul(B, C5); T = matMul3(T, C5);
          updateState();
          continue; // Restart from A1
        }
    
        // A6: Reduce |eta|
        if ((Math.abs(eta) > A + eps) ||
            (Math.abs(A - eta) <= eps && (2 * xi < zeta - eps)) ||
            (Math.abs(A + eta) <= eps && (zeta < -eps))) {
          const C6 = [[1, 0, -signStrict(eta)], [0, 1, 0], [0, 0, 1]];
          B = rightMul(B, C6); T = matMul3(T, C6);
          updateState();
          continue; // Restart from A1
        }
    
        // A7: Reduce |zeta|
        if ((Math.abs(zeta) > A + eps) ||
            (Math.abs(A - zeta) <= eps && (2 * xi < eta - eps)) ||
            (Math.abs(A + zeta) <= eps && (eta < -eps))) {
          const C7 = [[1, -signStrict(zeta), 0], [0, 1, 0], [0, 0, 1]];
          B = rightMul(B, C7); T = matMul3(T, C7);
          updateState();
          continue; // Restart from A1
        }
    
        // A8: Final reduction step
        if ((xi + eta + zeta + A + BB < -eps) ||
            (Math.abs(xi + eta + zeta + A + BB) <= eps && (2 * (A + eta) + zeta > eps))) {
          const C8 = [[1, 0, 1], [0, 1, 1], [0, 0, 1]];
          B = rightMul(B, C8); T = matMul3(T, C8);
          updateState();
          continue; // Restart from A1
        }
    
        // No rule fired => reduced
        break;
      }
    
      const reduced = basisToCell(B);
      const finalMetric = basisToMetric(B);
      
      return {
        cell: {
          a: reduced.a,  
          b: reduced.b,  
          c: reduced.c,
          alpha: reduced.alpha,  
          beta: reduced.beta,  
          gamma: reduced.gamma
        },
        transform: T,
        basis: B,
        metric: finalMetric.G,
        g6: {
          A: finalMetric.A,
          B: finalMetric.B,
          C: finalMetric.C,
          xi: finalMetric.xi,
          eta: finalMetric.eta,
          zeta: finalMetric.zeta
        },
        iterations: iter,
        converged: iter < maxIter
      };
    }
    
    


    /***** ---------- Convenience wrapper ---------- *****/
    function reduceToNiggliCell(sol, opts) {
      // Accepts your solution object (sol)
      const a = sol.a, b = sol.b || sol.a, c = sol.c || sol.a; // Handle cubic/tetragonal
      const alpha = sol.alpha ?? 90;
      const beta = sol.beta ?? 90;
      const gamma = sol.gamma ?? (sol.system === 'hexagonal' ? 120 : 90);
      
      // Use the detected centering string from the analysis step
      const centering = (sol.analysis?.centering) || 'P';
      
      return niggliReduceFromCell({ a, b, c, alpha, beta, gamma, centering }, opts);
    }


    
// --- [UPDATED FUNCTION V9] Centered Cell Generator (Removed Volume Check) ---

/**
 * Generates the conventional centered cell representations (I, F, A, B, C, R)
 * corresponding to a primitive Niggli cell, filtered by the original system's
 * possible Bravais types and angle constraints (60-150 deg).
 * Uses renamed helper functions to avoid scope conflicts. Removes redundant volume check.
 *
 * @param {object} niggliCell - The Niggli cell parameters {a, b, c, alpha, beta, gamma}.
 * @param {string} [originalSystem=null] - Optional: The original crystal system ('cubic', 'tetragonal', etc.)
 * @returns {object} { primitiveCells: Array<object>, centeredCells: object }
 */
function generateEquivalentCells(niggliCell, N_ignored, originalSystem = null) { // N parameter ignored
    const results = {
        primitiveCells: [],
        centeredCells: {}
    };

    if (!niggliCell || typeof niggliCell !== 'object' || !niggliCell.a) {
        console.error("Invalid Niggli cell provided.");
        return results;
    }

    const minAngle = 60.0, maxAngle = 150.0;

    // Use renamed helper functions
    const niggliSystemGuess = getSymmetryForEquivCells(niggliCell.a, niggliCell.b, niggliCell.c, niggliCell.alpha, niggliCell.beta, niggliCell.gamma);
    const niggliVolume = getVolumeForEquivCells({ ...niggliCell, system: niggliSystemGuess });
    results.primitiveCells.push({ ...niggliCell, description: "Niggli Cell", centering: 'P', volume: niggliVolume });

    // --- Generate Conventional Centered Cells ONLY ---
    if (originalSystem) {
        const niggliBasis = cellToBasis(
            niggliCell.a, niggliCell.b, niggliCell.c,
            niggliCell.alpha, niggliCell.beta, niggliCell.gamma
        );

        const primitiveToCenteredTransforms = {
            'I': [[0,1,1],[1,0,1],[1,1,0]],
            'F': [[-1,1,1],[1,-1,1],[1,1,-1]],
            'A': [[1,1,0],[-1,1,0],[0,0,1]],
            'B': [[1,0,1],[0,1,0],[-1,0,1]],
            'C': [[1,0,0],[0,1,-1],[0,1,1]],
            'R': [[1,0,1],[-1,1,1],[0,-1,1]]
        };

        const validBravaisCenterings = {
            'cubic': ['P', 'I', 'F'], 'tetragonal': ['P', 'I'], 'orthorhombic': ['P', 'I', 'F', 'A', 'B', 'C'],
            'hexagonal': ['P', 'R'], 'monoclinic': ['P', 'A', 'B', 'C', 'I'], 'triclinic': ['P']
        };
        const allowedCenterings = validBravaisCenterings[originalSystem] || ['P'];

        for (const [centeringType, transform] of Object.entries(primitiveToCenteredTransforms)) {
            if (allowedCenterings.includes(centeringType) && centeringType !== 'P') {
                try {
                    const centeredBasis = rightMul(niggliBasis, transform);
                    const centeredCellParams = basisToCell(centeredBasis);

                    // Check validity AND angle limits
                    if (Object.values(centeredCellParams).every(v => isFinite(v) && v > -1e-6) &&
                        [centeredCellParams.alpha, centeredCellParams.beta, centeredCellParams.gamma].every(a => a >= minAngle && a <= maxAngle))
                    {
                        // Use renamed helper function
                        const systemGuess = getSymmetryForEquivCells(centeredCellParams.a, centeredCellParams.b, centeredCellParams.c, centeredCellParams.alpha, centeredCellParams.beta, centeredCellParams.gamma);

                        const systemAllowed = (centeringType === 'I' && ['cubic', 'tetragonal', 'orthorhombic', 'monoclinic'].includes(systemGuess)) ||
                                              (centeringType === 'F' && ['cubic', 'orthorhombic'].includes(systemGuess)) ||
                                              (['A','B','C'].includes(centeringType) && ['orthorhombic', 'monoclinic'].includes(systemGuess)) ||
                                              (centeringType === 'R' && ['hexagonal', 'trigonal'].includes(systemGuess));

                        if (systemAllowed) {
                            // Use renamed helper function
                            const centeredVolume = getVolumeForEquivCells({ ...centeredCellParams, system: systemGuess });
                            // const expectedVolumeFactor = {'I': 2, 'F': 4, 'A': 2, 'B': 2, 'C': 2, 'R': 3}[centeringType] || 1;

                            // --- REMOVED VOLUME CHECK ---
                            // if (Math.abs(centeredVolume * expectedVolumeFactor - niggliVolume) < niggliVolume * 0.01) {
                                results.centeredCells[centeringType] = {
                                    ...centeredCellParams, system: systemGuess, centering: centeringType,
                                    volume: centeredVolume, description: `Conventional ${centeringType}-centered`
                                };
                            // } else { console.warn(`Generated ${centeringType}-centered cell volume (${centeredVolume.toFixed(4)}) inconsistent with primitive volume (${niggliVolume.toFixed(4)}), skipping.`); }
                        } else { /* console.warn(`Generated ${centeringType}-centered cell for ${originalSystem} has incompatible geometry (${systemGuess}), skipping.`); */ }
                    } else { /* console.warn(`Generated ${centeringType}-centered cell had invalid parameters or angles.`); */ }
                } catch (error) { console.error(`Error transforming to ${centeringType}-centered cell:`, error); }
            }
        }
    } // End centered cell generation

    return results;
}

const generatePDFReport = async () => {
        if (displayedSolutions.length === 0) {
            showStatus("No solutions found to generate a report.", 'info');
            return;
        }

        const tthMinVal = parseFloat(ui.tthMinSlider.value);
        const tthMaxVal = parseFloat(ui.tthMaxSlider.value);
        const reportPeaks = pickedPeaks.filter(p => p.tth >= tthMinVal && p.tth <= tthMaxVal);

        if (reportPeaks.length === 0) {
             showStatus("No peaks selected in the current 2-theta range for the report.", 'info');
             return;
        }

        ui.reportButton.textContent = 'Generating...';
        ui.reportButton.disabled = true;
        document.body.style.cursor = 'wait';
    
        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'p',
                unit: 'mm',
                format: 'a4'
            });
    
            const margin = 15;
            let yPos = 20;
            const pdfWidth = doc.internal.pageSize.getWidth();
            const lambda = parseFloat(ui.wavelength.value);
            const tthError = parseFloat(ui.tthError.value);
            
            const tthMinVal = parseFloat(ui.tthMinSlider.value);
            const tthMaxVal = parseFloat(ui.tthMaxSlider.value);
            
            // --- fonts and sizes, see later, this is esthetics, osef
            const FONT = {
                TITLE: 'helvetica',
                LABEL: 'helvetica',
                DATA: 'courier'
            };
            const SIZE = {
                TITLE: 18,
                H1: 14,
                H2: 12,
                BODY: 9,
                TABLE_HEADER: 8,
                TABLE_BODY: 8,
                SMALL: 7
            };
    
            // --- Page Header & Chart ---
            const now = new Date();
            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            const versionInfo = document.getElementById('app-footer')?.textContent || 'Combs, unknown version';
            const programURL = window.location.href;
            
    
            doc.setFont(FONT.TITLE, 'bold').setFontSize(SIZE.TITLE).text('Combs - Powder Indexing Report', pdfWidth / 2, yPos, { align: 'center' });
            yPos += 10;
            
            doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
            doc.text(`Generated:`, margin, yPos);
            doc.setFont(FONT.DATA, 'normal').text(timestamp, margin + 25, yPos);
            yPos += 5;
    
            // --- Add URL and Version lines
            doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
            doc.text(`URL:`, margin, yPos);
            doc.setFont(FONT.DATA, 'normal').text(programURL, margin + 25, yPos);
            yPos += 5;
    
            doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY);
            doc.text(`Version:`, margin, yPos);
            doc.setFont(FONT.DATA, 'normal').text(versionInfo, margin + 25, yPos);
            yPos += 5;
            
            doc.setFont(FONT.LABEL, 'normal').text(`Data File:`, margin, yPos);
            doc.setFont(FONT.DATA, 'normal').text(ui.fileName.textContent, margin + 25, yPos);
            yPos += 10;
            
            const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff', scale: 2 });
            const imgData = canvas.toDataURL('image/png');
            const imgProps = doc.getImageProperties(imgData);
            const availableWidth = pdfWidth - 2 * margin;
            let imgHeight = (imgProps.height * availableWidth) / imgProps.width;
            doc.addImage(imgData, 'PNG', margin, yPos, availableWidth, imgHeight);
    
            // --- Parameters & Summary Table Page ---
            doc.addPage();
            yPos = 20;
    
            // --- Indexing Parameters Section ---
            doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1).text('Indexing Parameters', margin, yPos);
            yPos += 8;
    
            // --- modif le 21 oct avec Ka2 strip
            const presetText = ui.wavelengthPreset.options[ui.wavelengthPreset.selectedIndex].text;
            const paramData = [
                { label: 'Radiation:', value: presetText },
                { label: 'Max Volume (A^3):', value: ui.maxVolume.value },
                { label: 'Ka1 Wavelength (A):', value: parseFloat(ui.wavelength.value).toFixed(5) },
                { label: 'Tolerance (2theta):', value: ui.tthError.value },
                { label: 'Ka2 Stripped:', value: ui.stripKa2Checkbox.checked ? 'True' : 'False' },
                { label: 'Impurity Peaks:', value: ui.impurityPeaksInput.value },
                { label: 'Min Peak (%):', value: ui.peakThresholdValue.textContent },
                { label: 'Refine Zero:', value: ui.refineZeroCheckbox.checked ? 'True' : 'False' },
                { label: '2theta Min (deg):', value: tthMinVal.toFixed(2) },
                { label: '2theta Max (deg):', value: tthMaxVal.toFixed(2) },
            ];
            // ---
    
            const col1X = margin;
            const col2X = margin + 85;
            const labelWidth = 35;
    
            paramData.forEach((item, index) => {
                const isCol1 = index % 2 === 0;
                const x = isCol1 ? col1X : col2X;
                if (isCol1) yPos += 5;
                
                doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text(item.label, x, yPos);
                doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(String(item.value), x + labelWidth, yPos);
            });
            yPos += 7;
            
            doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.BODY).text('Systems Searched:', margin, yPos);
            const systems = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value.charAt(0).toUpperCase() + cb.value.slice(1));
            const systemsText = systems.join(', ');
            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(systemsText, margin + labelWidth, yPos);
            yPos += 8;
    
            doc.setDrawColor(200); doc.line(margin, yPos, pdfWidth - margin, yPos); yPos += 8;
    
            // --- Indexing Solutions Summary Section ---
            doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1).text('Indexing Solutions Summary', margin, yPos); yPos += 8;
            doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER);
            doc.text('Sys', margin, yPos);
            // Get N from the *first* solution, or fall back to peak count
            const first_sol_n_20 = (displayedSolutions.length > 0 && displayedSolutions[0].n_20) ? displayedSolutions[0].n_20 : Math.min(20, reportPeaks.length);
            doc.text(`M(${first_sol_n_20})`, margin + 15, yPos);
            doc.text(`F(${first_sol_n_20})`, margin + 30, yPos);
            doc.text('Volume(A^3)', margin + 45, yPos);
            doc.text('Parameters', margin + 75, yPos);
            yPos += 5;
    
            doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY);
            displayedSolutions.slice(0, 30).forEach(sol => {
                if (yPos > 280) { doc.addPage(); yPos = 20; }
                let paramStr = '';
                const p = sol.errors || {};
                switch (sol.system) {
                     case 'cubic': paramStr = `a=${formatWithError(sol.a, p.s_a)}`; break;
                     case 'tetragonal': paramStr = `a=${formatWithError(sol.a, p.s_a)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                     case 'hexagonal': paramStr = `a=${formatWithError(sol.a, p.s_a)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                     case 'orthorhombic': paramStr = `a=${formatWithError(sol.a, p.s_a)}, b=${formatWithError(sol.b, p.s_b)}, c=${formatWithError(sol.c, p.s_c)}`; break;
                     case 'monoclinic': paramStr = `a=${formatWithError(sol.a, p.s_a)}, b=${formatWithError(sol.b, p.s_b)}, c=${formatWithError(sol.c, p.s_c)}, beta=${formatWithError(sol.beta, p.s_beta)}`; break;
                }
                doc.text(sol.system.substring(0,4), margin, yPos);
                doc.text(sol.m20.toFixed(2), margin + 15, yPos);
                doc.text((sol.fN_20 || 0).toFixed(2), margin + 30, yPos); // Use fN_20
                doc.text(sol.volume.toFixed(2), margin + 45, yPos);
                doc.text(paramStr, margin + 75, yPos);
                yPos += 5;
            });
    





// --- Detailed Solution Pages ---
            displayedSolutions.forEach((sol, solIndex) => {
                doc.addPage(); yPos = 20;
                
                // --- 1. MAIN TITLE (Large, Bold) ---
                doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.H1); // Changed to SIZE.H1
                doc.text(`Details for Solution #${solIndex + 1}: ${sol.system}`, margin, yPos); 
                yPos += 8; // Increased spacing after main title
                
                // --- 2. PARAMETERS AND VOLUME ---
                doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY); // Data font size
                const p = sol.errors || {};
                const paramLines = [];
                switch (sol.system) {
                     case 'cubic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`); break;
                     case 'tetragonal': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                     case 'hexagonal': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                     case 'orthorhombic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `b = ${formatWithError(sol.b, p.s_b)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`); break;
                     case 'monoclinic': paramLines.push(`a = ${formatWithError(sol.a, p.s_a)} A`, `b = ${formatWithError(sol.b, p.s_b)} A`, `c = ${formatWithError(sol.c, p.s_c)} A`, `beta = ${formatWithError(sol.beta, p.s_beta)} deg`); break;
                }
                paramLines.forEach(line => { doc.text(line, margin, yPos); yPos += 4; });
                doc.text(`Volume = ${sol.volume.toFixed(2)} A^3`, margin, yPos); 
               
                yPos += 4; 




                               doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY); // Back to body font
                if (sol.zero_correction !== undefined) { 
                    doc.text(`Zero Error (2theta) = ${formatWithError(sol.zero_correction, p.s_zero)} deg`, margin, yPos); 
                    yPos += 4; 
                }
               
             //      yPos += 4; // Spacing after parameters
                              const n_20_pdf = sol.n_20 || Math.min(20, reportPeaks.length);
                const m_20_str = `M(${n_20_pdf}) = ${sol.m20.toFixed(2)}`;
                const f_20_str = `F(${n_20_pdf}) = ${(sol.fN_20 || 0).toFixed(2)}`;
                doc.text(`${m_20_str}, ${f_20_str}`, margin, yPos); 
                yPos += 4;

                const n_all_pdf = sol.n_all || reportPeaks.length;
                const m_all_str = `M(${n_all_pdf}) = ${(sol.m_all || 0).toFixed(2)}`;
                const f_all_str = `F(${n_all_pdf}) = ${(sol.fN_all || 0).toFixed(2)}`;
                doc.text(`${m_all_str}, ${f_all_str}`, margin, yPos); 
                
    
               yPos += 7;
             

                // --- 3. NIGGLI REDUCED CELL (Moved up, Non-bold) ---
                doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.H2).text('Niggli Reduced Cell:', margin, yPos); // Changed to H2, normal
                yPos += 6;

                try {
                    const niggliResult = reduceToNiggliCell(sol);
                    const nCell = niggliResult.cell;

                    const niggliLines = [
                        `a = ${nCell.a.toFixed(4)} A`,
                        `b = ${nCell.b.toFixed(4)} A`,
                        `c = ${nCell.c.toFixed(4)} A`,
                        `alpha = ${nCell.alpha.toFixed(3)} deg`,
                        `beta  = ${nCell.beta.toFixed(3)} deg`,
                        `gamma = ${nCell.gamma.toFixed(3)} deg`                       
                    ];

                    doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY); // Use smaller table body font

                    const col1X_niggli = margin + 5;
                    const col2X_niggli = margin + 65;

                    doc.text(niggliLines[0], col1X_niggli, yPos);
                    doc.text(niggliLines[3], col2X_niggli, yPos);
                    yPos += 4;

                    doc.text(niggliLines[1], col1X_niggli, yPos);
                    doc.text(niggliLines[4], col2X_niggli, yPos);
                    yPos += 4;

                    doc.text(niggliLines[2], col1X_niggli, yPos);
                    doc.text(niggliLines[5], col2X_niggli, yPos);
                    yPos += 5;

                } catch (niggliError) {
                    console.error("Niggli reduction failed:", niggliError);
                    doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.BODY);
                    doc.text('Reduction failed. See console for error.', margin + 5, yPos);
                    yPos += 5;
                }
                
                
               yPos += 4;


 
                // --- 5. LATTICE CENTERING (Non-bold) ---
                if (sol.analysis) {
                     doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.H2).text(`Lattice Centering:`, margin, yPos); // Changed to H2, normal
                     doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(sol.analysis.centering, margin + 42, yPos); 
                     yPos += 7; // Spacing
                     


                     // --- 6. POSSIBLE SPACE GROUPS (Non-bold) ---
                     doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.H2).text('Possible Extinctions:', margin, yPos); // Changed to H2, normal
                     let extinctionList = sol.analysis.detectedExtinctions || [];
                     let extinctionText = "";

                     if (extinctionList.length > 0 && extinctionList[0] !== "None detected") {
                         extinctionText = extinctionList.join(', '); // Join into a single string
                     } else {
                         extinctionText = "None clearly detected";
                         doc.setFont(FONT.DATA, 'italic'); // Use italic for "None"
                     }

                     // Define the starting X position and max width for the extinction text
                     const extinctionX = margin + 42;
                     const extinctionMaxWidth = pdfWidth - extinctionX - margin; // Max width available

                     // Split the text into lines that fit the max width
                     const extinctionLines = doc.splitTextToSize(extinctionText, extinctionMaxWidth);

                     // Print the lines, adjusting yPos for each line
                     doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY); // Ensure normal font
                     extinctionLines.forEach(line => {
                         if (yPos > 280) { // Check for page break before printing line
                             doc.addPage();
                             yPos = 20;
                         }
                         doc.text(line, extinctionX, yPos);
                         yPos += 4; // Move down for the next line (adjust line spacing if needed)
                     });
                     // yPos += 3; // Add a bit more space after the block if needed (adjust from 7)
                     yPos += 3; // Total spacing after extinctions (was 7 before)


                     // --- 7. POSSIBLE SPACE GROUPS (Non-bold) ---
                     if (sol.analysis.rankedSpaceGroups && sol.analysis.rankedSpaceGroups.length > 0) {
                         if (yPos > 260) { doc.addPage(); yPos = 20; }
                         doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.H2).text('Possible Space Groups:', margin, yPos); // Changed to H2, normal
                         yPos += 6; // Slightly more space before the list starts

                         const sgList = sol.analysis.rankedSpaceGroups.slice(0, 20); // Limit to top 20
                         const groupsByViolation = {};
                         sgList.forEach(sg => {
                             const v = sg.violations || 0;
                             if (!groupsByViolation[v]) groupsByViolation[v] = [];
                             // Store settings under the same number together for grouping later
                             const existingEntry = groupsByViolation[v].find(entry => entry.number === sg.number);
                             if (existingEntry) {
                                 existingEntry.settings.push({ symbol: sg.symbol, violations: sg.violatedReflections });
                             } else {
                                 groupsByViolation[v].push({
                                     number: sg.number,
                                     standardSymbol: sg.standardSymbol, // Store standard symbol for reference if needed
                                     settings: [{ symbol: sg.symbol, violations: sg.violatedReflections }]
                                 });
                             }
                         });

                         const maxViolationsToShow = 2; // Show details for 0, 1, and 2 violations

                         for (let v = 0; v <= maxViolationsToShow; v++) {
                             if (groupsByViolation[v] && groupsByViolation[v].length > 0) {
                                 if (yPos > 270) { doc.addPage(); yPos = 20; }
                                 // Sub-heading for violations (bold, but smaller than H2)
                                 doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.BODY).text(`[${v} violation${v !== 1 ? 's' : ''}]:`, margin, yPos);
                                 yPos += 5;

                                 // Iterate through each unique space group number within this violation count
                                 groupsByViolation[v].forEach(groupEntry => {
                                     if (yPos > 280) { doc.addPage(); yPos = 20; }

                                     // Combine symbols for the same number
                                     const symbolsString = groupEntry.settings.map(s => s.symbol).join(', ');
                                     const groupLine = `${groupEntry.number}: ${symbolsString}`;

                                     doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY); // Use table body font
                                     
                                     // Check if the group line itself needs wrapping
                                     const groupLinesWrapped = doc.splitTextToSize(groupLine, pdfWidth - margin - margin - 5); // Allow some padding
                                     groupLinesWrapped.forEach(linePart => {
                                          if (yPos > 280) { doc.addPage(); yPos = 20; }
                                          doc.text(linePart, margin + 5, yPos);
                                          yPos += 4;
                                     });
                                     

                                     // If there are violations (v > 0), print details indented
                                     if (v > 0) {
                                         // Get violations from the *first* setting (they should be the same for the same group # within the same violation count)
                                         const violations = groupEntry.settings[0].violations;
                                         if (violations && violations.length > 0) {
                                             doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.SMALL);
                                             violations.slice(0, 4).forEach(viol => { // Limit displayed violations per group
                                                 if (yPos > 280) { doc.addPage(); yPos = 20; }
                                                 // Indent violation details
                                                 const violationLines = doc.splitTextToSize(viol, pdfWidth - margin - margin - 10); // More indent
                                                 violationLines.forEach(violLine => {
                                                     if (yPos > 280) { doc.addPage(); yPos = 20; }
                                                     doc.text(violLine, margin + 10, yPos);
                                                     yPos += 3.5;
                                                 });
                                             });
                                             yPos += 1; // Extra space after violations for one group
                                         }
                                     }
                                 });
                                 yPos += 3; // Extra space between violation categories
                             }
                         }
                     }
                     
                     yPos += 3; // Spacing after space groups if section exists

                     // --- 8. CENTERING TEST VIOLATIONS (Non-bold) ---
                     if (sol.analysis.centeringViolations && Object.keys(sol.analysis.centeringViolations).length > 0) {
                         if (yPos > 268) { doc.addPage(); yPos = 20; }
                         doc.setFont(FONT.LABEL, 'normal').setFontSize(SIZE.H2).text('Centering test violations:', margin, yPos); // Changed to H2, normal
                         yPos += 5;
                         const violText = Object.entries(sol.analysis.centeringViolations).sort(([,a], [,b]) => a - b).map(([key, val]) => `${key}:${val}`).join(', ');
                         doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY).text(violText, margin, yPos);
                         yPos += 5;
                         if (sol.analysis.centeringViolations && sol.analysis.centeringViolationDetails) {
                         doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.SMALL); // Smaller, italic font for details
                         let detailsYOffset = 0; // Track y position adjustments

                         for (const type of ['I', 'F', 'A', 'B', 'C']) {
                             const count = sol.analysis.centeringViolations[type];
                             const details = sol.analysis.centeringViolationDetails[type];

                             if ((count === 1 || count === 2) && details && details.length > 0) {
                                 let detailText = `${type} violation${count > 1 ? 's' : ''}: `;
                                 detailText += details.map(d =>
                                     `(${d.h},${d.k},${d.l}) at ${d.tth.toFixed(3)}°`
                                 ).join('; ');

                                 // Check for page break BEFORE printing the detail line
                                 if (yPos + detailsYOffset > 285) { // Use a slightly smaller threshold
                                     doc.addPage();
                                     yPos = 20;
                                     detailsYOffset = 0; // Reset offset for the new page
                                 }
                                 doc.text(detailText, margin + 5, yPos + detailsYOffset); // Indent slightly
                                 detailsYOffset += 3.5; // Move down for the next potential detail line
                             }
                         }
                         yPos += detailsYOffset; // Apply the total offset used for details
                         doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.BODY); // Reset font
                     }
                         
                         
                         
                         yPos += 5;
                     }
                } 
                yPos += 4; 
                if (yPos > 255) { doc.addPage(); yPos = 20; }
    


            /* --- REFLECTION TABLE ... */
    
                doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER);
                const tableHeader = ' h k l   | 2th_meas 2th_corr 2th_calc | d_corr     d_calc    | diff(2th)';
                doc.text(tableHeader, margin, yPos); yPos += 4;
                
                const hklList = generateHKL_for_analysis(sol, lambda, tthMaxVal);
                
                if (hklList.length === 0) {
                     doc.setFont(FONT.DATA, 'italic').setFontSize(SIZE.BODY).text('Could not generate theoretical reflections for this cell.', margin, yPos);
                     yPos += 5;
                     return; 
                }
    
                const ambiguousHkls = sol.analysis.ambiguousHkls || new Set();
                const corrected_tth_obs = reportPeaks.map(p => ({ ...p, tth_corr: p.tth - (sol.zero_correction || 0) }));
                const reportLines = []; 
                const assignedHkls = new Set();
    
                corrected_tth_obs.forEach((corr_peak) => {
                    let bestMatchHkl = null; let minDiff = Infinity;
                    hklList.forEach(hkl => { const diff = Math.abs(hkl.tth - corr_peak.tth_corr); if (diff < minDiff) { minDiff = diff; bestMatchHkl = hkl; } });
                    
                    if (bestMatchHkl && minDiff < tthError * 2 && corr_peak.tth_corr >= tthMinVal && corr_peak.tth_corr <= tthMaxVal) {
                        reportLines.push({ h: bestMatchHkl.h, k: bestMatchHkl.k, l: bestMatchHkl.l, tth_meas: corr_peak.tth, tth_corr: corr_peak.tth_corr, tth_calc: bestMatchHkl.tth, d_calc: bestMatchHkl.d });
                        assignedHkls.add(`${bestMatchHkl.h},${bestMatchHkl.k},${bestMatchHkl.l}`);
                    }
                });
    
                hklList.forEach(hkl => {
                    if (!assignedHkls.has(`${hkl.h},${hkl.k},${hkl.l}`) && hkl.tth >= tthMinVal && hkl.tth <= tthMaxVal) {
                        reportLines.push({ h: hkl.h, k: hkl.k, l: hkl.l, tth_meas: null, tth_corr: null, tth_calc: hkl.tth, d_calc: hkl.d });
                    }
                });
                
                reportLines.sort((a, b) => a.tth_calc - b.tth_calc);
                
                doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY);
                reportLines.forEach(line => {
                    if (yPos > 285) { doc.addPage(); yPos = 20; doc.setFont(FONT.LABEL, 'bold').setFontSize(SIZE.TABLE_HEADER); doc.text(tableHeader, margin, yPos); yPos += 4; doc.setFont(FONT.DATA, 'normal').setFontSize(SIZE.TABLE_BODY); }
                    
                    const hkl_key = `${line.h},${line.k},${line.l}`;
                    if (ambiguousHkls.has(hkl_key)) {
                        doc.setFont(FONT.DATA, 'italic');
                    }
    
                    const d_corr = line.tth_corr ? lambda / (2 * Math.sin(line.tth_corr * Math.PI / 360)) : null;
                    const tth_m = line.tth_meas ? line.tth_meas.toFixed(3) : '   -   '; 
                    const tth_c = line.tth_corr ? line.tth_corr.toFixed(3) : '   -   '; 
                    const d_c_str = d_corr ? d_corr.toFixed(5) : '    -    '; 
                    const diff_2t = line.tth_corr ? (line.tth_corr - line.tth_calc).toFixed(3) : '   -   ';
                    
                    const hkl_str = `${String(line.h).padStart(2)} ${String(line.k).padStart(2)} ${String(line.l).padStart(2)}`.padEnd(8);
                    const pdfLine = `${hkl_str}| ${tth_m.padStart(7)} ${tth_c.padStart(7)} ${line.tth_calc.toFixed(3).padStart(7)} | ${d_c_str.padStart(9)} ${line.d_calc.toFixed(5).padStart(9)} | ${diff_2t.padStart(8)}`;
                    doc.text(pdfLine, margin, yPos);
                    
                    doc.setFont(FONT.DATA, 'normal'); // Reset font to normal for the next line
                    yPos += 3.5;
                });
            });
    
            const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
            doc.save(filename);
            showStatus('PDF report generated and saved.', 'success');
    
        } catch (error) {
            console.error("Failed to generate PDF:", error);
            showStatus("An error occurred during PDF generation.", 'error');
        } finally {
            ui.reportButton.textContent = 'Generate PDF Report';
            ui.reportButton.disabled = (solutions.length === 0);
            document.body.style.cursor = 'default';
        }
    };  





    window.addEventListener('beforeunload', () => { if (workerURL) URL.revokeObjectURL(workerURL); });
});

    </script>
    


<script id="indexing-worker" type="text/javascript">

self.onmessage = function(e) {
    // --- INITIAL SETUP ---
const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks, refineZero, allowedSystems } = e.data;

// --- DEBUG 
//    console.log(`[Worker] Received ${peaks.length} peaks. Wavelength: ${wavelength}`);
//    console.log("[Worker] Calculating q_obs (1/d^2) for all peaks:");
    const q_values_full = peaks.map(p => {
        const q = (4 * Math.sin(p.tth * Math.PI / 360)**2) / (wavelength**2);
//        console.log(`  2θ: ${p.tth.toFixed(4)} -> q: ${q.toFixed(6)}`);
        return q;
    });
    // --- END DEBUG LOGGING ---

const N_FOR_M20 = Math.min(20, peaks.length);
    const min_m20 = 2.0;
    const d_min = wavelength / (2 * Math.sin(Math.max(...peaks.map(p => p.tth)) * Math.PI / 360));
    const q_max = 1 / (d_min * d_min);
    
    const peaks_sorted_by_q = peaks.map((p, i) => ({...p, original_index: i})).sort((a,b) => a.q - b.q);
    const q_obs = new Float64Array(peaks_sorted_by_q.map(p => p.q));
    const original_indices = peaks_sorted_by_q.map(p => p.original_index);
    const tth_obs_rad = new Float64Array(peaks.map(p => p.tth * Math.PI / 180));
    
    const foundSolutions = [];
    const foundSolutionMap = new Map();

    // --- UTILITY & CRYSTALLOGRAPHY HELPER 
    const metricFromCell = (cell) => {
        const deg2rad = Math.PI / 180;
        const a = cell.a; const b = cell.b ?? cell.a; const c = cell.c ?? cell.a;
        const alpha = (cell.alpha ?? 90) * deg2rad; const beta  = (cell.beta  ?? 90) * deg2rad; const gamma = (cell.gamma ?? 90) * deg2rad;
        const ca = Math.cos(alpha), cb = Math.cos(beta), cg = Math.cos(gamma);
        return [ [a*a, a*b*cg, a*c*cb], [a*b*cg, b*b, b*c*ca], [a*c*cb, b*c*ca, c*c] ];
    };
    const cellFromMetric = (G) => {
        const a = Math.sqrt(G[0][0]), b = Math.sqrt(G[1][1]), c = Math.sqrt(G[2][2]);
        const clamp = v => Math.max(-1, Math.min(1, v));
        const alpha = Math.acos(clamp(G[1][2]/(b*c)))*180/Math.PI, beta=Math.acos(clamp(G[0][2]/(a*c)))*180/Math.PI, gamma=Math.acos(clamp(G[0][1]/(a*b)))*180/Math.PI;
        return { a, b, c, alpha, beta, gamma };
    };
    const transpose = (M) => M[0].map((_,i) => M.map(r => r[i]));
    const matMul = (A,B) => {
        const r=A.length, c=B[0].length, k=A[0].length;
        const C = Array.from({length:r}, () => Array(c).fill(0));
        for(let i=0; i<r; i++) for(let j=0; j<c; j++) for(let t=0; t<k; t++) C[i][j] += A[i][t] * B[t][j];
        return C;
    };
    const getSymmetry = (a, b, c, alpha, beta, gamma, tol = 0.02) => {
        const eq = (v1, v2) => Math.abs(v1 - v2) < tol;
        const is90 = (v) => Math.abs(v - 90) < tol; const is120 = (v) => Math.abs(v - 120) < tol;
        const angles90 = is90(alpha) && is90(beta) && is90(gamma);
        if (angles90) {
            if (eq(a, b) && eq(b, c)) return 'cubic';
            if (eq(a, b) || eq(b, c) || eq(a, c)) return 'tetragonal';
            return 'orthorhombic';
        }
        if (is90(alpha) && is90(gamma) && is120(beta)) return 'hexagonal'; // Check for permuted hexagonal
        if (is90(beta) && is90(gamma) && is120(alpha)) return 'hexagonal'; // Check for permuted hexagonal
        if (is90(alpha) && is90(beta) && is120(gamma)) return 'hexagonal';
        if (is90(alpha) && is90(gamma) && !is90(beta)) return 'monoclinic';
        if (is90(beta) && is90(gamma) && !is90(alpha)) return 'monoclinic'; // b,c unique
        if (is90(alpha) && is90(beta) && !is90(gamma)) return 'monoclinic'; // a,b unique
        return 'triclinic';
    };
    const standardizeCell = (cell) => {
        const newCell = { ...cell };
        switch (cell.system) {
            case 'tetragonal': {
                const axes = [cell.a, cell.b, cell.c];
                const tol = 0.02;
                let uniqueAxis, repeatedAxis;
    
                if (Math.abs(axes[0] - axes[1]) < tol) { // a == b
                    uniqueAxis = axes[2];
                    repeatedAxis = axes[0];
                } else if (Math.abs(axes[0] - axes[2]) < tol) { // a == c
                    uniqueAxis = axes[1];
                    repeatedAxis = axes[0];
                } else { // b and c must be equal
                    uniqueAxis = axes[0];
                    repeatedAxis = axes[1];
                }
                newCell.a = repeatedAxis;
                newCell.b = repeatedAxis;
                newCell.c = uniqueAxis;
                break;
            }
            case 'orthorhombic': { const sorted = [cell.a, cell.b, cell.c].sort((x,y)=>x-y); newCell.a=sorted[0]; newCell.b=sorted[1]; newCell.c=sorted[2]; break; }
            case 'cubic': { newCell.b = newCell.a; newCell.c = newCell.a; break; }
        }
        return newCell;
    };
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const gcdOfList = (arr) => arr.length > 0 ? arr.reduce((acc, val) => gcd(acc, val), arr[0]) : 1;
    
    
    const binarySearchClosestTth = (sortedArr, targetTth) => {
        let low = 0, high = sortedArr.length - 1;
        if (high < 0) return -1;
        
        while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (sortedArr[mid].tth === targetTth) return mid;
            if (sortedArr[mid].tth < targetTth) low = mid + 1;
            else high = mid - 1;
        }
        
        // At this point, low > high. The closest is either low or high.
        if (low >= sortedArr.length) return high;
        if (high < 0) return low;
        
        if (Math.abs(sortedArr[low].tth - targetTth) < Math.abs(sortedArr[high].tth - targetTth)) {
            return low;
        } else {
            return high;
        }
    };
    


// Enforces crystallographic conventions to avoid listing
// redundant equivalent reflections (e.g., (100) vs (010) in cubic).
// ==================================================================
const generateHKL_for_indexing = (maxTth, params, system) => {
     const { a, b, c, beta, lambda } = params; if (!a || !lambda) return []; const reflections = [];
     const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360)); const q_max_limit = (1 / (d_min * d_min)) * 1.05;
     const h_max = Math.ceil(a / d_min); 
     const k_max = b ? Math.ceil(b / d_min) : h_max; 
     const l_max = c ? Math.ceil(c / d_min) : h_max;
     
     if (system === 'monoclinic') {
        const sinBeta = Math.sin(beta*Math.PI/180); 
        const cosBeta = Math.cos(beta*Math.PI/180);
        const sinBetaSq = sinBeta * sinBeta;
        if (sinBetaSq < 1e-6) return []; // Invalid cell

        for (let h = -h_max; h <= h_max; h++) {
            for (let k = 0; k <= k_max; k++) { // k >= 0 is sufficient
                for (let l = -l_max; l <= l_max; l++) {
                    if (h === 0 && k === 0 && l === 0) continue;
                    
                    // Add uniqueness filter for monoclinic (k=0, h>0 or h=0,l>0)
                    if (k === 0) {
                        if (h < 0) continue;
                        if (h === 0 && l <= 0) continue;
                    }

                    const inv_d_sq = (1/sinBetaSq)*(h*h/(a*a)+l*l/(c*c)-2*h*l*cosBeta/(a*c))+k*k/(b*b); 
                    
                    if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue; 
                    const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                    if (sinThetaSq <= 1) { 
                        const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); 
                        reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)}); 
                    }
                }
            }
        }
     } else {
         // Original logic for all other systems
         for (let h = 0; h <= h_max; h++) { 
            for (let k = 0; k <= k_max; k++) {
                if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                for (let l = 0; l <= l_max; l++) { 
                    if (system === 'cubic' && l > k) continue;
                    if (h === 0 && k === 0 && l === 0) continue;

                    let inv_d_sq = 0;
                     switch (system) {
                         case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                         case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                         case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                         // monoclinic case removed from here
                     }
                     if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue; 
                     const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                     if (sinThetaSq <= 1) { 
                        const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); 
                        reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)}); 
                    }
                }
            }
        }
     }

     return reflections.sort((a, b) => a.tth - b.tth);
 };


    const findIndexedPeaksForSolution = (solution, tthError) => {
        const maxTth = Math.max(...peaks.map(p => p.tth));
        
        // 1. Generate and sort theoretical HKLs *once*. This is O(M log M).
        const theoreticalHKLs = generateHKL_for_indexing(maxTth, { ...solution, lambda: wavelength }, solution.system);
        if (!theoreticalHKLs || theoreticalHKLs.length === 0) return [];
        
        // theoreticalHKLs is already sorted by tth from the generation function.

        const indexedPeaks = []; 
        const usedTheoreticalPeaks = new Set();
        
        // 2. For each observed peak, find the closest theoretical peak. This is O(N log M).
        for (const obsPeak of peaks) {
            const closestIndex = binarySearchClosestTth(theoreticalHKLs, obsPeak.tth);
            if (closestIndex === -1) continue;

            // Check neighbors in case binary search landed between two close peaks
            let bestMatch = null;
            let minDiff = Infinity;

            for (let i = Math.max(0, closestIndex - 2); i <= Math.min(theoreticalHKLs.length - 1, closestIndex + 2); i++) {
                 const diff = Math.abs(obsPeak.tth - theoreticalHKLs[i].tth);
                 if (diff < minDiff) {
                     minDiff = diff;
                     bestMatch = { ...theoreticalHKLs[i], originalIndex: i };
                 }
            }

            if (bestMatch && minDiff < tthError && !usedTheoreticalPeaks.has(bestMatch.originalIndex)) {
                indexedPeaks.push({ h: bestMatch.h, k: bestMatch.k, l: bestMatch.l }); 
                usedTheoreticalPeaks.add(bestMatch.originalIndex); 
            }
        }
        return indexedPeaks;
    };
    

    // --- CORE REFINEMENT AND ANALYSIS FUNCTIONS ---

    const generateHKL_for_worker = (cell) => {
        const { system } = cell;
        const reflections = [];
        const MAX_REFLECTIONS_LIMIT = 50000;
        const q_max_limit = q_max * 1.05; // Use the global q_max from the worker's scope
        
        // --- OPTIMIZED MONOCLINIC PATH ---
        if (system === 'monoclinic') {
            const { a, b, c, beta } = cell;
            if (!a || !b || !c || !beta) return []; // Safety check
            
            const h_max = Math.ceil(a / d_min) + 1;
            const k_max = Math.ceil(b / d_min) + 1;
            const l_max = Math.ceil(c / d_min) + 1;

            const sinBeta = Math.sin(beta * Math.PI / 180);
            const cosBeta = Math.cos(beta * Math.PI / 180);
            const sinBetaSq = sinBeta * sinBeta;
            
            if (sinBetaSq < 1e-6) return []; // Invalid cell

            const a_star_sq = 1 / (a * a * sinBetaSq);
            const b_star_sq = 1 / (b * b);
            const c_star_sq = 1 / (c * c * sinBetaSq);
            const ac_star_term = 2 * cosBeta / (a * c * sinBetaSq); 

            for (let h = -h_max; h <= h_max; h++) {
                const h_term = h * h * a_star_sq;
                const h_l_coeff = h * ac_star_term;
                
                // --- Optimization 1: Check min q for this 'h' (at k=0) ---
                const l_vertex_h_only = (c_star_sq !== 0) ? h_l_coeff / (2 * c_star_sq) : 0;
                const q_min_for_h = (c_star_sq * l_vertex_h_only * l_vertex_h_only) - (h_l_coeff * l_vertex_h_only) + h_term;
                
                if (q_min_for_h > q_max_limit) {
                    continue; // Skip this 'h' entirely
                }

                for (let k = 0; k <= k_max; k++) {
                    if (reflections.length > MAX_REFLECTIONS_LIMIT) {
                         console.warn(`[Worker] HKL generation limit (${MAX_REFLECTIONS_LIMIT}) reached for cell. Results may be incomplete.`);
                         h = h_max + 1; k = k_max + 1; // Break outer loops
                         continue;
                    }

                    const k_term = k * k * b_star_sq;
                    const hk_term = h_term + k_term;
                    
                    // --- Optimization 2: Check min q for this (h, k) ---
                    const l_vertex = l_vertex_h_only;
                    const q_min_for_hk = (c_star_sq * l_vertex * l_vertex) - (h_l_coeff * l_vertex) + hk_term;

                    if (q_min_for_hk > q_max_limit) {
                        if (k === 0) break; // Break k-loop, k>0 will also fail
                        else continue; // Continue k-loop
                    }

                    for (let l = -l_max; l <= l_max; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        // Enforce uniqueness
                        if (k === 0) {
                            if (h < 0) continue;
                            if (h === 0 && l <= 0) continue;
                        }

                        const q_calc = (c_star_sq * l * l) - (h_l_coeff * l) + hk_term;

                        if (q_calc > 0 && q_calc <= q_max_limit) {
                            reflections.push({ q: q_calc, h, k, l });
                        }
                    }
                }
            }
        
        } else {
            // --- ORIGINAL PATH FOR OTHER SYSTEMS ---
            const { a } = cell;
            const b = cell.b ?? cell.a;
            const c = cell.c ?? cell.a;
            if (!a || !b || !c) return []; // Safety check

            const h_max = Math.ceil(a / d_min) + 1;
            const k_max = Math.ceil(b / d_min) + 1;
            const l_max = Math.ceil(c / d_min) + 1;

            for (let h = -h_max; h <= h_max; h++) {
                // Simple optimization for non-monoclinic
                let h_term = 0;
                switch(system) {
                    case 'cubic': h_term = (h*h) / (a*a); break;
                    case 'tetragonal': h_term = (h*h) / (a*a); break;
                    case 'hexagonal': h_term = (4/3) * (h*h) / (a*a); break;
                    case 'orthorhombic': h_term = (h*h) / (a*a); break;
                }
                if (h_term > q_max_limit) continue;

                for (let k = 0; k <= k_max; k++) {
                    // Simple optimization
                    let hk_term = 0;
                    switch(system) {
                        case 'cubic': hk_term = (h*h + k*k) / (a*a); break;
                        case 'tetragonal': hk_term = (h*h + k*k) / (a*a); break;
                        case 'hexagonal': hk_term = (4/3) * (h*h + h*k + k*k) / (a*a); break;
                        case 'orthorhombic': hk_term = (h*h) / (a*a) + (k*k) / (b*b); break;
                    }
                    if (hk_term > q_max_limit) {
                        if (k === 0) break; else continue;
                    }
                    
                    if (reflections.length > MAX_REFLECTIONS_LIMIT) {
                         console.warn(`[Worker] HKL generation limit (${MAX_REFLECTIONS_LIMIT}) reached for cell. Results may be incomplete.`);
                         h = h_max + 1; k = k_max + 1; // Break outer loops
                         continue;
                    }

                    for (let l = -l_max; l <= l_max; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;

                        let q_calc = 0;
                        switch (system) {
                            case 'cubic':
                                q_calc = (h * h + k * k + l * l) / (a * a);
                                break;
                            case 'tetragonal':
                                q_calc = (h * h + k * k) / (a * a) + (l * l) / (c * c);
                                break;
                            case 'hexagonal':
                                q_calc = (4 / 3) * (h * h + h * k + k * k) / (a * a) + (l * l) / (c * c);
                                break;
                            case 'orthorhombic':
                                q_calc = (h * h) / (a * a) + (k * k) / (b * b) + (l * l) / (c * c);
                                break;
                        }
                        if (q_calc > 0 && q_calc <= q_max_limit) {
                            reflections.push({ q: q_calc, h, k, l });
                        }
                    }
                }
            }
        } // --- End of if/else(monoclinic) ---
        
        // Sort by q-value for efficient searching
        return reflections.sort((a, b) => a.q - b.q);
    };

    const getQcalc = (hkl, cell) => {
        const [h, k, l] = hkl;
        const { a, b, c, beta, system } = cell;
        switch (system) {
            case 'cubic': return (h*h + k*k + l*l) / (a*a);
            case 'tetragonal': return (h*h + k*k) / (a*a) + (l*l) / (c*c);
            case 'hexagonal': return (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c);
            case 'orthorhombic': return h*h/(a*a) + k*k/(b*b) + l*l/(c*c);
            case 'monoclinic':
                const sinBeta = Math.sin(beta * Math.PI / 180), cosBeta = Math.cos(beta * Math.PI / 180);
               
                if (Math.abs(sinBeta) < 1e-9) return 0;
               
                return (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
        }
        return 0;
    };
    
    const getLSDesignRow = (hkl, system) => {
        const [h, k, l] = hkl;
        switch(system) {
            case 'cubic': return [h*h + k*k + l*l];
            case 'tetragonal': return [h*h + k*k, l*l];
            case 'hexagonal': return [(4/3)*(h*h + h*k + k*k), l*l];
            case 'orthorhombic': return [h*h, k*k, l*l];
            case 'monoclinic': return [h*h, k*k, l*l, h*l];
        }
    };
    
    const extractCellFromFit = (params, system) => {
        let cell = { system, alpha: 90, gamma: 90 };
        try {
            if (params.some(p => isNaN(p))) return null;

            switch(system) {
    case 'cubic':
        if (params[0] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = cell.a;
        cell.beta = 90;
        break;

    case 'tetragonal':
        if (params[0] <= 0 || params[1] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = 1/Math.sqrt(params[1]);
        cell.beta = 90;
        break;

    case 'hexagonal':
        if (params[0] <= 0 || params[1] <= 0) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = cell.a;
        cell.c = 1/Math.sqrt(params[1]);
        cell.beta = 90;
        cell.gamma = 120;
        break;

    case 'orthorhombic':
        if (params.slice(0, 3).some(p => p <= 0)) return null;
        cell.a = 1/Math.sqrt(params[0]);
        cell.b = 1/Math.sqrt(params[1]);
        cell.c = 1/Math.sqrt(params[2]);
        cell.beta = 90;
        break;

    case 'monoclinic':
        const cell_params = params.slice(0, 4);
        let [A, B, C, D] = cell_params;
        
        // D*D >= 4*A*C is check for |cos(beta)| >= 1
        if (A <= 0 || B <= 0 || C <= 0 || D*D >= 4*A*C) return null;
        
        const cosBeta_calc = -D / (2 * Math.sqrt(A*C));
        if (Math.abs(cosBeta_calc) >= 1) return null;
        
        let beta_calc = Math.acos(cosBeta_calc) * 180 / Math.PI;

        // Enforce convention: beta >= 90
        // If beta is acute (< 90), flip it to the obtuse angle
        if (beta_calc < 90.0) {
            beta_calc = 180.0 - beta_calc;
        }

        // Now check the conventional beta (relaxed range)
        if (beta_calc < 90.0 || beta_calc > 150.0) return null;

        cell.beta = beta_calc;
        const sinBetaSq = Math.sin(cell.beta * Math.PI / 180)**2;
        
        if (sinBetaSq <= 1e-6) return null; // Avoid division by zero
        
        cell.a = 1/Math.sqrt(A * sinBetaSq);
        cell.b = 1/Math.sqrt(B);
        cell.c = 1/Math.sqrt(C * sinBetaSq);
        break;
}

        } catch { return null; }
        
        if (isNaN(cell.a) || isNaN(cell.b) || isNaN(cell.c) || isNaN(cell.beta)) return null;

        return cell;
    };
    
    const getVolume = (cell) => {
        const { a, b, c, beta, system } = cell;
        switch(system){
            case 'cubic': return a**3;
            case 'tetragonal': return a**2 * c;
            case 'hexagonal': return a**2 * c * Math.sqrt(3)/2;
            case 'orthorhombic': return a * b * c;
            case 'monoclinic': return a * b * c * Math.sin(beta * Math.PI / 180);
        }
    };
    
    const getSolutionKey = (cell) => {
        const P = 2;
        const std = standardizeCell(cell);
        switch(std.system) {
            case 'cubic': return `${std.system}_${std.a.toFixed(P)}`;
            case 'tetragonal': case 'hexagonal': return `${std.system}_${std.a.toFixed(P)}_${std.c.toFixed(P)}`;
            case 'orthorhombic': return `${std.system}_${[std.a,std.b,std.c].sort().map(p => p.toFixed(P)).join('_')}`;
            case 'monoclinic': return `${std.system}_${std.volume.toFixed(2)}_${std.beta.toFixed(2)}`;
        }
    };
        
    // Helper: Performs LU decomposition with partial pivoting
    const luDecomposition = (matrix) => {
        const n = matrix.length;
        const lu = matrix.map(row => row.slice());
        const P = Array(n).fill(0).map((_, i) => i); // Permutation vector
        for (let k = 0; k < n; k++) {
            // Find pivot
            let maxVal = 0;
            let k_prime = k;
            for (let i = k; i < n; i++) {
                if (Math.abs(lu[i][k]) > maxVal) {
                    maxVal = Math.abs(lu[i][k]);
                    k_prime = i;
                }
            }
            if (maxVal < 1e-12) return null; // Singular

            // Swap rows
            [P[k], P[k_prime]] = [P[k_prime], P[k]];
            [lu[k], lu[k_prime]] = [lu[k_prime], lu[k]];

            // Calculate multipliers and update
            for (let i = k + 1; i < n; i++) {
                lu[i][k] /= lu[k][k];
                for (let j = k + 1; j < n; j++) {
                    lu[i][j] -= lu[i][k] * lu[k][j];
                }
            }
        }
        return { lu, P };
    };

    // Helper: Solves Ax = b given LU decomposition
    const luSolve = (luDecomp, b) => {
        const { lu, P } = luDecomp;
        const n = lu.length;
        const x = new Array(n);
        const y = new Array(n);

        // Apply permutation to b -> get Pb
        const Pb = P.map(pi => b[pi]);

        // Solve Ly = Pb (forward substitution)
        for (let i = 0; i < n; i++) {
            let sum = 0;
            for (let j = 0; j < i; j++) {
                sum += lu[i][j] * y[j];
            }
            y[i] = Pb[i] - sum;
        }

        // Solve Ux = y (backward substitution)
        for (let i = n - 1; i >= 0; i--) {
            let sum = 0;
            for (let j = i + 1; j < n; j++) {
                sum += lu[i][j] * x[j];
            }
            x[i] = (y[i] - sum) / lu[i][i];
            if (isNaN(x[i])) return null; // Protect against div by zero if pivot was tiny
        }
        return x;
    };

    // Helper: Inverts a matrix given LU decomposition
    const luInvert = (luDecomp) => {
        const n = luDecomp.lu.length;
        const identity = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((__, j) => (i === j ? 1 : 0)));
        const inverse = Array(n).fill(0).map(() => Array(n).fill(0));

        for (let j = 0; j < n; j++) {
            // We need to solve for each column of the identity matrix
            const b = Array(n).fill(0);
            b[j] = 1;
            
            const invCol = luSolve(luDecomp, b);
            if (!invCol) return null; // Failed to solve

            for (let i = 0; i < n; i++) {
                inverse[i][j] = invCol[i];
            }
        }
        return inverse;
    };
 




    const get_q_tolerance = (original_peak_index) => {
        const theta_rad = tth_obs_rad[original_peak_index] / 2.0;
        const d_theta_rad = tth_error * Math.PI / 360;
        return ((8 * Math.sin(theta_rad) * Math.cos(theta_rad)) / (wavelength**2)) * d_theta_rad;
    };

    const binarySearchClosest = (arr, target) => {
        let low = 0, high = arr.length - 1;
        if (arr.length === 0 || target <= arr[low]) return 0;
        if (target >= arr[high]) return high;
        while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (arr[mid] < target) low = mid + 1; else high = mid - 1;
        }
        return (low >= arr.length) ? high : ((arr[low] - target) < (target - arr[high]) ? low : high);
    };
    
    const calculateFiguresOfMerit = (q_calc_sorted, peaks_for_merit) => {
        // peaks_for_merit is an array of peak objects: {tth, q, original_index}
        if (!q_calc_sorted || q_calc_sorted.length === 0) return { m20: 0, fN: 0 };
        
        const N = peaks_for_merit.length;
        if (N === 0) return { m20: 0, fN: 0 };

        let N_indexed = 0, sum_delta_q = 0, sum_delta_tth = 0;

        // Get Q and 2-theta of the Nth observed peak
        const q_n = peaks_for_merit[N - 1].q;
        const tth_n_deg = peaks_for_merit[N - 1].tth;

        for (let i = 0; i < N; i++) {
            const obs_peak = peaks_for_merit[i];
            const q_o = obs_peak.q;
            const tth_o_deg = obs_peak.tth;
            const tolerance_q = get_q_tolerance(obs_peak.original_index);

            // Find closest calculated Q-value
            const closest_q_calc_idx = binarySearchClosest(q_calc_sorted, q_o);
            const q_c = q_calc_sorted[closest_q_calc_idx];
            const diff_q = Math.abs(q_o - q_c);

            // Check if it's indexed
            if (diff_q < tolerance_q) {
                N_indexed++;
                sum_delta_q += diff_q;
                
                // Convert q_c back to 2-theta to get the 2-theta difference
                const sinThetaSq_c = (q_c * wavelength**2) / 4;
                if (sinThetaSq_c >= 0 && sinThetaSq_c <= 1) {
                    const tth_c_rad = 2 * Math.asin(Math.sqrt(sinThetaSq_c));
                    const tth_c_deg = tth_c_rad * 180 / Math.PI;
                    sum_delta_tth += Math.abs(tth_o_deg - tth_c_deg);
                }
            }
        }
        
        // --- Fail fast ---
        if (N - N_indexed > impurity_peaks || N_indexed === 0) return { m20: 0, fN: 0 };

        // --- M(N) Calculation ---
        const avg_delta_q = sum_delta_q / N_indexed;
        // N_calc for M(N) is number of calculated lines up to the Nth *observed Q*
        const N_calc_M = q_calc_sorted.filter(q => q <= q_n * 1.05).length;
        const mN = (N_calc_M > 0 && avg_delta_q > 1e-12) ? (q_n / (2 * avg_delta_q * N_calc_M)) : 0;

        // --- F(N) Calculation ---
        const avg_delta_tth = sum_delta_tth / N_indexed;
        // N_calc for F(N) is number of calculated lines up to the Nth *observed 2-theta*
        const q_limit_fN = (4 * Math.sin(tth_n_deg * Math.PI / 360)**2) / (wavelength**2);
        const N_calc_FN = q_calc_sorted.filter(q => q <= q_limit_fN * 1.0001).length; // Use tiny margin
        const fN = (N_calc_FN > 0 && avg_delta_tth > 1e-12) ? ((1 / avg_delta_tth) * (N_indexed / N_calc_FN)) : 0;

        return { m20: mN, fN: fN }; // Return M(N) and F(N)
    };


    const solveLeastSquares = (M, q_vec, weights) => {
        const num_eq = M.length, num_params = M[0].length;
        if (num_eq < num_params) return null;

        const w = weights || Array(num_eq).fill(1);
        
        // M_transpose * Weighted_M (MᵀWM)
        const MTWM = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
        for (let i = 0; i < num_params; i++) {
            for (let j = 0; j < num_params; j++) {
                let sum = 0;
                for (let k = 0; k < num_eq; k++) {
                    sum += M[k][i] * w[k] * M[k][j];
                }
                MTWM[i][j] = sum;
            }
        }
        
        // M_transpose * Weighted_q_vec (MᵀWq)
        const MTWq = Array(num_params).fill(0);
        for (let i = 0; i < num_params; i++) {
            let sum = 0;
            for (let k = 0; k < num_eq; k++) {
                sum += M[k][i] * w[k] * q_vec[k];
            }
            MTWq[i] = sum;
        }
        
        // Solve (MᵀWM)x = (MᵀWq) using LU decomposition
        const luDecomp = luDecomposition(MTWM);
        if (!luDecomp) return null; // Singular matrix

        const x = luSolve(luDecomp, MTWq);
        if (!x) return null; // Solver failed
        
        const df = num_eq - num_params;
        if (df <= 0) return { solution: x, covarianceMatrix: null };

        // Calculate covariance matrix V = (MᵀWM)⁻¹ * (SSR / df)
        const q_calc = M.map(row => row.reduce((s, v, j) => s + v * x[j], 0));
        const SSR = q_vec.reduce((sum, q_obs, i) => sum + w[i] * (q_obs - q_calc[i])**2, 0);
        
        const MTWM_inv = luInvert(luDecomp);
        if (!MTWM_inv) return { solution: x, covarianceMatrix: null }; // Inversion failed

        const V = MTWM_inv.map(row => row.map(el => el * (SSR / df)));

        return { solution: x, covarianceMatrix: V };
    };
    // --- END REPLACE ---


    const propagateErrors = (system, fitResult, cell) => {
        if (!fitResult || !fitResult.covarianceMatrix) return {};
        const V = fitResult.covarianceMatrix, errors = {}, num_params = V.length;
        try {
            switch (system) {
                case 'cubic': errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0])); break;
                case 'tetragonal': case 'hexagonal':
                    errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_c = 0.5 * cell.c**3 * Math.sqrt(Math.abs(V[1][1]));
                    break;
                case 'orthorhombic':
                    errors.s_a = 0.5 * cell.a**3 * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_b = 0.5 * cell.b**3 * Math.sqrt(Math.abs(V[1][1]));
                    errors.s_c = 0.5 * cell.c**3 * Math.sqrt(Math.abs(V[2][2]));
                    break;
                case 'monoclinic':
                    const [A,B,C,D] = fitResult.solution;
                    errors.s_b = 0.5 * cell.b**3 * Math.sqrt(Math.abs(V[1][1]));
                    const betaRad = cell.beta*Math.PI/180, sinBeta=Math.sin(betaRad), sqrtAC=Math.sqrt(A*C);
                    const d_beta_d_A = (-1/sinBeta)*(D/(4*A*sqrtAC)), d_beta_d_C = (-1/sinBeta)*(D/(4*C*sqrtAC)), d_beta_d_D = (-1/sinBeta)*(-1/(2*sqrtAC));
                    errors.s_beta = Math.sqrt(Math.abs(d_beta_d_A**2*V[0][0] + d_beta_d_C**2*V[2][2] + d_beta_d_D**2*V[3][3] + 2*(d_beta_d_A*d_beta_d_C*V[0][2] + d_beta_d_A*d_beta_d_D*V[0][3] + d_beta_d_C*d_beta_d_D*V[2][3]))) * 180 / Math.PI;
                    errors.s_a = (cell.a / (2*A)) * Math.sqrt(Math.abs(V[0][0]));
                    errors.s_c = (cell.c / (2*C)) * Math.sqrt(Math.abs(V[2][2]));
                    break;
            }
            const cell_param_count = { cubic: 1, tetragonal: 2, hexagonal: 2, orthorhombic: 3, monoclinic: 4 };
            if (num_params > cell_param_count[system]) {
                errors.s_zero = Math.sqrt(Math.abs(V[num_params - 1][num_params - 1])) * 180 / Math.PI;
            }
        } catch (e) { console.error("Error during propagation:", e); }
        return errors;
    };

    const hkl_search_list_cache = {};
    const get_hkl_search_list = (system) => {
        if (hkl_search_list_cache[system]) return hkl_search_list_cache[system];
        
        const hkls = [];
        const max_h = 6; // Max index for non-mono systems
        const max_mono = 4; // Max index for mono system

        if (system === 'monoclinic') {
            // --- Monoclinic ---
            // Needs k >= 0 and full h, l plane
            for (let h = -max_mono; h <= max_mono; h++) {
                for (let k = 0; k <= max_mono; k++) { // k >= 0
                    for (let l = -max_mono; l <= max_mono; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        // Enforce uniqueness convention
                        if (k === 0) {
                            if (h < 0) continue;
                            if (h === 0 && l <= 0) continue;
                        }
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'orthorhombic') {
            // --- Orthorhombic ---
            // All positive octant (h,k,l) are unique
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= max_h; k++) {
                    for (let l = 0; l <= max_h; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'tetragonal' || system === 'hexagonal') {
            // --- Tetragonal & Hexagonal ---
            // (hkl) equiv to (khl). Enforce h >= k >= 0. l is independent.
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= h; k++) { // k <= h
                    for (let l = 0; l <= max_h; l++) { // l is independent
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        } else if (system === 'cubic') {
            // --- Cubic ---
            // (hkl) equiv to all permutations. Enforce h >= k >= l >= 0.
            for (let h = 0; h <= max_h; h++) {
                for (let k = 0; k <= h; k++) { // k <= h
                    for (let l = 0; l <= k; l++) { // l <= k
                        if (h === 0 && k === 0 && l === 0) continue;
                        hkls.push([h, k, l]);
                    }
                }
            }
        }
        
        // Sort by complexity (h^2+k^2+l^2)
        hkls.sort((a,b) => (a[0]*a[0]+a[1]*a[1]+a[2]*a[2])-(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]));
        return hkl_search_list_cache[system] = hkls;
    };


    const refineAndTestSolution = (initialParams) => {
    if (!initialParams || !initialParams.system) return;
    
    const min_lp = 2, max_lp = 50.0;
    const params_to_check = [];
    if (initialParams.a !== undefined) params_to_check.push(initialParams.a);
    if (initialParams.b !== undefined) params_to_check.push(initialParams.b);
    if (initialParams.c !== undefined) params_to_check.push(initialParams.c);

    if (params_to_check.some(p => (isNaN(p) || p < min_lp || p > max_lp))) {
        return; 
    }
    
    let candidate_cell = { ...initialParams }; 
    const { system } = initialParams;

    // --- STEP 1: Perform the initial indexing ---
    let initial_indexed_pairs = [];
    let initial_peak_indices = []; 
    
    const hkl_search_list = get_hkl_search_list(system); 
    
    for (let i = 0; i < N_FOR_M20; i++) {
        const q_o = q_obs[i], tolerance = get_q_tolerance(original_indices[i]);
        let best_match = null, min_diff = Infinity;
        
        for (const hkl of hkl_search_list) { 
            const q_calc = getQcalc(hkl, candidate_cell);
            const diff = Math.abs(q_calc - q_o);
            
            if (diff < min_diff) { 
                min_diff = diff; 
                best_match = hkl; 
            }
            
            if (system !== 'monoclinic' && q_calc > q_o + tolerance * 2) {
                 break; 
            }
        }
        
        if (best_match && min_diff < tolerance) {
            initial_indexed_pairs.push({ q_obs: q_o, hkl: best_match });
            initial_peak_indices.push(original_indices[i]);
        }
    }
    
    const min_indexed = { cubic: 4, tetragonal: 5, hexagonal: 5, orthorhombic: 6, monoclinic: 7 };
    
    if (initial_indexed_pairs.length < min_indexed[system]) {
        return;
    }
    
    // STEP 2: Perform Least-Squares Refinement ---
    // This block now ALWAYS runs 
    let fitResult_no_zero = null;
    const q_vec_initial = initial_indexed_pairs.map(p => p.q_obs);

    // 1. Build a design matrix *with* a zero-error column
    let M_with_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
    M_with_zero.forEach((row, i) => {
        const tth_rad = tth_obs_rad[initial_peak_indices[i]];
        row.push((-4 / (wavelength**2)) * Math.sin(tth_rad));
    });

    // 2. Solve for cell params *and* zero error
    const fitResult_with_zero = solveLeastSquares(M_with_zero, q_vec_initial, q_vec_initial);

    if (fitResult_with_zero && fitResult_with_zero.solution) {
        // 3. Get the initial zero correction (in degrees)
        let initial_zero_correction_rad = fitResult_with_zero.solution[fitResult_with_zero.solution.length - 1];
        let initial_zero_correction_deg = initial_zero_correction_rad * 180 / Math.PI;

        // 4. LIMIT the correction to the tth_error tolerance
        initial_zero_correction_deg = Math.max(-tth_error, Math.min(tth_error, initial_zero_correction_deg));
        
        // 5. Apply this *limited* correction to the observed q values
        const q_vec_corrected = [];
        for (let i = 0; i < initial_indexed_pairs.length; i++) {
            const original_tth_deg = tth_obs_rad[initial_peak_indices[i]] * 180 / Math.PI;
            const corrected_tth_rad = (original_tth_deg - initial_zero_correction_deg) * Math.PI / 180;
            const corrected_q = (4 * Math.sin(corrected_tth_rad / 2)**2) / (wavelength**2);
            q_vec_corrected.push(corrected_q);
        }

        // 6. Now solve *only* for cell params using the corrected q values
        let M_no_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
        fitResult_no_zero = solveLeastSquares(M_no_zero, q_vec_corrected, q_vec_corrected);
    }
    
    // Fallback: If the zero-refinement failed, run the original (non-zero-corrected) refinement.
    if (!fitResult_no_zero) {
        let M_no_zero = initial_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
        fitResult_no_zero = solveLeastSquares(M_no_zero, q_vec_initial, q_vec_initial);
    }
    

    if (!fitResult_no_zero || !fitResult_no_zero.solution) {
        return;
    }
    
    const initial_cell = extractCellFromFit(fitResult_no_zero.solution, system);
    if (!initial_cell) {
        return;
    }

    initial_cell.volume = getVolume(initial_cell);
    if (initial_cell.volume > max_volume || initial_cell.volume < 20) {
        return;
    }

// STEP 3: Validate the refined cell with M(20) and M(all)
    const q_calc_set = new Set(generateHKL_for_worker(initial_cell).map(r => r.q));
    const q_calc_sorted = new Float64Array(Array.from(q_calc_set)).sort((a,b)=>a-b);
    
    // --- Calculate M(20) and F(N_20) ---
    // Note: N_FOR_M20 is the variable (e.g., 20)
    // n_20 is the *actual* number of peaks used (e.g., 15 if file only has 15 peaks)
    const n_20 = Math.min(N_FOR_M20, peaks_sorted_by_q.length);
    const peaks_for_merit_20 = peaks_sorted_by_q.slice(0, n_20);
    const { m20, fN: fN_20 } = calculateFiguresOfMerit(q_calc_sorted, peaks_for_merit_20);
    
    if (m20 <= min_m20) { // Still use M(20) as the primary gatekeeper
        return;
    }

    // --- Calculate M(all) and F(all) ---
    const n_all = peaks_sorted_by_q.length;
    const peaks_for_merit_all = peaks_sorted_by_q; // Use all peaks
    // We pass `peaks_for_merit_all` which has N=n_all peaks
    const { m20: m_all, fN: fN_all } = calculateFiguresOfMerit(q_calc_sorted, peaks_for_merit_all);

    let final_solution_to_post = initial_cell;
    final_solution_to_post.m20 = m20;       // M(20)
    final_solution_to_post.fN_20 = fN_20;   // F(N_20)
    final_solution_to_post.n_20 = n_20;     // N_20
    final_solution_to_post.m_all = m_all;   // M(N_all)
    final_solution_to_post.fN_all = fN_all; // F(N_all)
    final_solution_to_post.n_all = n_all;   // N_all
    final_solution_to_post.errors = propagateErrors(system, fitResult_no_zero, initial_cell);






    // STEP 4: Perform the FINAL refinement WITH zero error, if the user enabled it
    if (refineZero) {
        const all_possible_reflections = generateHKL_for_worker(initial_cell);
        const final_indexed_pairs = [];
        const final_peak_indices_for_ls = [];
        const used_reflections = new Set();

        for (let i = 0; i < N_FOR_M20; i++) { 
            const q_o = q_obs[i];
            const tolerance = get_q_tolerance(original_indices[i]);
            let best_match_idx = -1, min_diff = Infinity;

            for (let j = 0; j < all_possible_reflections.length; j++) {
                const diff = Math.abs(all_possible_reflections[j].q - q_o);
                if (diff < min_diff) {
                    min_diff = diff;
                    best_match_idx = j;
                }
            }

            if (best_match_idx !== -1 && min_diff < tolerance && !used_reflections.has(best_match_idx)) {
                const {h, k, l} = all_possible_reflections[best_match_idx];
                final_indexed_pairs.push({ q_obs: q_o, hkl: [h, k, l] });
                final_peak_indices_for_ls.push(original_indices[i]);
                used_reflections.add(best_match_idx);
            }
        }
        
        if (final_indexed_pairs.length > min_indexed[system]) {
            let M_with_zero_final = final_indexed_pairs.map(p => getLSDesignRow(p.hkl, system));
            const q_vec_final = final_indexed_pairs.map(p => p.q_obs);
            M_with_zero_final.forEach((row, i) => {
                const tth_rad = tth_obs_rad[final_peak_indices_for_ls[i]];
                row.push((-4 / (wavelength**2)) * Math.sin(tth_rad));
            });

            const fitResult_with_zero_final = solveLeastSquares(M_with_zero_final, q_vec_final, q_vec_final);
            
            if (fitResult_with_zero_final && fitResult_with_zero_final.solution) {
                const refined_cell = extractCellFromFit(fitResult_with_zero_final.solution, system);
                if (refined_cell) {
                    refined_cell.zero_correction = fitResult_with_zero_final.solution[fitResult_with_zero_final.solution.length - 1] * 180 / Math.PI;
                    refined_cell.volume = getVolume(refined_cell);
                    

                    const q_calc_set_refined = new Set(generateHKL_for_worker(refined_cell).map(r => r.q));
                    const q_calc_sorted_refined = new Float64Array(Array.from(q_calc_set_refined)).sort((a,b)=>a-b);

                    // --- Calculate M(20) and F(N_20) for refined cell ---
                    const n_20_refined = Math.min(N_FOR_M20, peaks_sorted_by_q.length);
                    const peaks_for_merit_20_refined = [];
                    // Create corrected peak list for N <= 20
                    for (let i = 0; i < n_20_refined; i++) {
                        const original_peak = peaks_sorted_by_q[i];
                        const corrected_tth_deg = original_peak.tth - refined_cell.zero_correction;
                        const corrected_tth_rad = corrected_tth_deg * Math.PI / 180;
                        const corrected_q = (4 * Math.sin(corrected_tth_rad / 2)**2) / (wavelength**2);
                        peaks_for_merit_20_refined.push({ ...original_peak, q: corrected_q, tth: corrected_tth_deg });
                    }
                    
                    const { m20: final_m20, fN: final_fN_20 } = calculateFiguresOfMerit(q_calc_sorted_refined, peaks_for_merit_20_refined);
                    
                    if (final_m20 > min_m20) { // Still use M(20) as the gatekeeper
                        
                        // --- Calculate M(all) and F(all) for refined cell ---
                        const n_all_refined = peaks_sorted_by_q.length;
                        const peaks_for_merit_all_refined = [];
                        // Create corrected peak list for ALL N peaks
                        for (let i = 0; i < n_all_refined; i++) {
                            const original_peak = peaks_sorted_by_q[i];
                            const corrected_tth_deg = original_peak.tth - refined_cell.zero_correction;
                            const corrected_tth_rad = corrected_tth_deg * Math.PI / 180;
                            const corrected_q = (4 * Math.sin(corrected_tth_rad / 2)**2) / (wavelength**2);
                            peaks_for_merit_all_refined.push({ ...original_peak, q: corrected_q, tth: corrected_tth_deg });
                        }
                        
                        const { m20: final_m_all, fN: final_fN_all } = calculateFiguresOfMerit(q_calc_sorted_refined, peaks_for_merit_all_refined);
                        
                        // Attach all values to the final solution
                        refined_cell.m20 = final_m20;
                        refined_cell.fN_20 = final_fN_20;
                        refined_cell.n_20 = n_20_refined;
                        refined_cell.m_all = final_m_all;
                        refined_cell.fN_all = final_fN_all;
                        refined_cell.n_all = n_all_refined;
                        
                        refined_cell.errors = propagateErrors(system, fitResult_with_zero_final, refined_cell);
                        final_solution_to_post = refined_cell; 
                    }




                }
            }
        }
    }

    // STEP 5: Post the best found solution to the UI
    const key = getSolutionKey(final_solution_to_post);
    const existing = foundSolutionMap.get(key);
    if (!existing || final_solution_to_post.m20 > existing.m20) {
        self.postMessage({ type: 'solution', payload: final_solution_to_post });
        if (existing) {
            foundSolutions[existing.index] = final_solution_to_post;
        } else {
            foundSolutions.push(final_solution_to_post);
        }
        foundSolutionMap.set(key, { m20: final_solution_to_post.m20, index: existing ? existing.index : foundSolutions.length - 1 });
    }
};

    //  SEARCH ALGORITHMS 
    const indexCubic = () => {
        const h_max = 8;
        const totalIterations = Math.min(peaks.length, 10);
        if (totalIterations === 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) { 
            for (let h = 1; h <= h_max; h++) {
                for (let k = 0; k <= h; k++) {
                    for (let l = 0; l <= k; l++) {
                        if (!h && !k && !l) continue;
                        refineAndTestSolution({ a: Math.sqrt((h * h + k * k + l * l) / q_obs[i]), system: 'cubic' });
                    }
                }
            }
            // Report progress based on the outer loop
            const progress = ((i + 1) / totalIterations) * 80; // Scale to 80% (20% for transforms)
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };

    const indexTetragonalOrHexagonal = (system) => {
        const max_hkl = 5, i_depth = Math.min(10, peaks.length), j_depth = Math.min(10, peaks.length);
        const totalIterations = i_depth;
        if (totalIterations === 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) {
            for (let j = i + 1; j < j_depth; j++) {
                for (let h1 = 0; h1 <= max_hkl; h1++) for (let k1 = 0; k1 <= h1; k1++) for (let l1 = 0; l1 <= max_hkl; l1++) {
                    if (!h1 && !k1 && !l1) continue;
                    const S1 = system === 'tetragonal' ? h1 * h1 + k1 * k1 : h1 * h1 + h1 * k1 + k1 * k1;
                    for (let h2 = 0; h2 <= max_hkl; h2++) for (let k2 = 0; k2 <= h2; k2++) for (let l2 = 0; l2 <= max_hkl; l2++) {
                        if (!h2 && !k2 && !l2) continue;
                        const S2 = system === 'tetragonal' ? h2 * h2 + k2 * k2 : h2 * h2 + h2 * k2 + k2 * k2;
                        const det = S1 * l2 * l2 - S2 * l1 * l1;
                        if (Math.abs(det) < 1e-6) continue;
                        const a_term_inv = (q_obs[i] * l2 * l2 - q_obs[j] * l1 * l1) / det, c_term_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                        if (a_term_inv > 0 && c_term_inv > 0) {
                            const a = system === 'tetragonal' ? 1 / Math.sqrt(a_term_inv) : Math.sqrt(4 / (3 * a_term_inv));
                            refineAndTestSolution({ a: a, c: 1 / Math.sqrt(c_term_inv), system });
                        }
                    }
                }
            }
            const progress = ((i + 1) / totalIterations) * 80; 
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };

    const indexOrthorhombic = () => {
        const max_p = Math.min(10, q_obs.length), basis_hkls = get_hkl_search_list('orthorhombic').slice(0, 30);
        const totalIterations = max_p - 2;
        if (totalIterations <= 0) return;
        // ---

        for (let i = 0; i < totalIterations; i++) { 
            for (let j = i + 1; j < max_p - 1; j++) {
                for (let k = j + 1; k < max_p; k++) {
                    for (let n1 = 0; n1 < basis_hkls.length - 2; n1++) for (let n2 = n1 + 1; n2 < basis_hkls.length - 1; n2++) for (let n3 = n2 + 1; n3 < basis_hkls.length; n3++) {
                        const M = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]].map(hkl => [hkl[0] ** 2, hkl[1] ** 2, hkl[2] ** 2]);
                        const q_vec_for_guess = [q_obs[i], q_obs[j], q_obs[k]];
                        const fit = solveLeastSquares(M, q_vec_for_guess, q_vec_for_guess);

                        if (fit && fit.solution && fit.solution.every(s => s > 0)) {
                            refineAndTestSolution({ a: 1 / Math.sqrt(fit.solution[0]), b: 1 / Math.sqrt(fit.solution[1]), c: 1 / Math.sqrt(fit.solution[2]), system: 'orthorhombic' });
                        }
                    }
                }
            }
            // 
            const progress = ((i + 1) / totalIterations) * 80; // Scale to 80%
            self.postMessage({ type: 'progress', payload: progress });
            // ---
        }
    };



    // Helper function for indexMonoclinic
const generateBasisHKLs = (max_index = 3) => {
    const hkls = [];
    // Generate h,k,l up to max_index
    for (let h = -max_index; h <= max_index; h++) {
        for (let k = 0; k <= max_index; k++) { // k >= 0
            for (let l = -max_index; l <= max_index; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                
                // Enforce monoclinic uniqueness
                if (k === 0) {
                    if (h < 0) continue;
                    if (h === 0 && l <= 0) continue;
                }
                hkls.push([h, k, l]);
            }
        }
    }
    // Sort by complexity (sum of h^2+k^2+l^2)
    hkls.sort((a,b) => (a[0]*a[0]+a[1]*a[1]+a[2]*a[2]) - (b[0]*b[0]+b[1]*b[1]+b[2]*b[2]));
    return hkls;
};

// indexMonoclinic, quelques soucis avec beta < 90, je vais scanner uniquement >90
const indexMonoclinic = (opts = {}) => {
    // Options (override if needed)
    const MAX_BASIS = opts.maxBasis || 50;        // max basis size to use
    const MAX_PEAKS = opts.maxPeaks || 20;       // use first N peaks
    const SAMPLE_COMBINATIONS = opts.sampleCombinations || false; 
    const HKL_SAMPLE_SIZE = opts.hklSampleSize || 10000;  //augmenté de 5 à 10k
  //  const SAMPLE_TRIES = opts.sampleTries || 20000; 
    const MIN_DET = opts.minDeterminant || 1e-8; 
    const CELL_LIMITS = opts.cellLimits || { a: [2, 50], b: [2, 50], c: [2, 50] }; 

    // 1) Decide peaks to use
    const max_p = Math.min(MAX_PEAKS, q_obs.length);
    if (max_p < 4) return;

    // 2) Define HKL basis
    const basis_hkls_full = generateBasisHKLs(3); // Generate hkls up to index 3
    const basis_hkls = basis_hkls_full.slice(0, Math.min(basis_hkls_full.length, MAX_BASIS));
    
    const num_hkls = basis_hkls.length;
    if (num_hkls < 4) return;

    // Helper: check if two HKLs are linearly dependent / duplicates (simple check)
    const isDuplicateHKL = (hkl1, hkl2) => {
        if (hkl1[0] === hkl2[0] && hkl1[1] === hkl2[1] && hkl1[2] === hkl2[2]) return true;
        const a = hkl1[0], b = hkl1[1], c = hkl1[2];
        const x = hkl2[0], y = hkl2[1], z = hkl2[2];
        if ((a===0 && b===0 && c===0) || (x===0 && y===0 && z===0)) return true;
        let r = null;
        const pairs = [[a,x],[b,y],[c,z]];
        for (const [p,q] of pairs) {
            if (q === 0) {
                if (p !== 0) return false;
                continue;
            }
            if (r === null) r = p / q;
            else if (Math.abs(r - p/q) > 1e-8) return false;
        }
        return true;
    };

    // Helper: build M (4x4) from 4 hkls where Q = A*h^2 + B*k^2 + C*l^2 + D*h*l
    const buildM = (hkls) => hkls.map(hkl => [hkl[0]*hkl[0], hkl[1]*hkl[1], hkl[2]*hkl[2], hkl[0]*hkl[2]]);

    // Robust 4x4 solver
    const solve4x4 = (A, b) => {
        const M = A.map(r => r.slice());
        const v = b.slice();
        const n = 4;
        let det = 1;
        for (let i = 0; i < n; i++) {
            let maxRow = i;
            let maxVal = Math.abs(M[i][i]);
            for (let r = i+1; r < n; r++) {
                const val = Math.abs(M[r][i]);
                if (val > maxVal) { maxVal = val; maxRow = r; }
            }
            if (maxVal < 1e-14) return null; 
            if (maxRow !== i) {
                [M[i], M[maxRow]] = [M[maxRow], M[i]];
                [v[i], v[maxRow]] = [v[maxRow], v[i]];
                det = -det;
            }
            const pivot = M[i][i];
            det *= pivot;
            for (let r = i+1; r < n; r++) {
                const fac = M[r][i] / pivot;
                for (let c = i; c < n; c++) M[r][c] -= fac * M[i][c];
                v[r] -= fac * v[i];
            }
        }
        if (Math.abs(det) < MIN_DET) return null;
        const x = new Array(n).fill(0);
        for (let i = n-1; i >= 0; i--) {
            let s = v[i];
            for (let j = i+1; j < n; j++) s -= M[i][j] * x[j];
            x[i] = s / M[i][i];
        }
        return { solution: x, det };
    };

    // Simple plausibility test for the extracted cell
    const plausibleCellCheck = (cell) => {
        if (!isFinite(cell.a) || !isFinite(cell.b) || !isFinite(cell.c) || !isFinite(cell.beta)) return false;
        if (cell.a <= 0 || cell.b <= 0 || cell.c <= 0) return false;
        //  beta check to conventional range
        if (cell.beta < 90 || cell.beta > 150) return false;
        if (cell.a < CELL_LIMITS.a[0] || cell.a > CELL_LIMITS.a[1]) return false;
        if (cell.b < CELL_LIMITS.b[0] || cell.b > CELL_LIMITS.b[1]) return false;
        if (cell.c < CELL_LIMITS.c[0] || cell.c > CELL_LIMITS.c[1]) return false;
        return true;
    };

    // Prepare combinations generator (exhaustive or sampling)
    const combos = [];
    if (!SAMPLE_COMBINATIONS) {
        for (let i = 0; i < max_p - 3; i++) {
            for (let j = i + 1; j < max_p - 2; j++) {
                for (let k = j + 1; k < max_p - 1; k++) {
                    for (let l = k + 1; l < max_p; l++) {
                        combos.push([i,j,k,l]);
                    }
                }
            }
        }
    } else {
        const rng = () => Math.floor(Math.random() * max_p);
        for (let t = 0; t < SAMPLE_TRIES; t++) {
            let s = new Set();
            while (s.size < 4) s.add(rng());
            const arr = Array.from(s).sort((a,b)=>a-b);
            combos.push(arr);
        }
    }

    const totalProgressIterations = combos.length || 1;
    let progressCount = 0;

    const hklsCombosLimit = 200000;
    const allHKLCombos = [];
    const estimatedHKLQuads = (num_hkls * (num_hkls-1) * (num_hkls-2) * (num_hkls-3)) / 24;
    const hklsShouldSample = estimatedHKLQuads > hklsCombosLimit;

    if (!hklsShouldSample) {
        for (let n1 = 0; n1 < num_hkls - 3; n1++) {
            for (let n2 = n1 + 1; n2 < num_hkls - 2; n2++) {
                for (let n3 = n2 + 1; n3 < num_hkls - 1; n3++) {
                    for (let n4 = n3 + 1; n4 < num_hkls; n4++) {
                        allHKLCombos.push([n1,n2,n3,n4]);
                    }
                }
            }
        }
    }
    
    const all_q_indices_permutations = [
        [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1],
        [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0],
        [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0],
        [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]
    ];

    // Main loops
    for (const peakIndices of combos) {
        
        const hklsIter = hklsShouldSample ? (() => {
            const tries = HKL_SAMPLE_SIZE;
            const yielded = [];
            for (let t = 0; t < tries; t++) {
                const pick = [];
                while (pick.length < 4) {
                    const r = Math.floor(Math.random() * num_hkls);
                    if (!pick.includes(r)) pick.push(r);
                }
                pick.sort((a,b)=>a-b);
                yielded.push(pick);
            }
            return yielded;
        })() : allHKLCombos;

        for (const [n1,n2,n3,n4] of hklsIter) {
            const h1 = basis_hkls[n1], h2 = basis_hkls[n2], h3 = basis_hkls[n3], h4 = basis_hkls[n4];
            if (isDuplicateHKL(h1,h2) || isDuplicateHKL(h1,h3) || isDuplicateHKL(h1,h4) ||
                isDuplicateHKL(h2,h3) || isDuplicateHKL(h2,h4) || isDuplicateHKL(h3,h4)) continue;

            const hkls = [h1,h2,h3,h4];
            const M = buildM(hkls);
            
            const q_values = [ 
                q_obs[peakIndices[0]], q_obs[peakIndices[1]],
                q_obs[peakIndices[2]], q_obs[peakIndices[3]] 
            ];

            for (const p of all_q_indices_permutations) {
                const q_vec_permuted = [ q_values[p[0]], q_values[p[1]], q_values[p[2]], q_values[p[3]] ];

                const fit = solve4x4(M, q_vec_permuted);
                if (!fit) continue;

                const [P1, P2, P3, P4] = fit.solution; 
                if (!(P1 > 0 && P2 > 0 && P3 > 0)) continue;

                const A = P1, B = P2, C = P3, D = P4;
                
                const denom = 2 * Math.sqrt(A * C);
                if (!isFinite(denom) || Math.abs(denom) < 1e-14) continue;
                
                
                // The relationship is cos(beta) = D / (2*sqrt(A*C))
                // NOT -D / (2*sqrt(A*C)).
                const cosBeta = D / denom;
              

                if (!isFinite(cosBeta) || Math.abs(cosBeta) > 1 - 1e-6) continue;

                const cosB_clamped = Math.max(-1, Math.min(1, cosBeta));
                let betaRad = Math.acos(cosB_clamped);
                
                // Enforce conventional beta >= 90
                if (betaRad < (Math.PI / 2.0)) {
                    betaRad = Math.PI - betaRad;
                }
                
                const beta = betaRad * 180 / Math.PI;
                const sinBetaSq = 1 - Math.cos(betaRad)**2;

                if (sinBetaSq < 1e-6) continue;
                if (beta < 90.0 || beta > 150.0) continue;

                const a = 1 / Math.sqrt(A * sinBetaSq);
                const b = 1 / Math.sqrt(B);
                const c = 1 / Math.sqrt(C * sinBetaSq);

                const trialCell = { a, b, c, beta, system: 'monoclinic' };

                if (!plausibleCellCheck(trialCell)) continue;

                try {
                    refineAndTestSolution(trialCell);
                } catch (e) {
                    console.warn('refineAndTestSolution threw', e);
                }
            } 
        } 

        progressCount++;
        const progress = (progressCount / totalProgressIterations) * 80;
        self.postMessage({ type: 'progress', payload: progress });
    } 

    self.postMessage({ type: 'progress', payload: 100 });
};



// Helper function to calculate 3x3 determinant
function calculateDeterminant3x3(M) {
    return M[0][0] * (M[1][1]*M[2][2] - M[1][2]*M[2][1]) -
           M[0][1] * (M[1][0]*M[2][2] - M[1][2]*M[2][0]) +
           M[0][2] * (M[1][0]*M[2][1] - M[1][1]*M[2][0]);
}


// --- DERIVED/TRANSFORMED CELL SEARCH
const findTransformedSolutions = (initialSolutions) => {
        const cellTransforms = [ { P: [[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]] }, { P: [[-0.5, 0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, -0.5]] }, { P: [[0.5, 0.5, 0], [-0.5, 0.5, 0], [0, 0, 1]] }, { P: [[0.5, 0, 0], [0, 1, 0], [0, 0, 1]] }, { P: [[1, 0, 0], [0, 0.5, 0], [0, 0, 1]] }, { P: [[1, 0, 0], [0, 1, 0], [0, 0, 0.5]] }, { P: [[0.5, -0.5, 0], [0.5, 0.5, 0], [0, 0, 1]] } ];
        const totalSolutions = initialSolutions.length;
        if (totalSolutions === 0) return;

        initialSolutions.forEach((sol, index) => {
            // --- 1. Original Transformations ---
            cellTransforms.forEach(tf => {
                try {
                    const G = metricFromCell(sol); const Pt = transpose(tf.P); const Gprime = matMul(matMul(Pt, G), tf.P);
                    const candCell = cellFromMetric(Gprime);
                    const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
                    if (allowedSystems.includes(newSystem)) refineAndTestSolution({ ...candCell, system: newSystem });
                } catch {}
            });
            
            const indexedPeaks = []; // Re-index for GCD and Ortho-Hexagonal checks, comme CheckCell
            const theoretical_hkls_for_tf = generateHKL_for_worker(sol);
            for(let i=0; i<N_FOR_M20; i++){
                 const q_o = q_obs[i];
                 const best_match_idx = binarySearchClosest(theoretical_hkls_for_tf.map(h => h.q), q_o);
                 if(Math.abs(q_o - theoretical_hkls_for_tf[best_match_idx].q) < get_q_tolerance(original_indices[i])){
                     indexedPeaks.push(theoretical_hkls_for_tf[best_match_idx]);
                 }
            }

            if (indexedPeaks.length > 5) {
                const h_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.h)).filter(h => h > 0));
                const k_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.k)).filter(k => k > 0));
                const l_div = gcdOfList(indexedPeaks.map(p => Math.abs(p.l)).filter(l => l > 0));
                if (h_div > 1 || k_div > 1 || l_div > 1) {
                    const candCell = { ...sol, a: sol.a/h_div, b: (sol.b??sol.a)/k_div, c:(sol.c??sol.a)/l_div };
                    const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
                    if (allowedSystems.includes(newSystem)) refineAndTestSolution({ ...candCell, system: newSystem });
                }
            }
            if (sol.system === 'orthorhombic' && allowedSystems.includes('hexagonal')) {
                const axes = { a: sol.a, b: sol.b, c: sol.c }; const pairs = [['a','b','c'], ['a','c','b'], ['b','c','a']];
                pairs.forEach(([ax1, ax2, unique_ax]) => {
                    if (Math.abs(axes[ax2] / axes[ax1] / Math.sqrt(3) - 1) < 0.03) {
                        refineAndTestSolution({ system: 'hexagonal', a: axes[ax1], c: axes[unique_ax], beta: 90, gamma: 120 });
                    }
                });
            }

            // --- 2. "Swap Fishing" Strategy ---
            try {
                const system = sol.system;
                const min_peaks_needed = {cubic: 1, tetragonal: 2, hexagonal: 2, orthorhombic: 3, monoclinic: 4}[system];
                if (!min_peaks_needed || peaks.length < min_peaks_needed) return;

                const theoretical_hkls = generateHKL_for_worker(sol);
                const first_four_indexed = [];
                for(let i=0; i<4 && i < q_obs.length; i++){
                    const q_o = q_obs[i];
                    const best_match_idx = binarySearchClosest(theoretical_hkls.map(h => h.q), q_o);
                    if(Math.abs(q_o - theoretical_hkls[best_match_idx].q) < get_q_tolerance(original_indices[i])){
                        first_four_indexed.push({q_obs: q_o, hkl: [theoretical_hkls[best_match_idx].h, theoretical_hkls[best_match_idx].k, theoretical_hkls[best_match_idx].l]});
                    }
                }
                if (first_four_indexed.length < min_peaks_needed) return;

                let closest_pair = {i: -1, j: -1, diff: Infinity};
                for(let i=0; i<first_four_indexed.length; i++){
                    for(let j=i+1; j<first_four_indexed.length; j++){
                        const diff = Math.abs(first_four_indexed[i].q_obs - first_four_indexed[j].q_obs);
                        if(diff < closest_pair.diff){
                            closest_pair = {i, j, diff};
                        }
                    }
                }
                
                if(closest_pair.i !== -1){
                    const swapped_indexed_peaks = JSON.parse(JSON.stringify(first_four_indexed));
                    const temp_hkl = swapped_indexed_peaks[closest_pair.i].hkl;
                    swapped_indexed_peaks[closest_pair.i].hkl = swapped_indexed_peaks[closest_pair.j].hkl;
                    swapped_indexed_peaks[closest_pair.j].hkl = temp_hkl;
                    
                    const peaks_for_solve = swapped_indexed_peaks.slice(0, min_peaks_needed);
                    const M = peaks_for_solve.map(p => getLSDesignRow(p.hkl, system));
                    const q_vec = peaks_for_solve.map(p => p.q_obs);

                    const fit = solveLeastSquares(M, q_vec);
                    if(fit && fit.solution){
                        const new_trial_cell = extractCellFromFit(fit.solution, system);
                        if(new_trial_cell){
                           refineAndTestSolution(new_trial_cell);
                        }
                    }
                }
            } catch (e) {
                console.warn("Swap-fishing attempt failed:", e);
            }

            const progress = 80 + ((index + 1) / totalSolutions) * 15;
            self.postMessage({ type: 'progress', payload: progress });
        });
    };
       

 // --- EXECUTION & REPORTING
    postMessage({ type: 'status', payload: `Searching for ${systemToSearch} cells...` });
    self.postMessage({ type: 'progress', payload: 1 }); // Start at 1%

    if (systemToSearch === 'cubic') indexCubic();
    if (systemToSearch === 'tetragonal') indexTetragonalOrHexagonal('tetragonal');
    if (systemToSearch === 'hexagonal') indexTetragonalOrHexagonal('hexagonal');
    if (systemToSearch === 'orthorhombic') indexOrthorhombic();
    if (systemToSearch === 'monoclinic') indexMonoclinic();
    
    self.postMessage({ type: 'progress', payload: 80 });
    postMessage({ type: 'status', payload: `Analyzing transformations for ${systemToSearch}...` });
  
    findTransformedSolutions([...foundSolutions]);
    
  
    // Mark transform phase as 95% complete
    self.postMessage({ type: 'progress', payload: 95 });
    postMessage({ type: 'status', payload: `Analyzing ${systemToSearch}...` });
    // ---
    
    foundSolutions.forEach(solution => self.postMessage({ type: 'solution', payload: solution }));
  
    // Mark as 100% complete just before sending 'done'
    self.postMessage({ type: 'progress', payload: 100 });
    self.postMessage({ type: 'done' });
    // ---
};

/*
*** 21 oct 2025
- changement UI pour Ka2 strip
- changement de la partie traitement des données uniquement sur workingdata, identiques ou non à ce qu'on a lu
- changement de rapport pour inclure la nouvelle valeur et calcul de Ka1 ou Ka moyen
*** 23 oct 2025: 
- ajout de filtre lattice de Bravais pour le rapport PDF
- Savitzy avec 5 points pour les pics
- ordre des groupes d'espaces du plus symmetrique vers le standard dans le rapport
- 1.18 milliard de cellules en monoclinic !
- better sieveng -prend le beta le plus proche de 90, si le volume et M sont les mêmes
*** 25 oct 2025
- added F(N) in the report file
- sorted monoclinic if M is whithin 2%
*** 26 oct 2025
- use pickedPeaks, use only the peaks in the 2theta limits
*/

</script>

<div id="app-footer">Combs, version 26 oct 2025</div>
</body>
</html>
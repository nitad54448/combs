<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brutus Indexing - Technical Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --text-light: #f3f4f6;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --content-bg: #ffffff;
            --content-text: #1f2937;
            --content-heading: #111827;
            --code-bg: #f3f4f6;
            --code-text: #111827;
        }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--content-bg);
            color: var(--content-text); line-height: 1.7; display: flex;
            height: 100vh; overflow: hidden;
        }
        #left-panel {
            width: 280px; flex-shrink: 0; background-color: var(--dark-bg);
            color: var(--text-medium); padding: 2rem; overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        #left-panel .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--text-light);
            margin-bottom: 2rem;
        }
        #left-panel .logo span { color: var(--primary-accent); }
        #toc { list-style: none; padding: 0; margin: 0; }
        #toc li a {
            display: block; color: var(--text-dark); text-decoration: none;
            padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 500;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            border-left: 3px solid transparent;
        }
        #toc li a:hover { background-color: var(--medium-bg); color: var(--text-light); }
        #toc li a.active {
            background-color: var(--light-bg); color: var(--text-light);
            border-left-color: var(--primary-accent); font-weight: 600;
        }
        #main-content { flex-grow: 1; overflow-y: auto; padding: 3rem 4rem; }
        section {
            margin-bottom: 4rem; padding-top: 2rem; border-top: 1px solid #e5e7eb;
        }
        section:first-child { padding-top: 0; border-top: none; }
        h1, h2, h3, h4 {
            color: var(--content-heading); font-weight: 700; line-height: 1.3;
            margin-top: 1.5em; margin-bottom: 1em;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }
        p, li { margin-bottom: 1rem; }
        ul, ol { padding-left: 1.5rem; }
        a { color: var(--primary-accent); text-decoration: none; font-weight: 500; }
        a:hover { text-decoration: underline; }
        code {
            font-family: 'Source Code Pro', monospace; background-color: var(--code-bg);
            color: var(--code-text); padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg); border-radius: 0.5rem; padding: 1rem;
            overflow-x: auto; font-size: 0.85rem; line-height: 1.5;
        }
        pre code { padding: 0; background: none; }
        blockquote {
            margin-left: 0; padding: 1rem 1.5rem; border-left: 4px solid var(--primary-accent);
            background-color: #f9fafb; color: #4b5563;
        }
        blockquote strong {
            display: block; margin-bottom: 0.5rem; font-weight: 600; color: #111827;
        }
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; font-size: 0.9rem;
        }
        th, td { padding: 0.75rem 1rem; border: 1px solid #d1d5db; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .footer {
            text-align: center; margin-top: 4rem; padding-top: 2rem;
            border-top: 1px solid #e5e7eb; font-size: 0.85rem; color: #6b7280;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>
    <aside id="left-panel">
        <div class="logo">Help Guide: <span>Brutus</span></div>
        <nav>
            <ul id="toc">
                <li><a href="#introduction" class="active">Technical Overview</a></li>
                <li><a href="#quick-start">Quick Start Guide</a></li>
                <li><a href="#ui">The User Interface</a></li>
                <li><a href="#peak-finding">Peak Finding</a></li>
                <li><a href="#indexing-method">Indexing Algorithm</a></li>
                <li><a href="#evaluating-solutions">Evaluating Solutions</a></li>
                <li><a href="#space-group-analysis">Space Group Analysis</a></li>
                <li><a href="#advanced-topics">Advanced Topics</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
                <li><a href="#references">References</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <section id="introduction">
            <h1>Technical Overview & Methodology</h1>
            <p>This document provides a technical reference for the Brutus Powder Indexing software. It details the program's algorithms, search parameters, and methodologies for scientists and researchers familiar with powder X-ray diffraction techniques.</p>

            <h3>Core Methodology</h3>
            <p>
                The goal of <em>ab initio</em> powder indexing is to determine the unit cell parameters ($a, b, c, \alpha, \beta, \gamma$) from a list of observed diffraction peak positions ($2\theta$). This program implements a system-specific, exhaustive search algorithm to solve this problem.
            </p>
            <p>
                The core principle is to assume that a small subset of the most intense, low-angle reflections must correspond to simple crystal planes with low-integer Miller indices $(hkl)$. The program solves the indexing equations by taking the exact number of unknown parameters for a given crystal system and solving a system of linear equations using that many observed peaks.
            </p>
             <p>
                To linearize the indexing equations, all peak positions are first converted from $2\theta$ to Q-space, where $Q = 1/d^2$. The relationship between $Q$, the Miller indices, and the reciprocal cell parameters ($A, B, C, D, E, F$) is given by the general quadratic form:
                $$ Q_{hkl} = Ah^2 + Bk^2 + Cl^2 + Dkl + Ehl + Fhk $$
                The software solves for these reciprocal parameters (or a subset of them, depending on the crystal system) and then converts them back to the real-space cell parameters for the final solution. Each trial cell is immediately refined and scored against the full peak list.
            </p>
        </section>

        <section id="quick-start">
            <h2>Quick Start Guide</h2>
            <p>Follow these steps for a standard indexing routine on a single-phase powder pattern.</p>
            <ol>
                <li><strong>Load Data File:</strong> Use the <code>Select Data File</code> button. Supported formats include <code>.xy</code>, <code>.xrdml</code>, <code>.ras</code>, etc.</li>
                <li><strong>Find Peaks:</strong> On the <strong>Peaks</strong> tab, adjust the <code>Min peak (%)</code>, <code>Radius (pts)</code>, and <code>Points</code> sliders to accurately capture your experimental peaks.</li>
                <li><strong>Review & Refine Peaks:</strong> Critically examine the peak list. Edit 2θ positions for accuracy, delete spurious peaks (noise, Kα2 shoulders if *not* stripping), and add any missed reflections using <code>Ctrl + Click</code> on the chart. A clean list of 15-20 peaks is ideal.</li>
                <li><strong>Set Parameters:</strong> On the <strong>Parameters</strong> tab:
                    <ul>
                        <li>Select the appropriate X-ray <code>Radiation Preset</code> (e.g., Cu Ka).</li>
                        <li>Decide whether to enable <code>Strip K-alpha2</code>. This choice updates the <code>Ka1 Wavelength</code> field automatically. The default is OFF, using the average Ka wavelength.</li>
                        <li>Set a chemically sensible <code>Max Volume (Å³)</code> to constrain the search.</li>
                        <li>Set the <code>2θ Error (°)</code> appropriate for your instrument's resolution (e.g., 0.02° for synchrotron, 0.05° for lab data).</li>
                        <li>The <strong>Refine Zero-Point Error</strong> checkbox is enabled by default and is highly recommended.</li>
                        <li>Select the crystal systems to search. Checking Monoclinic or Triclinic will enable GPU-accelerated searching.</li>
                    </ul>
                </li>
                <li><strong>Start Indexing:</strong> Click <code>Start Indexing</code>.</li>
                <li><strong>Analyze Solutions:</strong> On the <strong>Solutions</strong> tab, review the results. Sort by M(20) and F(20) scores. Click on high-scoring solutions to visually compare the calculated (blue) and observed (red) peak markers on the chart. A good solution will also have plausible space group suggestions.</li>
            </ol>
        </section>

        <section id="ui">
            <h2>The User Interface</h2>
            <p>The application is divided into the Controls Panel (left) and the Results Area (right).</p>

            <h3>Controls Panel</h3>
            <p>This panel contains all inputs and controls, organized into three primary tabs.</p>
            <h4>1. Peaks Tab</h4>
            <ul>
                <li><strong>Peak Finding Sliders:</strong> Control the background subtraction (<code>Radius</code>), data smoothing (<code>Points</code>), and peak detection threshold (<code>Min peak</code>, logarithmic scale).</li>
                <li><strong>2θ Range Sliders:</strong> Define the angular range for peak detection, useful for excluding noisy regions.</li>
                <li><strong>Peak Table:</strong> A list of all detected peaks. <code>2θ Obs (°)</code> values can be manually edited for precision.</li>
            </ul>

            <h4>2. Parameters Tab</h4>
            <ul>
                <li><strong>Radiation Preset:</strong> Select the X-ray source used (e.g., Cu Ka, Co Ka). This sets the appropriate wavelengths.</li>
                <li><strong>Ka1 Wavelength (Å):</strong> Displays the wavelength being used for calculations. If a preset is selected, this value automatically updates based on the <code>Strip K-alpha2</code> setting (shows Ka1 if ON, average Ka if OFF). It is editable only when <code>Custom</code> preset is chosen.</li>
                <li><strong>Strip K-alpha2:</strong> If checked, applies a Rachinger algorithm to numerically remove the Kα2 component from the data before peak finding and analysis. This also sets the <code>Ka1 Wavelength</code> field to the pure Kα1 value. Default is OFF.</li>
                <li><strong>Max Volume (Å³):</strong> The upper limit for acceptable unit cell volume. A key parameter for constraining the search.</li>
                <li><strong>Impurity Peaks:</strong> Number of allowed un-indexed peaks among the first 20 when calculating M(20).</li>
                <li><strong>2θ Error (°):</strong> Tolerance for matching calculated to observed peaks.</li>
                <li><strong>Refine Zero-Point Error:</strong> Controls whether a full, unconstrained zero-point refinement is applied to the final reported solution.</li>
                <li><strong>Crystal Systems to Search:</strong> Checkboxes for Cubic, Tetragonal, Hexagonal, Orthorhombic, Monoclinic, and Triclinic systems.</li>
            </ul>

            <h4>3. Solutions Tab</h4>
            <ul>
                <li><strong>Solutions Table:</strong> Lists all valid solutions found, with their system, parameters, volume, M(20) score, and F(20) score. Click a row to select it for visual analysis on the chart.<br>When the search is finished, you can filter the solutions based on symmetry by enabling/disabling crystal systems.</li>
            </ul>

            <h3>Results Area</h3>
            <ul>
                <li><strong>Chart:</strong> Displays the diffraction pattern, observed peaks (red ticks), and calculated peaks for the selected solution (blue ticks). A good fit shows excellent alignment between red and blue ticks.</li>
                <li><strong>Chart Interaction:</strong> Zoom (mouse wheel), Pan (click-drag), Reset Zoom (right-click), Add Peak (<code>Ctrl + Click</code>).</li>
            </ul>
        </section>

        <section id="peak-finding">
            <h2>Peak Finding in Detail</h2>
            <p>Accurate peak positions are the most critical input for successful indexing. The program uses a multi-step process to identify peaks from raw data.</p>

            <h4>The Algorithm Steps</h4>
            <ol>
                <li><strong>Kα2 Stripping (Optional):</strong> If <code>Strip K-alpha2</code> is checked, the Rachinger algorithm is applied to the raw intensity data first.</li>
                <li><strong>Background Subtraction:</strong> A "rolling ball" algorithm estimates and subtracts the background signal from the (potentially stripped) data. The <code>Radius</code> slider controls the size of the virtual ball.</li>
                <li><strong>Data Smoothing:</strong> A Savitzky-Golay filter is applied to the background-subtracted data to reduce noise while preserving peak shape. The <code>Points</code> slider controls the smoothing window size.</li>
                <li><strong>Peak Detection:</strong> The algorithm identifies local maxima in the smoothed data that are above the <code>Min peak (%)</code> threshold.</li>
                <li>
                    <strong>Position Refinement:</strong> To find a precise, sub-pixel peak position, the algorithm performs a 5-point least-squares quadratic fit (based on Savitzky-Golay coefficients) on the data points surrounding the detected maximum. This is more accurate than a simple 3-point parabola and robust against noise. If a peak is too close to the data's edge, it falls back to a 3-point fit.
                </li>
            </ol>

            <h4>Practical Advice</h4>
            <ul>
                <li>Start with default values and visually inspect the results.</li>
                <li>If weak but clear peaks are missed, lower the <code>Min peak (%)</code>. If picking up noise, increase it.</li>
                <li>For patterns with a broad amorphous background, increase the <code>Radius</code>.</li>
                <li>If data is very noisy, increase smoothing <code>Points</code>, but avoid over-smoothing, which can merge or shift peaks.</li>
                <li><strong>Always manually curate the final peak list.</strong> Remove artifacts and known impurity peaks. If <strong>not</strong> stripping Kα2, be sure to delete the Kα2 shoulders manually.</li>
                <li>Kα2 stripping can simplify patterns but may introduce small artifacts. If indexing fails with stripping ON, try turning it OFF and manually removing the α2 peaks.</li>
            </ul>
        </section>


        <section id="indexing-method">
    <h2>Indexing Algorithm and Search Parameters</h2>
    <p>The program employs a dedicated search routine for each crystal system. This is an "exhaustive" or "brute-force" trial method that iterates through combinations of low-angle peaks and low-integer Miller indices. The number of peaks required to generate a trial cell depends on the number of unknown lattice parameters.</p>

    <h3>System-by-System Search Logic</h3>
    <p>The search algorithm's goal is to solve a system of linear equations of the form $Q_{obs} = \sum P_i \cdot H_i$, where $Q_{obs}$ are the $1/d^2$ values from the observed peaks, $H_i$ are terms derived from the trial Miller indices (e.g., $h^2, k^2, l^2$), and $P_i$ are the reciprocal lattice parameters (e.g., $A=1/a^{*2}, B=1/b^{*2}, ...$) we want to find.</p>
    <ul>
        <li>
            <strong>Cubic (1 parameter, $A=1/a^2$) - CPU Worker:</strong>
            Solves a 1x1 system:
            $$ Q_{obs, 1} = (h_1^2 + k_1^2 + l_1^2) \cdot A $$
            The program iterates through the first 10 observed peaks, assigning each one a single trial $(hkl)$ vector (where $h,k,l$ are integers up to 8) to find a trial $a$-value.
        </li>
        <li>
            <strong>Tetragonal & Hexagonal (2 parameters, $P_1, P_2$) - CPU Worker:</strong>
            Solves a 2x2 system of equations using pairs of peaks from the first 10:
            $$ Q_{obs, 1} = H_{1,a} \cdot P_1 + H_{1,c} \cdot P_2 $$
            $$ Q_{obs, 2} = H_{2,a} \cdot P_1 + H_{2,c} \cdot P_2 $$
            It assigns pairs of trial $(hkl)$ vectors (where $h,k,l$ are integers up to 8) to solve for $P_1$ and $P_2$, which are then converted to $a$ and $c$.
        </li>

        <li>
<strong>Orthorhombic (3 parameters, $A, B, C$) - CPU Worker:</strong>
Solves a 3x3 system for the reciprocal parameters ($1/a^2, 1/b^2, 1/c^2$).
<br><br>
It iterates through all combinations of 3 peaks from the first <strong>10</strong> ($\binom{10}{3} = 120$ combos).
For <em>each</em> peak triplet, it systematically tests <strong>every possible combination</strong> of 3 HKLs drawn from a basis set of <strong>80</strong> simple reflections ($\binom{80}{3} = 82,160$ combos).
The total search space is $120 \times 82,160 = \textbf{9,859,200 combinations}$. This is a fully exhaustive search of this HKL basis set.
</li>





<li>
    <strong>Monoclinic (4 parameters, $A, B, C, D$) - WebGPU Accelerated (Exhaustive):</strong>
    Solves a 4x4 system for the four reciprocal parameters.
    <br><br>
    This search is performed on the GPU. It iterates through all combinations of 4 peaks from the first <strong>10</strong> ($\binom{10}{4} = 210$ combos).
    For <em>each</em> peak quadruplet, it tests every possible combination of 4 HKLs drawn from a basis set of <strong>100</strong> simple reflections. The total HKL combinations are $\binom{100}{4} = 3,921,225$.
    The total search space is $210 \times 3,921,225 = \textbf{823.5 Million combinations}$.
    <br>
    <em>Note: Using 100 HKLs keeps the buffer size at a safe $\approx 63 \text{ MB}$, ensuring compatibility with most GPUs.</em>
    <br>
    <em>Note: Search is constrained to cell edges between 2 and 50 Å, and a $\beta$ angle between 90° and 150°.</em>
</li>

<li>
    <strong>Triclinic (6 parameters, $A, B, C, D, E, F$) - WebGPU Accelerated (Exhaustive Chunked Search):</strong>
    Solves the full 6x6 system for all reciprocal parameters. This is the most computationally demanding search, executed entirely on the <strong>GPU (WebGPU)</strong>.
    <br><br>
    It iterates through all combinations of 6 peaks from the first <strong>10</strong> ($\binom{10}{6} = 210$ combos).
    For <em>each</em> peak sextuplet, it tests every possible combination of 6 HKLs drawn from a basis set of <strong>100</strong> simple reflections. The total HKL combinations are $\binom{100}{6} = 1,192,052,400$.
    This defines a total search space of $210 \times 1,192,052,400 = \textbf{250.3 Billion combinations}$.
    <br><br>
    <em><strong>Note on Chunks:</strong> The total number of HKL combinations ($\approx 1.19 \text{ Billion}$) is too large for most GPUs to handle at once. 
        The program automatically splits this HKL list into smaller "chunks" (e.g., ~14 for a 2Gb WebGPU buffer) and sends them to the GPU one by one.</em>
    <br><br>
    <em><strong>To Tweak:</strong> The search parameters are set in <code>brutus.html</code> inside the <code>startIndexing</code> function.</em>
    <ul>
        <li><em>To change the <strong>10-peak</strong> basis (for Monoclinic/Triclinic), edit the <code>max_p</code> variable for each system.</em></li>
        <li><em>To change the <strong>100-HKL</strong> basis (for Monoclinic), edit its <code>slice(0, 100)</code> value.</em></li>
        <li><em>To change the <strong>100-HKL</strong> basis (for Triclinic), edit its <code>slice(0, 100)</code> value.</em></li>
    </ul>
    <br>
    <em>Note: Search is constrained to cell edges between 2 and 50 Å, and all angles ($\alpha, \beta, \gamma$) between 60° and 150°.</em>
</li>

        
    <blockquote>
        <strong>A Note on Performance (WebGPU vs. CPU):</strong>
        <p>
            The searches for Cubic, Tetragonal, Hexagonal, and Orthorhombic are performed on the CPU (in a Web Worker) and are typically very fast (seconds to minutes).
        </p>
        <p>
            The far more complex Monoclinic and Triclinic searches are offloaded to your computer's GPU (via WebGPU). This technology is now supported by default in all major modern browsers (including Chrome, Edge, Firefox, and Safari), making high-speed indexing widely accessible. This allows the program to test *billions* of combinations in seconds or 10-20 minutes for triclinic, a task that would take many hours or even many days on a CPU.
        </p>
        <p>
            On a modern GPU, the testing speed can exceed $10^8$ trials per second, depending on your hardware. This is several orders of magnitude faster than the CPU-based version. For the search to run at full speed, the browser tab must remain visible and active, otherwise the browser may throttle the calculation.
        </p>
    </blockquote>
   

</section>



        <section id="evaluating-solutions">
            <h2>Evaluating Solutions</h2>
            <p>The indexing search often produces multiple candidate solutions. During the search the solutions will be dynamically limited to best 50 solutions. Distinguishing the correct one requires a reliable figure of merit and careful refinement.</p>

            <h3>The de Wolff Figure of Merit: M(20)</h3>
            <p>Solutions are ranked by the <strong>de Wolff Figure of Merit, M(20)</strong>, which assesses the fit's accuracy and completeness. It is calculated using the first 20 observed reflections. A high M(20) value is a strong indicator of a correct solution.</p>
            <table>
                <thead><tr><th>M(20) Value</th><th>Interpretation</th></tr></thead>
                <tbody>
                    <tr><td>> 20</td><td>The solution is very likely to be correct.</td></tr>
                    <tr><td>> 10</td><td>The solution is likely correct, especially if the volume is chemically sensible.</td></tr>
                    <tr><td>5 - 10</td><td>The solution is plausible and deserves further investigation.</td></tr>
                    <tr><td>&lt; 5</td><td>The solution is likely spurious and should be viewed with skepticism.</td></tr>
                </tbody>
            </table>

            <h3>The F(N) Figure of Merit</h3>
            <p>
                As a complementary metric to M(20), the program also calculates the <strong>F(N) Figure of Merit</strong>, typically for N=20 (F(20)). While M(20) focuses on the completeness and accuracy of the first 20 lines, F(N) provides a score based on the average positional accuracy of those lines.
            </p>
            <p>
                It is defined by the formula:
                $$ F_N = \frac{N}{\langle |\Delta(2\theta)| \rangle \cdot N_{calc}} $$
                Where:
            </p>
            <ul>
                <li>$N$ is the number of observed lines being evaluated (e.g., 20).</li>
                <li>$\langle |\Delta(2\theta)| \rangle$ is the average absolute discrepancy between observed and calculated $2\theta$ positions for those $N$ lines.</li>
                <li>$N_{calc}$ is the number of *possible* theoretical reflections (including unobserved ones) up to the $2\theta$ position of the $N^{th}$ observed line.</li>
            </ul>
            <p>
                A high F(N) value indicates a very high-quality fit with low average error. Together, a high M(20) (indicating a correct and complete cell) and a high F(N) (indicating high precision) give strong confidence in a solution.
            </p>

            <h3>Least-Squares and Zero-Point Refinement</h3>
            <p>
                Every promising trial cell is refined using a robust, two-stage process to find the best possible parameters and M(20) score.
            </p>
            <h4>Stage 1: Internal Zero-Point Correction</h4>
            <p>
                To generate the most accurate cell proposal, the program <strong>always</strong> performs an initial refinement that includes a zero-point error term. This internal correction is strictly limited (constrained to be no larger than the user-defined `2θ Error`) to account for minor instrument misalignments without overfitting. The resulting corrected peak positions are then used to refine a baseline set of lattice parameters. This makes the initial cell proposal much more robust against small experimental shifts.
            </p>
            <h4>Stage 2: Final (Optional) Zero-Point Refinement</h4>
            <p>
                If the cell from Stage 1 achieves a high M(20) score, and the user has the <code>Refine Zero-Point Error</code> checkbox enabled, a second, <strong>full and unconstrained</strong> refinement is performed. This final step solves for all parameters simultaneously to produce the final reported values and their estimated standard deviations. If this option is disabled, only the lattice parameters from Stage 1 are reported.
            </p>
        </section>

        <section id="space-group-analysis">
            <h2>Space Group Analysis</h2>
            <p>
                After a high-scoring unit cell is found, the program provides an automated analysis to suggest the most probable space groups. This feature serves as a powerful guide for subsequent structure solution or Rietveld refinement.
            </p>

            <h3>Methodology</h3>
            <p>The analysis is a systematic process of elimination based on observed systematic absences:</p>
            <ol>
                <li>
                    <strong>Generate Unique Reflections:</strong> The program takes the refined unit cell and generates a complete theoretical reflection list, ensuring only crystallographically unique reflections (e.g., `(100)`, but not `(-100)`) are included to prevent self-ambiguity.
                </li>
                <li>
                    <strong>Index Observed Peaks:</strong> It then indexes <em>all</em> observed peaks from the user's list against this theoretical pattern.
                </li>
                <li>
                    <strong>Build High-Confidence Set:</strong> To avoid errors from accidental peak overlap (e.g., `(100)` and `(011)` having very similar $2\theta$ values), the algorithm filters the indexed list to find <strong>unambiguous</strong> reflections. A reflection is considered unambiguous only if no other theoretical $(hkl)$ line is calculated to be within the `2θ Error` tolerance of its position.
                </li>
                <li>
                    <strong>Determine Centering & Extinctions:</strong> This high-confidence set of <em>observed</em> $(hkl)$s is used for all further analysis. It is tested against the rules for lattice centerings and glide/screw axes. A violation is only counted if an <em>observed unambiguous peak</em> breaks a rule.
                </li>
                <li>
                    <strong>Rank Space Groups:</strong> The program filters its internal database for all space groups matching the solution's crystal system and plausible centering(s). Each candidate group is ranked by its number of violations.
                </li>
            </ol>

            <h3>How to Interpret the Results</h3>
            <ul>
                <li><strong>0 Violations:</strong> This is the ideal result. It means that <em>no observed unambiguous reflection</em> violated any of the space group's extinction rules. These are the strongest candidates.</li>
                <li><strong>1-2 Violations:</strong> These are still plausible. A single violation could be caused by an experimental artifact or a weak, theoretically-forbidden reflection.</li>
                <li><strong>Ambiguous Peaks (in italics):</strong> In the PDF report's reflection table, any peak that was identified as ambiguous (and therefore excluded from the analysis) is printed in an <em>italic</em> font for easy identification.</li>
            </ul>
        </section>

        <section id="advanced-topics">
            <h2>Advanced Topics: Enhanced Search and Sieving</h2>
            <p>
                To improve the success rate, the program integrates several advanced search strategies after the initial indexing routine is complete. These "fishing" strategies test for non-obvious but crystallographically common relationships.
            </p>

            <h3>1. "Swap Fishing" for Ambiguity</h3>
            <p>
                For each promising solution, the program re-examines the indexing of the <strong>first four low-angle peaks</strong>. It identifies the two peaks that are closest to each other, as this is a likely point of mis-indexing due to ambiguity. It then creates a new hypothesis by <strong>swapping their HKL assignments</strong> and attempts to solve for a new trial cell. This new cell is then sent back through the full refinement and scoring process. If this "swapped" hypothesis is correct, it will often lead to a solution with a significantly higher M(20) score.
            </p>

            <h3>2. Matrix-based Cell Transformations</h3>
            <p>Solutions are transformed using crystallographic matrices to test for related primitive or higher-symmetry cells. For example, a body-centered cell ($I$) is tested for a valid primitive ($P$) equivalent.</p>

            <h3>3. HKL Divisor Analysis</h3>
            <p>The program examines the list of indexed Miller indices. If all indices in one direction (e.g., all $h$ values) share a common divisor, it tests a new cell with the corresponding axis halved (a sub-cell).</p>

            <h3>4. Orthorhombic to Hexagonal Check</h3>
            <p>A hexagonal lattice can sometimes be indexed as a C-centered orthorhombic cell where $b/a \approx \sqrt{3}$. The program specifically checks all orthorhombic solutions for this condition and generates the equivalent hexagonal cell for evaluation.</p>

            <h3>5. Niggli Cell Standardization</h3>
            <p>
                After a potential solution is found, the program calculates its <strong>Niggli reduced cell</strong>. This is a fundamental and unique, standardized representation of the crystal lattice, also known as the "reduced primitive cell".
            </p>
            <p>
                The calculation first transforms the conventional (centered) cell found by the program—using the detected centering (e.g., 'I', 'F', 'C')—into its primitive form. It then applies a mathematical reduction algorithm to find the basis vectors ($a, b, c$) and angles ($\alpha, \beta, \gamma$) that are the most "compact" and obey a specific set of geometric rules.
            </p>
            <p>
                This Niggli cell is extremely useful for:
            </p>
            <ul>
                <li><strong>Identifying a structure:</strong> It provides a canonical form for searching crystal databases (like the ICDD or CSD), as two different conventional cells (e.g., a C-centered monoclinic and a primitive monoclinic) can reduce to the same Niggli cell if they describe the same lattice.</li>
                <li><strong>Symmetry determination:</strong> The specific conditions of the Niggli cell parameters directly correlate with the 14 Bravais lattices and 7 crystal systems.</li>
                <li><strong>Standardization:</strong> It removes ambiguity in how a unit cell is reported.</li>
            </ul>
            <p>
                The calculated Niggli cell for each high-scoring solution is reported in the detailed section of the PDF report to aid in further analysis and database comparison.
            </p>

            <h3>6. Final Sieving</h3>
            <p>
                After all searches, a final sieving process is applied to remove redundant solutions. If two solutions have very similar volumes (within 1%), the one with higher symmetry is preferred.
            </p>
            <p>
                If the symmetries are also equal (e.g., two different monoclinic cells), the program compares their M(20) scores. Crucially, it treats M(20) scores as "effectively equal" if they are within a small tolerance (e.g., $\Delta M(20) < 0.05$). In this tie-breaker scenario, it invokes crystallographic conventions:
            </p>
            <ul>
                <li><strong>For Monoclinic Cells:</strong> A special filter is applied. If two monoclinic solutions have <strong>volumes within 2%</strong> of each other and have effectively equal M(20) scores, the program will prefer the solution whose $\beta$ angle is <strong>closer to 90°</strong> (e.g., 106° will be preferred over 147°).</li>
                <li><strong>For Other Systems:</strong> If M(20) scores are tied, the first solution found is retained.</li>
            </ul>
        </section>

        <section id="troubleshooting">
            <h2>Troubleshooting & FAQ</h2>

            <h4>Why were no solutions found?</h4>
            <ul>
                <li><strong>Poor Peak List:</strong> The most common cause. Ensure the peak list is accurate, with impurity peaks removed and positions refined. A minimum of 15-20 clean peaks is recommended.
                For low symmetry make sure the first 10 peaks are accurate and have largest interplanar distances.</li>
                <li><strong>Incorrect Parameters:</strong> Verify the <code>Wavelength</code> and ensure the <code>Max Volume</code> is chemically reasonable and sufficiently large.</li>
                <li><strong>High Zero-Point Error:</strong> While the program corrects for small zero errors internally, a very large instrument misalignment may still cause failure.</li>
                <li><strong>Sample is a Mixture:</strong> Indexing requires a peak list from a single crystalline phase.</li>
            </ul>

            <h4>Why is M(20) low for a visually good fit?</h4>
            <ul>
                <li><strong>Incorrect Cell (Sub-multiple/Super-multiple):</strong> The found cell may be a multiple or sub-multiple of the true cell. It indexes some lines but is penalized by M(20) for being too "empty" or "dense" with calculated reflections.</li>
                <li><strong>High Error / Low Resolution:</strong> The <code>2θ Error</code> might be set too tight for broad peaks. Try slightly increasing this value.</li>
                <li><strong>Spurious Solution:</strong> A random solution can sometimes fit a few lines by chance. Visual inspection is key; if major observed peaks are missed by the calculated pattern, the solution is incorrect regardless of the M(20) value.</li>
            </ul>

                        <h4>Test files</h4>
            <ul>
                <li>In the github repository you will find several test files</li>
                <li><strong>Monoclinic_test_1.xy</strong> This a synchrotron XRD file for a monoclinic sample, measured with a monochromatic radiation of 0.79764 A. The values of the lattice parameters are 19.877, 8.196, 11.243 and beta 106.08.</li>
                <li><strong>C61Br2_079764.XY</strong> A dibromo-methano fullerene measured at ESRF with a wavelength of 0.79764 A. It contains an impurity peak at about 16.24 deg 2 theta. There are many solutions, a most likely is a cubic I, with a=18.92 A.</li>
                <li><strong>SPDDRR1_sample2_0692.xy</strong> Data taken from a round robin, measured at Daresbury with 0.692 A. The probable cell is orthorhombic with a=10.983, b=12.852, c=15.740 A.</li>
                <li><strong>SPDDRR1_sample2_Cu.xy</strong> Same sample as the previous listing, measured with a Cu Ka laboratory instrument.</li>
                <li><strong>SPDDRR1_zhu1_Cu.xy</strong> Sample 1 from the same Round Robin, measured with a Cu Ka X-ray tube; likely a monoclinic with a=7.672, b=9.624, c=7.076, beta=106.24</li>
                <li><strong>PbSO4.xra and FAP.xra</strong> Laboratory Cu Ka samples: orthorhombic and hexagonal, respectively.</li>
            
              <li><strong>P-1_sim_5_6_7_86_91_96.txt</strong> This is a simulated powder diffraction pattern for a P-1 lattice, wavelenght 1.7 A, and the lattice parameters a=5.0, b=6.0, c=7.0, alpha=86.0, beta=91.0 and gamma=96.0 deg. On a Windows PC, with Chrome and Nvidia T1000 8GPU card, it takes less than 3 minutes to find a solution with M(20)=86.89 (or an equivalent one, such as a=6.000, b=6.998, c=4.997, alpha=91.0, beta=83.99 and gamma=93.99 deg).
                On the CPU version of this indexing program (see combs.html) a solution will be found after about 24 hours.</li>

            
            </ul>

            
        </section>


                    <section id="references">
            <h2>References</h2>
            <p>This program was developed by Nita Dragoe at Université Paris-Saclay (2024-2025) as a successor to a prior software, Powder, originally created by the same author in 1999-2000. If you use this program (Brutus) you can cite this reference <a href="https://doi.org/10.13140/RG.2.2.13443.57126">https://doi.org/10.13140/RG.2.2.13443.57126</a>. <br>For a deeper understanding of the methodology, consulting the original scientific papers is highly recommended.</p>
            <ol>
                <li>
                    <strong>The M(20) Figure of Merit:</strong><br>
                    de Wolff, P. M. (1968). "A Simplified Criterion for the Reliability of a Powder Pattern Indexing." <em>Journal of Applied Crystallography</em>, <strong>1</strong>, 108-113.
                </li>
                <li>
                    <strong>The F(N) Figure of Merit:</strong><br>
                    Smith, G. S. & Snyder, R. L. (1979). "F(N): A Criterion for Rating Powder Diffraction Patterns and Evaluating the Reliability of Powder-Pattern Indexing." <em>Journal of Applied Crystallography</em>, <strong>12</strong>, 60-65.
                </li>
                <li>
                    <strong>General Powder Diffraction Text:</strong><br>
                    Klug, H. P. & Alexander, L. E. (1974). <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em>, 2nd ed. New York: Wiley-Interscience.
                </li>
                <li>
                    <strong>Kα2 Stripping Algorithm:</strong><br>
                    Rachinger, W. A. (1948). "A Correction for the α1α2 Doublet in the Measurement of Widths of X-Ray Diffraction Lines." <em>Journal of Scientific Instruments</em>, <strong>25</strong>, 254-255.
                </li>
                <li>
                    <strong>Alternative Indexing Methods:</strong><br>
                    Ito, T. (1949). "A General Powder X-ray Photography."<em>Nature</em>, 164, 755-756.<br>
                    Werner, P.-E., Eriksson, L., & Westdahl, M. (1985). "TREOR, a semi-exhaustive trial-and-error powder indexing program for all symmetries." <em>Journal of Applied Crystallography</em>, <strong>18</strong>, 367-370.<br>
                     Visser, J. W. (1969). "A fully automatic program for finding the unit cell from powder data." <em>Journal of Applied Crystallography</em>, <strong>2</strong>, 89-95.<br>
                     Le Bail, A. (2004). "Monte Carlo Indexing with McMaille". <em>Powder Diffraction</em>, <strong>19(3)</strong>, 249-254.<br>
                     Boultif, A. & Louër, D. (2004). "Powder pattern indexing with the dichotomy method." <em>Journal of Applied Crystallography</em>, <strong>37</strong>, 724-731.
                    </li>
                <li>
                    <strong>Previous version:</strong><br>
                    Dragoe, N. (2001). "PowderV2: a suite of applications for powder X-ray diffraction calculations." <em>Journal of Applied Crystallography</em>, <strong>34</strong>, 535.
                </li>

            </ol>
            <div class="footer">
                <p>Help Guide created by an AI Assistant, updated on 08 Nov 2025.</p>
            </div>
        </section>

    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('#toc a');
        const mainContent = document.getElementById('main-content');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => link.classList.remove('active'));
                    const activeLink = document.querySelector(`#toc a[href="#${id}"]`);
                    if (activeLink) activeLink.classList.add('active');
                }
            });
        }, { root: mainContent, rootMargin: "0px 0px -80% 0px" });

        sections.forEach(section => observer.observe(section));

        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                navLinks.forEach(l => l.classList.remove('active'));
                this.classList.add('active');
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);

                if (targetElement) {
                    mainContent.scrollTo({
                        top: targetElement.offsetTop - 32,
                        behavior: 'smooth'
                    });
                }
            });
        });

        const updateActiveLink = () => {
            let currentActive = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top >= 0 && rect.top <= mainContent.clientHeight * 0.2) {
                    currentActive = section.getAttribute('id');
                }
            });

            if (currentActive) {
                navLinks.forEach(link => link.classList.remove('active'));
                const activeLink = document.querySelector(`#toc a[href="#${currentActive}"]`);
                if (activeLink) activeLink.classList.add('active');
            } else {
                // If no section is clearly active at the top, default to the first one
                 if (mainContent.scrollTop < sections[0].offsetTop + sections[0].offsetHeight) {
                     navLinks.forEach(link => link.classList.remove('active'));
                     if (navLinks.length > 0) navLinks[0].classList.add('active');
                 }
            }
        };

        // Update active link on scroll
        mainContent.addEventListener('scroll', updateActiveLink);

        // Initial update after load
        setTimeout(updateActiveLink, 150);
    });
</script>

</body>
</html>